
---

В отличии от обычных базовых алгоритмов, у которых строго определены задачи, которые они решают, дано формальное описание и подробно описано как эти алгоритмы работают, метод двух указателей - это прием, имеющий много вариаций и не имеющего строго формального описания.

При этом - владеть этим приемом очень важно, так как его любят давать на собесах, ну и плюс он улучщает навык написания аккуратного кода (особенно с ошибками на +1, -1 - любимые ошибки всех на алгоритмах).

Поэтому данный метод будем разбирать на примерах:

---
## Задача №1

- Дан массив целых **положительных** чисел.
- Найти в нем отрезок, сумма элементов которого равна **X**.\
- Пример
	- `A = {3, 1, 5, 6, 2, 8, 7}`
	- `X = 13`
Идея нахождения отрезков:
1.  Проверяем сумму с таргетным значением
	![[algo-foundation-two-pointers-1.png]]
2. Из-за того, что сумма меньше искомой - сдвигаем правую границу
	![[algo-foundation-two-pointers-2.png]]
3.  Так как сумма стала больше, чем таргетное значение - сдвигаем левую границу:
	![[algo-foundation-two-pointers-3.png]]
	 Ну вот так мы и нашли отрезок
То есть ключевая идея решения этой задачи такая:
- Пока сумма текущего отрезка меньше таргетной - сдвигаем его правую границу, когда сумма текущего отрезка стала больше искомой, сдвигаем левую границу на один вправо.

Вот пример кода на С++ (стоит понимать, что тут надо вывести индексы, которые нумеруются с единицы):

```cpp
struct Segment
{
    int left = 0;   // Эти значения left и right в моей реализации считаются
    int right = -1; // за "не найдено"
};

Segment TheTwoPointersMethod(
    const std::vector<int>& data,
    int targetValue
)
{
    Segment segment;
    
    int right = 0;
    int sum = 0;
    for (int left = 0; left < data.size(); ++left)
    {
        while (right < data.size() && sum < targetValue)
        {
            sum += data[right];
            ++right;
        }
        if (sum == targetValue)
        {
            ++left;
            segment.left  = left;
            segment.right = right;
            break;
        }
        sum -= data[left];
    }
    
    return segment;
}

```

Данный алгоритм работает за $O(N)$ Из-за того, что есть ограничение `l <= r` и цикл `while()` может максимум дойти только до `data.size()`.
 
 ### Доказательство Корректности

Надо доказать два тезиса:
- Если искомого отрезка нет, наш алгоритм вернет пустой отрезок
- По построению наш алгоритм поддерживает в переменной `sum` сумму на отрезке
	
1. Если искомого отрезка нет, наш алгоритм вернет пустой отрезок
	По построению наш алгоритм поддерживает в переменной `sum` сумму на отрезке нашего массива. Таким образом, если искомого отрезка нет, то и наш алгоритм его не найдет, он вернет пустой отрезок, потому что он принимает решение, что отрезок найден на основании суммы на каком-то отрезке. Поэтому если нет такой ссумы, которую мы ищем - то наш алгоритм ее и не найдет
2. Докажем, что наш алгоритм находит отрезое с заданной суммой когда он есть.
	Для этого пойдем от обратного и предположим, что это не так. Наш алгоритм не нашел отрезок, хотя он был.
	Рассмотрим следующую ситуацию, пусть желтым обозначен отрезок, который мы ищем:
	![[algo-foundation-two-pointers-4.png]]
	Так как мы доказываем от противного, то что бы отрезок не был найден, когда `l` стал указывать на левую границу отрезка:
	![[algo-foundation-two-pointers-5.png]]
	То тогда указатель `r` должен быть правее, чем правая граница отрезка:
	![[algo-foundation-two-pointers-6.png]]
	При этом мы сдвигаем указатель `l` в тот момент, когда текущая накопленная сумма оказалась больше таргетной:
	![[algo-foundation-two-pointers-7.png]]
	Но в такой ситуации `r` не может находиться правее нужного отрезка:
	![[algo-foundation-two-pointers-8.png]]
	Ну и в любом случае теперь `r` не будет никуда сдвигаться, тк сумма не может быть больше таргетной. А значит в итоге мы получим:
	![[algo-foundation-two-pointers-9.png]]
	 
---

## Задача № 2

- Дано два отсортированных массива целых чисел
- Найти в них пару элементов, сумма которых равна `X`
- Пример
	- `A = {0, 2, 5}, B = {-3, -1, 2}, X = 4`
	- Ответ: пара индексов `(1; 2)`

Идея решения этой задачи:
	![[algo-foundation-two-pointers-10.png]]
	 Рассмотрим вот такой кейс, что сумма двух значений больше, чем нужная нам. В таком кейсе мы вроде бы можем уменьшить `i`, а так же и `j` а может быть и оба индекса. Пока что не совсем понятно как праильно поступить.
	 Тогда попробуем зайти с другого конца: и поставить один указатель в начало, второй указатель в конец: ![[algo-foundation-two-pointers-11.png]]
	 Что нам надо делать в этой ситуации, когда `A[i] + B[i] > X`? Конечно же уменьшить `j`, потому что эти два массива отсортированы и по определению, если уменьшить один индекс - общая сумма точно уменьшится или хотя бы останется такой же.
	 Получаем: ![[algo-foundation-two-pointers-12.png]]
	 Все еще такой же кейс, поэтому сместим `j` еще раз:![[algo-foundation-two-pointers-13.png]]
	 Теперь сумма стала меньше, чем таргетное `X`, уменьшать `j` больше нет смысла, поэтому мы увеличим `i`: ![[algo-foundation-two-pointers-14.png]]
	 Сумма теперь больше `X` - значит уменьшаем `j`: ![[algo-foundation-two-pointers-15.png]]
	 Теперь сумма меньше искомой, а значит снова увеличиваем `i`: ![[algo-foundation-two-pointers-16.png]]
	 Сумма все ещё меньше искомой, значит снова увеличиваем `i`:  ![[algo-foundation-two-pointers-17.png]]
	 И таким образом мы нашли искомую сумму!

Теперь мы оформим данный алгоритм словами:
- Ставим указатель `i` в начало первого массива, а указатель `j` в конец второго массива.
- Пока текущая сумма больше искомой, уменьшаем `j`.
- Увеличиваем `i` на 1 и возвращаемся на прошлый шаг.

### Реализация

```cpp
struct Indexes
{
    int first { 0 };
    int second { 0 };
};

Indexes TheTwoPointersMethod(
    const std::vector<int>& firstSortedVector,
    const std::vector<int>& secondSortedVector,
    int targetNumber
)
{
    Indexes result;
    
    int right = secondSortedVector.size() - 1;
    for (int left = 0; left < firstSortedVector.size(); ++left)
    {
        while (right >= 0 
            && firstSortedVector[left] + secondSortedVector[right] > targetNumber
        )
        {
            right -= 1;
        }
        
        if (right >= 0 && targetNumber == firstSortedVector[left] + secondSortedVector[right])
        {
            result.first = left + 1;
            result.second = right + 1;
            break;
        }
    }
    
    return result;
}
```