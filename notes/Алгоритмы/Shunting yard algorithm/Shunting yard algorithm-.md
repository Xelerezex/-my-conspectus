---

## Ресурсы:

1. [Shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm).
2. [Operator associativity](https://en.wikipedia.org/wiki/Operator_associativity)
3. [Token.](https://en.wikipedia.org/wiki/Lexical_analysis#Token)

---

  

На русский это примерно переводится, как алгоритм _Маневровой Станции_. В компьютерных науках данный алгоритм относится, к типу: _алгоритмы для парсинга_ арифметических или логических выражений, находящихся в _инфиксной нотации_.

- **Какие существуют нотации:**
    1. _Постфиксная нотация_ (обратная польская нотация), выражение типа `3 - 4 + 5` примет вид: `3 4 - 5 +`.
    2. _Префиксная нотация_ (польская нотация) , выражение типа `3 - 4 + 5` примет вид: `-3 4 + 5`.
    3. _Инфиксная нотация_ - это есть обычное представление выражения: `3 - 4 + 5`.

Выходные данные, после отработки алгоритма, представляют собой выражение либо в _постфиксной нотации_, либо в _абстрактном синтаксическом дереве_.

- **Абстрактное синтаксическое дерево:**
    
    Это дерево, которое показывает абстрактную синтаксическую структуру текста (часто это код какого-то языка) записанную формально. Каждая нода в дереве, обозначает одну конструкцию, встречающуюся в тексте. Дерево является “_абстрактным_” - значит, что в нодах представлены не все детали реального синтаксиса текста, а скорее только структурные или связанные с содержанием детали.
    
    Данное дерево представляет алгоритм Евклида:
    
    ![[abstract-syntax-tree.svg.png]]
    
    Код, по которому составлено данное дерево:
    
    ```Bash
    while b ≠ 0:
        if a > b:
            a := a - b
        else:
            b := b - a
    return a
    ```
    

Алгоритм маневровой станции был изобретен Эдсгером Дейктрой и назван в честь маневровых станций для поездов.

Ровно как и Польская Нотация - этот алгоритм основан на применении стека. Стоит так же помнить, что все правильные инфиксные нотации парсятся правильно, но алгоритм не отклоняет все неправильные варианты. К примеру, вариант `1 2 +` не правильная инфиксная нотация, но он спарсится в `1 + 2` . Однако алгоритм может отклонять выражения с несовпадающими круглыми скобками.

### Графическое представление:

![[shunting-yard-algo.svg.png]]

Если приглядеться к рисунку, то мы увидим классическую развязку железной дороги, или другими словами - маневровую станцию. `input` отдает только по одному символу за итерацию.

Есть три важных условия выполнения алгоритма:

1. Если найдена переменная или число, то оно отправляется в `output` (_pic. a, c, e, f_).
2. Если найден символ, считающийся оператором, то он отправляется в `operator stack` (_pic. b, d, f_).
3. Если старшинство (_precedence_) оператора (1), отправляемого в `operator stack` меньше, чем у оператора (2), который лежит на верхушке `operator stack` , отправляется в `output` . И только после этого оператор (1) кладется в `operator stack` (_pic. j_).
4. Если старшинство (_precedence_) оператора (1), отправляемого в `operator stack` равно, лево-ассоциированному оператору (2), который лежит на верхушке `operator stack` , отправляется в `output` . И только после этого оператор (1) кладется в `operator stack` (_pic. j_).
5. В конце, когда `input` пуст, все операторы из `operator stack` выталкиваются в `output`.

### Детальный пример:

Дано выражение:

```LaTeX
3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3 
```

Далее приведем основные свойства, используемых нами, операторов:

|Оператор|Старшинство|Ассоциативность|
|---|---|---|
|^|4|Правая|
|*|3|Левая|
|/|3|Левая|
|+|2|Левая|
|-|2|Левая|

А теперь пошагово разберем работу алгоритма:

|Токен|Действие|Вывод (RPN)|Стек операторов|Заметки|
|---|---|---|---|---|
|3|Добавить токен в `output`|`3`|||
|+|Добавить токен в `operator stack`|`3`|`+`||
|4|Добавить токен в `output`|`3 4`|`+`||
|*|Добавить токен в `operator stack`|`3 4`|`* +`|У оператора `*` выше старшинство, чем у `+`. Потому он идет в `operator stack`|
|2|Добавить токен в `output`|`3 4 2`|`* +`||
|/|Извлечь из `operator stack` в `output`|`3 4 2 *`|`+`|У оператора `/` и `*` одинаковое старшинство. Поэтому * идет в `output`|
||Добавить токен в `operator stack`|`3 4 2 *`|`/ +`|У оператора `/` выше старшинство, чем у `+`. Поэтому он идет в `operator stack`|
|(|Добавить токен в `operator stack`|`3 4 2 *`|`( / +`||
|1|Добавить токен в `output`|`3 4 2 * 1`|`( / +`||
|-|Добавить токен в `operator stack`|`3 4 2 * 1`|`- ( / +`||
|5|Добавить токен в `output`|`3 4 2 * 1 5`|`- ( / +`||
|)|Извлечь из `operator stack` в `output`|`3 4 2 * 1 5 -`|`( / +`|Извлекать операторы в `output` пока в `operator stack` не встретится `(`|
||Извлечь верхнее значение из `operator stack`|`3 4 2 * 1 5 -`|`/ +`|Так скобки просто выкидываются из `operator stack`|
|^|Добавить токен в `operator stack`|`3 4 2 * 1 5 -`|`^ / +`|У оператора `^` выше старшинство, чем у `/`. Поэтому он идет в `operator stack`|
|2|Добавить токен в `output`|`3 4 2 * 1 5 - 2`|`^ / +`||
|^|Добавить токен в `operator stack`|`3 4 2 * 1 5 - 2`|`^ ^ / +`|`^` - правосторонний оператор, поэтому он идет в `operator stack`|
|3|Добавить токен в `output`|`3 4 2 * 1 5 - 2 3`|`^ ^ / +`||
|Конец|Весь `operator stack` переходит в `output`|`3 4 2 * 1 5 - 2 3` `^ ^ / +`|||

- Possible tokens code:
    
    ```Plain
    {'_',10,ASSOC_RIGHT,1,eval_uminus},
    {'^',9,ASSOC_RIGHT,0,eval_exp},
    {'*',8,ASSOC_LEFT,0,eval_mul},
    {'/',8,ASSOC_LEFT,0,eval_div},
    {'%',8,ASSOC_LEFT,0,eval_mod},/* Старшинство токена *//* Старшинство токена */
    {'+',5,ASSOC_LEFT,0,eval_add},
    {'-',5,ASSOC_LEFT,0,eval_sub},
    {'(',0,ASSOC_NONE,0,NULL},
    {')',0,ASSOC_NONE,0,NULL}
    ```
    

- ъявление анонимной функции (лямбды) можно считать объявлением без имени либо выражением
- Объявление переменной можно считать как про