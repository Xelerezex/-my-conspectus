
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-10-grouping-in-ff.zip`

---

Вы написали метод из 30 строк. В нём вы замечаете фрагменты, которые вроде бы выполняют более мелкие действия. Разбиваете ли вы этот метод на более мелкие методы, по SRP? Если да, если фрагменты действительно достаточно автономные, то вы правильно обозначили логические границы, но при этом добавили в код некоторую косвенность/перенаправление. Кроме того, разбиение на части может привести к появлению большого числа методов, или методов с большим количеством параметров.

Если же вы не разбиваете его, то всё будет наоборот: вы избавляетесь от множества методов и внутренней вложенности вызовов, однако явные границы между логикой теряются.

Но здесь есть простой приём, когда вы можете и рыбку съесть, и косточкой не подавиться. Он доступен в любом Си-подобном языке, где используются фигурные скобки для группировки кода внутри функций, и средства редактора IDE для схлопывания кода.

Например, у вас есть метод InitDriver, внутри которого имеются три шага логики: поиск водителя, отправка ему сообщения, и заключительные проверки, что сообщение успешно ушло, и что инвариант класса сохранён. Вы не делите его на три физических метода, а группируете соответствующие части кода внутри { } , предваряя их либо явной синтаксической меткой, обозначающей смысл этого кода -- FindDriver: , SendStartupMessage: , SanityCheck: (если язык это позволяет, как С++), либо ставите соответствующий комментарий, а сам код внутри { } схлопываете.

Таким образом, вы придерживаетесь "встраиваемого проектирования", когда ваш код явно сохраняет свой смысл на более высоком уровне абстракции, нежели он сам. Если вам когда-нибудь понадобится таки явно разделить этот метод на физические подфункции, то уже не нужно будет выяснять, как это сделать -- всё уже готово!

Дополнительное преимущество этого стиля такое, что он позволяет понять, какие локальные переменные будут "жить" во всём теле функции, а какие используются только локально внутри своих блоков кода.

Аналогичная идея также хорошо работает при размещении функций в файле, или методов в классе. Здорово разбивать их на логические подкатегории, разделяя красивым комментарием (в C# есть например удобная прагма #region). Тут уже не всегда удаётся организовать соответствие каждого такого размеченного кластера определённому проектному замыслу. Тем не менее, это очень помогает быстро понять, что находится в файле. А если вы захотите затем разделить этот файл на несколько частей, то всё уже будет сделано за вас.

![[ff.png]]
