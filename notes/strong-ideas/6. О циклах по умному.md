
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-6-loops.zip`

--- 

Каждый раз, когда вы пишете цикл, вы делаете это с одной из нескольких целей. Понимание программы -- это **искусство восстановления замысла по коду**, и тут соответственно будет очень полезен навык быстрого распознавания нескольких разновидностей циклов. А главное -- понимание циклов с т.зр. функционального программирования.

Например, стандартные библиотеки большинства языков содержат тот или иной вариант функции **fold**. Она наверное более известна как `reduce`, а различие `fold` и `reduce` лишь в том, что для `fold` можно задавать начальное значение в аккумуляторе, а `reduce` таковым сразу берёт результат над первыми двумя элементами.

Есть такая распространённая разновидность циклов, как итерация по коллекции, которая на каждом шаге вычисляет результат на основе текущего узла + предыдущий результат. Знакомые с `fold` сразу её распознают

```java
resStr = false;
for (int i = 0; i < str.length(); i++)
{
	resStr = resStr && Character.isAlphabetic(str.charAt(i));
}
```

=>

```java
boolean resStr = str.chars()
    .mapToObj(c -> (char) c)
    .reduce(true, (acc, c) -> acc && Character.isAlphabetic(c), (a, b) -> a && b);
```

---

Гораздо менее известное семейство циклов -- это **unfold**, который в стандартных библиотеках найти гораздо сложнее. Он в некотором смысле обратен fold и формирует поток значений на основе исходной части состояния.

Простой пример: логика, обратная предыдущему.

```java
public static void main(String[] args)
{
	String str = "Это была проверка!";
	
	List<Boolean> alphabeticChecks = unfold(
		i -> i < str.length(),
		i -> Character.isAlphabetic(str.charAt(i)),
		i -> i + 1,
		0
	);
	
	System.out.println(alphabeticChecks);
}
```

Подумайте, как бы вы реализовали такой unfold ?

(пауза)

(спойлер)

```java
public static <T, R> List<R> unfold(
	Predicate<T> predicate, 
	Function<T, R> generator, 
	Function<T, T> next, 
	T seed
)
{
	List<R> result = new ArrayList<>();
	T current = seed;
	
	while (predicate.test(current))
	{
		result.add(generator.apply(current));
		current = next.apply(current);
	}
	
	return result;
}
```

---

Вот более практический пример unfold -- [функция рисования линий по алгоритму Брезенхэма из Redis](https://github.com/redis/redis/blob/b002d2b4f1415f4db805081bc8f5b85d00f30e33/src/lolwut.c#L126). С помощью цикла на основе начальных значений формируем набор точек (попиксельную линию).

---

Однако **ещё более продуктивный подход в понимании цикла -- это когда он вообще не будет написан:)**

Посмотрите этот, без преувеличения, выдающийся доклад ["GoingNative 2013 C++ Seasoning"](https://www.youtube.com/watch?v=W2tWOdzgXHA)
Sean Parent начинает выступление со слайда с куском кода из некоторой версии Chromium OS. Это цикл со вложенными if (за что я строго ругаю даже начинающих :), который, судя по всему, выполняет перестановку панелей. И всего несколько слайдов спустя он преобразует этот код в несколько строк вообще без циклов и условий: более читабельный, более эффективный, более простой и более общий.

Да, вот такой ужасный код пишут в Гугле "знатоки алгоритмов", прошедшие, типа, через сложнейшие собеседованя.

За этим стоит его стиль, когда **любое использование цикла в середине более крупной функции нужно попытаться заменить генериками**. В результате этот весьма специфический пример оказывается просто частным случаем подходящей функции из стандартной библиотеки C++.

Я обычно принижаю значение всяческих рефакторингов, утверждая, что они либо не доходят до корня проблемы, либо что лучше развивать более общий навык, который делает предложенный рефакторинг тривиальным. На этот раз я впечатлён!

И хотя навык, на который здесь ссылаются -- распознавание определённого семейства циклов -- весьма специфичен, он предлагает нам более универсальный подход: верить, что каждая функция с циклом может быть отрефакторена подобным образом, и постоянно искать такие обобщения.

**Никаких циклов, если их можно заменить подходящей абстракцией**.
##### Пример 1: Удаление чётных чисел из списка.

```java
public List<Integer> removeEvenNumbers(List<Integer> numbers)
{
    List<Integer> result = new ArrayList<>();
    for (Integer number : numbers)
    {
        if (number % 2 != 0) 
        {
            result.add(number);
        }
    }
    return result;
}
```

=>

```java
public List<Integer> removeEvenNumbers(List<Integer> numbers)
{
    return numbers.stream()
		.filter(number -> number % 2 != 0)
		.collect(Collectors.toList());
}
```

##### Пример 2: Преобразование списка строк в их длины.

```java
public List<Integer> stringLengths(List<String> strings)
{
    List<Integer> lengths = new ArrayList<>();
    for (String str : strings)
    {
        lengths.add(str.length());
    }
    return lengths;
}
```

=>

```java
public List<Integer> stringLengths(List<String> strings)
{
    return strings.stream()
		.map(String::length)
		.collect(Collectors.toList());
}
```

##### Пример 3: Подсчёт суммы всех чисел в списке.

```java
public int sumList(List<Integer> numbers)
{
    int sum = 0;
    for (Integer number : numbers)
    {
        sum += number;
    }
    return sum;
}
```

=>

```java
public int sumList(List<Integer> numbers)
{
    return numbers.stream()
		.mapToInt(Integer::intValue)
		.sum();
}
```

##### Пример 4: Поиск индекса элемента по условию.

```java
public int findIndexByCondition(List<Integer> list)
{
    for (int i = 0; i < list.size(); i++)
    {
        if (list.get(i) % 2 == 0)
        {
            return i;
        }
    }
    return -1;
}
```

=>

```java
public int findIndexByCondition(List<Integer> list)
{
    return IntStream.range(0, list.size())
		.filter(i -> list.get(i) % 2 == 0)
		.findFirst()
		.orElse(-1);
}
```

---

Вообще, постоянный поиск абстракций в коде приучает человека к формированию всё более обширного и, главное, всё более универсального набора инструментов.

Те семейства циклов, которые рефакторил Parent, представимы как чистые функции -- если немного прищуриться, то можно распознать их императивные варианты (например, вывод каждого элемента списка можно считать map-ом). Тут ещё нюанс в том, что Parent трудится в экосистеме C++, в которой имеется свой собственный словарь (онтология) общих императивных функций. Поэтому с ходу не понять, что код в некоторых его примерах, например, представляет экземпляр операции `std::stable_partition`.

Кстати, подумайте, не заглядывая в документацию, как она работает, если на вход подаётся

```java
{0, 0, 3, -1, 2, 4, 5, 0, 7} и функция-предикат [](int n) { return n > 0; }
```

а результатом становится

```java
3 2 4 5 7 0 0 -1 0
```

?

Другие моменты -- например, "отсутствие raw-указателей", труднее переносимы за пределы C++, я его не так хорошо знаю. Тем не менее, как минимум первую половину этого выступления я рекомендую как очень хороший и полезный материал по программной инженерии, благо сегодня любое видео можно легко и просто транскрибировать в текст или сопроводить русскими субтитрами.

