
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-16-3-rules-of-simple-project-design.zip

---

Как насчёт того, чтобы защитить от ошибок дизайн (в архитектурном смысле) вашего проекта? Как сделать его более удобным для развития и сопровождения?

Процитирую книгу **"Дизайн привычных вещей" Дональда Нормана**:

_"Порочный круг начинается так: когда у вас что-то не получается, вы думаете, что это ваша вина. Поэтому вы считаете, что не можете справиться с этой задачей. В результате в следующий раз, когда вам придется выполнять подобное задание, вы уже полагаете, что не сможете, и даже не пытаетесь. В результате у вас ничего не получается, как вы и думали. Вы попали в ловушку самоисполняющегося пророчества"._

Рекомендация Нормана такая:

_"**Переложите вину на машины и их конструкцию**. Долг машин и тех, кто их проектирует -- прежде всего понимать нужды людей"._

В тему ещё можно упомянуть **выученную беспомощность по Селигману**.

Да, я постоянно призываю брать на себя максимум ответственности, в том числе и за то, что нам неподвластно :) В данном случае как раз имею в виду, что, допустим, вы миддл или сеньор, который спроектировал некоторую (под)систему, и когда джуниор, развивая эту систему, делает ошибку, которую ранее уже делали другие разработчики, то это означает, что виноват не джуниор, а вы как проектировщик: **ошибки разработчиков почти всегда есть следствие плохого дизайна системы**.

```java
// Глобальный класс-синглтон, управляющий всеми пользователями в системе
public class GlobalUserManager
{
    private static GlobalUserManager instance;
    private Map<String, User> users = new HashMap<>();
    private Connection dbConnection;
    private Config config;
    private Logger logger;
    
    private GlobalUserManager()
    {
        // Инициализация всего и вся прямо в конструкторе
        dbConnection = DatabaseFactory.createConnection();
        config = ConfigLoader.load();
        logger = LoggerFactory.createLogger();
    }

    public static GlobalUserManager getInstance()
    {
        if (instance == null)
        {
            instance = new GlobalUserManager();
        }
        return instance;
    }

    // Метод, который делает слишком много всего
    public void processUser(String userId)
    {
        User user = users.get(userId);
        
        // Прямая работа с БД внутри бизнес-логики
        String query = "UPDATE users SET last_login = NOW() WHERE id = " + userId;
        dbConnection.executeUpdate(query);
        
        // Прямая работа с внешними сервисами
        if (user.getRole().equals("PREMIUM"))
        {
            NotificationService.sendPremiumEmail(user.getEmail());
            BillingService.checkSubscription(user);
            RewardService.giveBonus(user);
        }
        
        // Логика, смешанная с логированием
        logger.info("Processing user " + userId);
        
        // Сложная бизнес-логика вперемешку с техническими деталями
        if (config.getBoolean("feature.enabled"))
        {
            try
            {
                user.updateProfile();
                cache.invalidate(userId);
                messageQueue.send(new UserEvent(user));
            }
            catch (Exception e)
            {
                // Общий catch всех исключений
                logger.error("Error occurred", e);
            }
        }
    }
}
```

Этот код демонстрирует несколько серьёзных проблем высокоуровневого дизайна ...
(пауза на подумать)
- Синглтон делает код сильно связанным и сложно тестируемым;
- Смешивание разных уровней абстракции (бизнес-логика + работа с БД + внешние сервисы);
- Нарушение SRP;
- Жёсткие зависимости между компонентами;
- В данном случае неплохо бы подошла инверсия зависимостей;
- Прямая работа с внешними ресурсами без абстракций.

Такой дизайн практически вынуждает разработчиков ...
(пауза на подумать)
- Писать трудно тестируемый код;
- Дублировать и копипастить логику;
- Создавать сложные и запутанные зависимости;
- Нарушать принципы SOLID;
- Смешивать разные уровни абстракции;
- Усложнять выявление ошибок...

Даже опытный программист, работая с такой архитектурой, будет вынужден писать код, содержащий потенциальные проблемы, так как сама структура модуля подталкивает к неправильным решениям.

Классическое (ошибочное) решение (ведущее к выученной беспомощности) -- это указать джуниору на ошибку, задокументировать её как "типичную", и в следующий раз тыкать кодировщиков в эту документацию. Именно так и формируется порочный круг.

Правильно так: пересмотреть дизайн системы, и перепроектировать его так, чтобы подобные ошибки более не могли возникать.

---
Например, разрабатывается шахматная программа. Есть класс `Game` с методом `Move(int color)`. Код, который обычно джуниор пишет "в лоб", выглядит примерно так:

```java
Game game = new Game();
...
game.Move(WHITE);
game.Move(BLACK);
```

Хороший миддл вполне может потребовать, чтобы метод `Move(int color)` был декомпозирован на два явных: `MoveWhite()` и `MoveBlack()`, так как в игре явно присутствуют ровно два игровых цвета, качественно отличающихся друг от друга (белые всегда ходят первыми, чёрные всегда ходят вторыми). Мы избавляемся от ненужного параметра, а код становится более наглядным и менее хрупким.

Но пока это косметическая правка, потому что джуниор случайно может написать

```java
game.MoveWhite();
game.MoveWhite();
game.MoveBlack();
game.MoveBlack();
```

Программа работает нормально, а выловить такую логическую ошибку будет не очень легко.

---

Сеньор советует применить такую тактику: класс `Game` отслеживает внутри себя, какой цвет ходил последним, и если метод `MoveWhite()` или `MoveBlack()` вызывается два раза подряд, то он генерирует исключение. Как минимум, такой подход существенно повышает вероятность того, что ошибка наподобие вышеприведённой будет отловлена юнит-тестами. Однако одновременно повышается и вероятность того, что программа будет периодически вылетать во время работы (хотя непонятно, что хуже: такой вылет, или логическая ошибка "два раза походить одним цветом" :).

К делу подключается проектировщик. Его рекомендация -- вообще избавиться от явных ходов за конкретный цвет, инкапсулировав текущее состояние (цвет ходящей стороны) внутрь класса `Game`. Тогда получится нечто вроде:

```java
Game game = new Game();
game.NewGame(); // новая игра
game.Move(); // ходят белые
game.Move(); // ходят чёрные
...
```

Такая схема уже существенно лучше защищена от ошибок кодировщика.

---

Однако в реальной шахматной партии у нас имеются не просто белые и чёрные, а конкретные игроки (белковые или AI). Поэтому схема

```java
Game game = new Game();
game.NewGame(); // новая игра
game.Move();
```

вылетает с исключением в `Move()` -- оказывается, что атрибут `Player` для белой стороны не инициализирован.

Поэтому конструктор `Game` по умолчанию лучше как-то запретить, а игроков указывать явно:

```java
Game game = new Game(PlayerPetya, PlayerRybkaBot);
```

---

Другая распространённая джуниорская ошибка -- использовать базовые типы там, где они плохо подходят (т.н. антипаттерн _Primitive Obsession_, одержимость примитивами). Например, конкретный ход может выполняться так:

```java
game.Move("e2", "e4");
```

Это и есть типичная проблема дизайна. Ведь ничто не мешает вызывать:

```java
game.Move("e16", "x42");
```

Как обходить такие моменты, объясняю на курсе "Быстрая прокачка в ООП", а общий принцип такой, что под каждую смысловую сущность в проекте должен создаваться отдельный тип данных. В данном случае это может быть просто перечисление `Cell { a1, a2, ..., h7, h8 }`, т.к. клетки шахматной доски заведомо фиксированы.

---

Разработчики, использующие систему, которая плохо спроектирована (другими разработчиками), склонны винить в проектных сложностях себя, а не эту систему, которую они используют. Однако это далеко не всегда верно, хотя подобное случается не только с программистами. Дональд Норман приводит много примеров подобных проблем у пользователей физических рукотворных объектов, и показывает выход: вам как прикладному разработчику важно прежде всего понять, что очень часто виновата именно система, которую вы используете, именно "внешняя" система накладывает множество ненужных ограничений и принуждает к кривому стилю. Такое постоянно встречается при использовании популярных веб-фреймворков например.

Главное, что вам самому надо проектировать программное обеспечение с учетом его надёжности и отказоустойчивости. Выше мы рассмотрели три простых способа улучшить дизайн класса, чтобы он был более защищен от ошибок:  
-- **-избавляться от точек генерации исключений**, запрещая соответствующее ошибочное поведение на уровне интерфейса класса;  
-- **отказаться от дефолтных конструкторов без параметров**, и передавать конструктору обязательные аргументы;  
-- **избегать увлечения примитивными типами данных**, разрабатывать прикладную систему типов, на смысловом уровне моделирующую предметную область (используйте типы данных Клетка и Фигура, а не строки или числа).

В результате код получается проще для понимания, использования и развития, и в то же время позволяет избежать распространённых ошибок.