
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-11-self-doc.zip`

---
_Далее и под самодокументирующимся кодом, и под самодокументируемым кодом понимается одно и то же :)  
Имеется в виду, что код настолько выразителен, что он воспринимается и как код, и как документация к самому себе._

Одна из самых странных вещей в программной инженерии -- как много людей ненавидят комментарии. Буквально, на самом деле ненавидят. Есть очень авторитетные люди в информатике, которые заявляют, что комментарии -- это признак того, что ваш код плох, и это значит, вы просто не смогли сделать свой код достаточно понятным, чтобы он не нуждался в комментариях.

Комментарии устаревают, комментарии часто врут; код -- единственный источник правды. Вам надо стремиться к самодокументирующемуся коду, с наглядными именами переменных, который хорошо структурирован и хорошо организован, и это всё автоматически делает комментарии излишними. Дескать, другие разработчики поймут, что делает код, просто прочитав его! Таким образом, комментарии в коде не нужны, за редчайшими исключениями.

Очень жаль, но это невозможно. Если вы изучили материалы "3 уровня думания о программе", наверняка уже понимаете, почему.

```java
public final class SecretVaultManager
{
    private final EncryptionEngine encryptionEngine;
    private final VaultDatabase vaultDatabase;
    private final AuthorizationManager authorizationManager;

    public SecretVaultManager()
    {
        this.encryptionEngine = new AdvancedEncryptionEngine();
        this.vaultDatabase = new SecureVaultDatabase();
        this.authorizationManager = new RoleBasedAuthorizationManager();
    }

    public void storeSecret(
	    final String ownerUsername, 
	    final String secretData
	) 
	{
        final User owner =
	        this.authorizationManager.getUserByUsername(ownerUsername);
        final byte[] encryptedData = 
        this.encryptionEngine.encryptData(secretData, owner.getEncryptionKey());
        this.vaultDatabase.storeEncryptedData(owner.getUserId(), encryptedData);
    }

    public String retrieveSecret(
	    final String ownerUsername, 
	    final String secretId
	) 
	{
        final User owner
	        = this.authorizationManager.getUserByUsername(ownerUsername);
        final byte[] encryptedData =
              this.vaultDatabase.getEncryptedData(owner.getUserId(), secretId);
        return this.encryptionEngine.decryptData(
	        encryptedData, 
	        owner.getEncryptionKey()
		);
    }

    private final class User
    {
        private final String userId;
        private final String username;
        private final byte[] encryptionKey;

        private User(
	        final String userId, 
	        final String username, 
	        final byte[] encryptionKey
		) 
		{
            this.userId = userId;
            this.username = username;
            this.encryptionKey = encryptionKey;
        }

        public String getUserId()
        {
            return this.userId;
        }

        public String getUsername()
        {
            return this.username;
        }

        public byte[] getEncryptionKey()
        {
            return this.encryptionKey;
        }
    }
}
```

Вроде бы используются осмысленные и выразительные названия классов, интерфейсов и методов, которые отражают их назначение и ответственность.  
Внутренние классы и интерфейсы (`EncryptionEngine`, `VaultDatabase`, `AuthorizationManager`) чётко определяют разделение ответственностей и роли различных компонентов системы.  
Комментарии внутри методов и классов не нужны, поскольку их назначение и реализация (вроде бы) очевидны.  
Общая архитектура системы(например, паттерн Фасад для `SecretVaultManager`) понятна с первого взгляда.

Да, но...

1. Эта попытка должна быть заблокирована, так как `"alice"` не есть текущий пользователь
```java
SecretVaultManager vaultManager = new SecretVaultManager();
vaultManager.retrieveSecret("alice", "secret123");
```
2. `storeSecret` не проверяет явно, что второй ("секретный") параметр не пустой, что может привести к непредсказуемому поведению.
```java
SecretVaultManager vaultManager = new SecretVaultManager();
vaultManager.storeSecret("bob", "");
```
3. Такая попытка должна быть заблокирована, так как метод `getUserByUsername` должен вернуть `null` для несуществующего пользователя, что приведёт к ошибке.
```java
SecretVaultManager vaultManager = new SecretVaultManager();
vaultManager.storeSecret("non_existent_user", "super_secret");
```
4. Тут аналогичная проблема, уже со вторым параметром.
```java
SecretVaultManager vaultManager = new SecretVaultManager();
vaultManager.retrieveSecret("alice", "non_existent_secret");
```
Даже в таком маленьком коде появляется немало потенциальных проблем. В целом, на эту тему у меня есть отдельный курс **"Незримые механизмы логики"**.

---

Большинство "очевидных" вещей таковыми не являются. Об этом отлично знает любой преподаватель. Неважно, насколько просто и очевидно что-то для вас -- это совсем не так просто и не так очевидно для кого-то другого. Это же относится и к программированию. **Когда вы пишете "самодокументирующийся код", он самодокументируется только для вас**. У вас есть весь этот внутренний контекст (в идеале -- осознанная модель), который делает его самодокументируемым. У других людей такого контекста нет. Им нужно больше информации, чем есть в вашем коде.

Да, вы можете включить часть этой информации в имена переменных и функций, но тут получится только одно-два слова для каждой функции, и вы сможете закодировать только отдельное небольшое понятие. Можно попробовать "закодировать больше", механически разбив функцию на подфункции, но тогда вы усложните код, чтобы сделать его более "читабельным", и получите противоположный эффект. Вы также можете встроить часть этой информации в тесты -- но тогда ваши тесты будут вынуждены сочетать свойства и тестов, и документации, тем самым они нарушат принцип единой ответственности со всеми печальными вытекающими.

Более того, замена комментариев функциями и тестами ведёт к более глубокой, более фундаментальной проблеме: таким методом вы сможете кодировать только определенные классы информации. В программной инженерии этот подход называют "комментировать не что делается, а почему/зачем", чему специально учат начинающих, но **существует огромный класс информации, помимо "почему/зачем", который не может быть закодирован непосредственно в коде**. Это всяческая анти-информация (код ведь по определению говорит, **что надо делать**, но в процессе проектирования очень важно исходить из того, **что не надо делать**, для чего в частности применяем пред- и пост-условия, как на курсах по ООАП). Это всяческие советы на будущее, TODO. Это информация об оптимизации, и т. п. Более того, большинство разработчиков даже не догадываются, что можно документировать такие вещи. Часто в команде даже никакой документации не ведётся, а если она и есть, в неё никто не заглядывает. Но вы можете довольно легко решить эту проблему именно с помощью комментариев.

Да, в интернете огромное количество примеров и статей, показывающих фрагменты "самодокументированного/самодокументирующегося кода". Однако практически у всех у них есть один общий момент: они обучающие, а не рабочие, поэтому представляют собой небольшие и действительно самодостаточные вещи. Однако **разработчику важна прежде всего информация глобального характера: как этот код вписывается в общую программу** (понимание на более высоком уровне дизайна системы). Поведение выразительного кода ничего не может рассказать нам об этом, потому что **сам код не должен ничего знать о программе в целом, иначе это нарушило бы саму идею инкапсуляции!**

```java
/**
 * Этот класс представляет собой компонент для управления пользователями.
 * Он отвечает за аутентификацию, авторизацию и администрирование пользователей.
 *
 * @author Иван Иванов
 * @version 1.0
 * @since 2022-02-22
 */
public class UserManager
{
    /**
     * Менеджер реляционной базы данных для хранения и получения пользователей.
     */
    private DatabaseManager databaseManager;

    /**
     * Конструктор класса UserManager.
     * Инициализирует менеджер базы данных.
     */
    public UserManager()
    {
        databaseManager = new DatabaseManager();
    }

    /**
     * Аутентифицирует пользователя по имени пользователя и паролю.
     * Использует простой подход к аутентификации с помощью базы данных.
     *
     * @param username Имя пользователя
     * @param password Пароль пользователя
     * @return true, если аутентификация успешна, false в противном случае
     */
    public boolean authenticateUser(
	    String username, 
	    String password
    )
    {
        // Получаем пользователя из базы данных
        User user = databaseManager.getUserByUsername(username);
        // Проверяем, соответствует ли пароль пользователя
        return user != null && user.getPassword().equals(password);
    }
    
    /**
     * Добавляет нового пользователя в систему.
     * Использует простой подход к добавлению пользователей в базу данных.
     *
     * @param user Новый пользователь
     * @return true, если пользователь успешно добавлен, false в противном случае
     */
    public boolean addUser(User user)
    {
        // Сохраняем пользователя в базе данных
        return databaseManager.saveUser(user);
    }
}
```

Вроде бы, тут наоборот добавлены хорошие комментарии. Да, но...

1. Возможно, сегодня используется не РСУБД, а NoSQL база, облачное хранилище...

2. "простой подход к аутентификации" сам по себе смотрится стрёмно :)  
В современных системах используются гораздо более сложные и надёжные методы аутентификации (двухфакторная аутентификация, интеграция с внешними провайдерами идентификации...).

3. "простой подход к добавлению пользователей" тоже скорее всего легаси (сегодня применяются более комплексные механизмы регистрации, с проверками на соответствие политике безопасности, возможность самостоятельной регистрации через соцсети и т.д.

---

Давайте посмотрим на известный учебный проект "чистого кода" [FitNesse](https://github.com/unclebob/fitnesse) от Дядюшки Боба. Это отличная и вдобавок довольно большая программа, написанная самым влиятельным Ясным Кодировщиком, поэтому она вполне достойна стать лучшим кандидатом на самодокументированный код.

Возьмём кусочек кода из этого проекта, [пусть такой](https://github.com/unclebob/fitnesse/blob/master/src/fitnesse/Shutdown.java#L29) (функция run).

Читабельно? Очень даже. Вполне понятно, что этот код делает, и какие переменные и функции за что отвечают. Однако если мы попробуем разобраться в этом коде чуть поглубже (например, требуется его как-то расширить), возникнет например вопрос, кто где и как формирует сигнал выключения (чтобы программа завершилась)? Да, напрашивается, что вызов API скрыт внутри buildAndSendRequest(), но это лишь туманный намёк. Внутри buildAndSendRequest мы найдём ResponseParser.performHttpRequest(), внутри которого встретится RequestBuilder.send()...

Этот код не самодокументирующийся, потому что критическая часть его "документации", понимания -- фактический вызов API -- фактически никак не связана с дизайном, с видением и выразительностью структуры кода и проекта на третьем логическом уровне.

**То, что в проекте очевидно для вас, совсем не очевидно для всех остальных**. Вы можете даже не подозревать о существовании подобных проблем, потому что вы сами настолько освоили свой код, что они кажутся вам слишком тривиальными, чтобы в отношении них возникали хоть какие-то вопросы. Вы смотрите на свой код и думаете: "ага, тут везде отличное самодокументирование", потому что некоторая выразительность кода на втором уровне отвечает на тактические вопросы, а дизайн вы пока относительно успешно держите в голове.

Роберт Мартин кстати в этой связи высказался так: _"Этому проекту уже двадцать лет, и у него была долгая и разнообразная история... Идеально? Нет. А что идеально?"_. Речь тут о том, конечно, что информация о дизайне отсутствует в коде не потому, что код недостаточно ясен, а потому, что она не может быть легко закодирована в коде.

Но почему же тема самодокументированного кода столь привлекательна для разработчиков? Тому есть множество весьма законных причин:

- **Комментарии вполне могут рассинхронизировываться с кодом**, что делает их менее надёжными. Хотя то же самое может произойти и с именами переменных, методов и тестов, вероятность этого меньше, так как для их сопровождения требуется меньше усилий, и в IDE обычно наличествуют хорошие инструменты быстрого автоматического рефакторинга.

- **Комментарии загромождают код**, существенно увеличивая объём кода в файле.

- Гораздо легче вспомнить случаи, когда **комментарии оказывались устаревшими** и "обманывали" нас, нежели те случаи, когда комментарии нам помогали.

- В программной инженерии разработано множество теорий и практик по поводу того, как писать "более лучший" код -- но не **как писать хорошие комментарии**.

- Писать хорошие комментарии -- это фактически про общение человека с человеком, **это софт-скилл**, это совершенно иной навык, нежели писать хороший код, и большинство разработчиков не практикуют его прежде всего по этой причине.

Большой процент разработчиков полагает, что комментарии -- это что-то вроде вежливости, и я на 100% согласен: **комментарии -- это учтивость по отношению к другим программистам**. Нам нужно что-то более лучшее, нежели комментарии, или, по крайней мере, нам нужна гораздо лучшая технология написания комментариев!

**Но даже в тех случаях, когда комментарии -- это просто вежливость, они все равно остаются единственным средством, которое позволяет нам сочетать код с выразительным общением**.

Код и тесты недостаточно выразительны, чтобы вместить всю полезную информацию. Мы не можем в достаточной степени самодокументировать наш код. Что с этим делать, рассмотрим постепенно в следующих материалах.