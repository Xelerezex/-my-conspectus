
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-9-3-propers.zip`

---
Качество кода -- понятие слабо ощутимое. Начинающих с первых занятий учат, как правильно именовать переменные и как правильно писать комментарии.

Но очень легко упустить из виду, **а зачем вообще это нужно**.

Есть например вполне авторитетное мнение, что красивый/элегантный код -- это больше отвлекающий момент, как завитушки в архитектуре барокко. Даже гуру computer science заявляют, что просто красивый сам по себе код больше отвлекает внимание, и к качеству это не имеет никакого отношения.

Максималисты тоже говорят, что красота не важна, но с чисто прагматичной точки зрения: подчас в процессе отладки кривого кода вам приходится переворачивать столько камней, что кажется, будто мир под вами рушится. Но 10-кратной скорости можно добиться не тем, что вы будете писать красивый код или станете в 10 раз быстрее отлаживать, а тем, что будете писать код, который вообще не нуждается в отладке.

---

Я стараюсь на курсах разъяснять различные нечёткие термины программной инженерии, которые уже довольно давно были формально описаны в академической литературе.

Давайте попробуем аналогичным образом сформулировать, **а что такое качественный код?**

На этот вопрос не может быть короткого исчёрпывающего ответа. Вопрос "что такое качественный код" сродни вопросу "что такое квантовая физика". Это тема целой области.

Более конкретным будет вопрос "какова цель погони за качеством кода" ("что это мне даст на практике?" :). Ответ на него особенно важен в частности потому, что **создание качественного кода -- ремесло, достойное изучения на протяжении всей жизни**.

Итак, чтобы распознать качественный код, нам надо понять, какими внешними и внутренними свойствами должен обладать качественный код.

Найдите в этом коде 4 ошибки и 3 опасные операции:

```cpp
#include <iostream>
using namespace std;

int main() {
    int *x;
    int a[10];
    for (int i = 0; i <= 10; i++) {
        a[i] = i * i;
    }
    cout << "Введите значение: ";
    cin >> *x;
    cout << "Значение: " << *x << endl;

    char* str = "Это строка";
    cout << "Строка: " << str << endl;
    delete[] str;

    int* ptr = new int(10);
    delete ptr;
    delete ptr;

    return 0;
}
```

## Внешние свойства

### 1. Хороший код -- это готовый, "законченный" код

Все рассуждения о качестве базируются на конечной цели создаваемого проекта. Назначение подавляющего большинства кода -- быть успешно выполненным в виде программы, достигающей некоторой цели, будь то развлечение людей, помощь в уплате налогов, передача данных или тестирование другого кода. Существует также меньшинство кода, созданного для других целей: эксперименты, чтобы проверить, возможно ли нечто; примеры для объяснения алгоритмов или технологий; код, который делает разные необычные вещи (например, распечатывает свои собственные исходные тексты).

Во всех этих случаях код, который не достигает своей цели, не может обладать никакими внешними качествами (как заброшенная стройка не может быть полезным сооружением).

Существуют также нефункциональные требования -- например, производительность. Продукт не может быть качественным, если его заторможенность заставляет пользователей удалять его.

Кроме того, качество кода не зависит от факторов, лежащих за пределами инженерной сферы. Если продукт не вышел на рынок, это не делает его плохим, а директива сверху от начальства, предписывающая сотрудникам обязательно использовать его, не делает его хорошим.

И поэтому **хороший код -- это прежде всего "законченный" код.**

Но на этом конечно останавливаться нельзя. Это только начало.

Потому что даже если вы скажете: "Мы сделали это и отправили работающий продукт заказчику", это не будет оправданием для вашего начальника, когда вы будете объяснять, почему добавление функции поздравления пользователей с днём рождения займет полгода. И это не оправдание для самих себя, когда вы тратите четыре дня на отладку ошибки, которая оказалась опечаткой. Готовый код ещё не значит хороший код.

---
### 2. Хороший код понятен

Есть хорошее определение: инженер -- это тот, кто понимает систему на глубоком уровне.

Отсюда следует, что **для того, чтобы код был хорошим, он должен быть понятным (и чем полнее, тем лучше).**

А иногда (например, для обучающего кода) в этом и заключается вся его цель.

Поэтому нужно, чтобы код был понятен. Но для кого он должен быть понятным?

Для себе и для тех, кто должен его читать.

Точнее, **для тех людей, которые должны его понять в тот момент, когда будут его читать**.

Глупому программисту предлагают новый навык, который позволит сократить его код в 10 раз. "Никто другой этого не поймет" -- заявляет он, отказываясь учиться. На самом деле, под такой маской заниженных ожиданий в отношении других он просто скрывает заниженные ожидания в отношении самого себя (так не хочется выходить из своей зоны псевдо-комфорта).

Сильный и умный, но слегка надменный разработчик точно знает, что его мастерство эффективно, и при этом утверждает: "любой, кому важен этот код, должен освоить технику, которую я использовал". Если его окружают достаточно амбициозные программисты, то это сработает. Однако в 98% случаев интересы его рабочего окружения лежат обычно в другой плоскости, и подобное неосознанное/принудительное решение не будет правильным. Этот разработчик тоже спрятался в своей зоне комфорта под видом заботы о других.

Каждый из них однако может совершенствоваться, выходя из своей зоны комфорта, выясняя, на какие стены теперь ему надо карабкаться, и как это делать, помогая попутно другим заинтересованным (создавая и расставляя лестницы).

**Но элитный программист сам, по своей воле, выходит из зоны комфорта**. Ему не нужны ни подъёмники, ни лестницы, ибо те, кто следует за ним, вдруг неожиданно для самих себя оказываются на вершинах гор.

---
### 3. Хороший код эволюционирует

Программное обеспечение -- это не точка во времени, а система.

Да, есть такие программы, которые, как музейные экспонаты, заключённые в стекло, существуют только ради самих себя, или презентуют кусочек застывшего прошлого. Остальные связаны с другими программами, с платформами, со стеками, с растущим бизнесом и с толпами клиентов. **Они связаны с постоянно меняющимся миром.**

И сегодня, когда многие из нас проводят всю свою жизнь, приклеившись к экранам, созданным на роботизированных фабриках и доставленным на кораблях, управляемых спутниками, **программное обеспечение и есть этот меняющийся мир**.

**Невозможно изменить мир, не изменив его программное обеспечение**. Каждый инженер-программист несёт профессиональное бремя создания программного обеспечения, которое легко изменить. Точнее, которое должно легко переходить из одного желаемого состояния в другое.

Мы должны избегать создания "жёсткого" кода, который вообще трудно изменить.

Мы также не должны создавать хрупкий код, который можно слишком легко изменить так, что он превратится в нечто сломанное.

Хороший код легко расширять и трудно сломать. Сила проектного дизайна заключается не в том, что код может сделать, а в том, что код не может сделать.

---

Но зачем готовиться к будущему, которое, возможно, никогда не наступит? Невозможно предсказать, **как именно** изменится код, что ещё взбредёт в голову менеджерам или заказчикам.

Однако довольно легко предсказать, **что именно** изменится в коде. Или даже **где**.

**И это -- всё, что нужно для создания эволюционирующего кода.**

Да, глупо проектировать систему, предполагая, что по мере того, как жизнь будет идти по предполагаемому нами пути, мы будем вносить определённые предсказуемые изменения. Но еще большая глупость -- проектировать систему так, как будто никаких изменений вообще не произойдёт.