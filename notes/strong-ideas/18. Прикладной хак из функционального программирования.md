
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-18-hack-from-functional-programming.zip

---

Формальная чистота кода в функциональном программировании возведена в ранг святой темы. Действительно, чистые функции не имеют побочных эффектов, соответствующий код хорошо параллелится и легко тестируется, он модульный, он может многократно использоваться, и вообще магически спасает от 108 типов проблем. Однако платой за это становится тот факт, что код программы распухает и начинает занимать всё больший объём.

На практике, как обычно, определённые инженерные компромиссы нередко дают ощутимую полезную выгоду, а жертвовать приходится подчас совсем малым. В частности, можно отказаться от полной частоты, и разрешить стать функциям **"немножечко грязными"** (или, более корректно, **"слабо чистыми" - weakly pure**). Ключевой момент, что у этой "грязи" в computer science есть хорошие формальные обоснования, то есть пачкать функцию надо правильно.

Слабо чистой функции разрешается:  
- изменять свои аргументы (или их атрибуты), если они передаются по ссылке;  
- читать из глобального состояния.

**Единственное, что слабо чистой функции запрещается: изменять глобальные состояния.**

```java
public class GlobalStateExample
{
    // Простые типы - надежная защита от изменений
    private static final int MAX_ATTEMPTS = 3;  // Нельзя изменить
    
    // Для коллекций нужны дополнительные меры
    private static final List<String> STATUSES = Collections.unmodifiableList(
        Arrays.asList("ACTIVE", "PENDING", "CLOSED")
    );
    
    // Для объектов тоже нужны дополнительные меры
    private static final Configuration CONFIG = new Configuration();
    
    public class Configuration
    {
        private Map<String, String> settings;
        
        public Configuration()
        {
            this.settings = new HashMap<>();
            this.settings.put("timeout", "30");
            // Защищаем от модификации
            this.settings = Collections.unmodifiableMap(this.settings);
        }
    }

    // Слабо чистая функция
    public void processUser(User user)
    {
        // OK: Чтение глобального состояния разрешено
        if (user.getAttempts() > MAX_ATTEMPTS)
        {
            throw new IllegalStateException();
        }
        
        // OK: Чтение из неизменяемой коллекции
        if (!STATUSES.contains(user.getStatus()))
        {
            user.setStatus("PENDING");
        }
        
        // Компилятор запретит эти операции:
        // MAX_ATTEMPTS = 4;                    // Ошибка компиляции
        // STATUSES.add("NEW");                // RuntimeException
        // CONFIG.getSettings().put("x", "y"); // RuntimeException
        
        // OK: Модификация параметра разрешена
        user.setLastAccessTime(LocalDateTime.now());
    }
}
```

Для примитивных типов и `String`:  
- `final` полностью запрещает изменение значения  
- Попытка изменения вызовет ошибку компиляции

Для коллекций:  
- Просто `final` защищает только ссылку, но не содержимое  
- Нужно использовать обёртки типа `Collections.unmodifiableList()`, `Collections.unmodifiableMap()` и т.д.  
- Попытка модификации вызовет `UnsupportedOperationException`

Для объектов:  
- `final` защищает только ссылку  
- Нужно делать все поля объекта private и предоставлять только методы чтения  
- Все изменяемые структуры данных внутри объекта также нужно защищать через unmodifiable-обёртки

Для защиты от reflection-атак:

```java
   private static final List<String> STATUSES = 
        Collections.unmodifiableList(
           new ArrayList<>(Arrays.asList("ACTIVE", "PENDING", "CLOSED"))
   );
```

Но тут важно понимать, что `Java` не предоставляет 100% гарантии неизменяемости на синтаксическом уровне (формально из-за reflection, а по сути из-за слабости системы типов), хотя и предлагает достаточные механизмы для обеспечения неизменяемости в обычном использовании:

- `final` для примитивов и ссылок  
- `unmodifiable`- обёртки для коллекций  
- инкапсуляция и правильное проектирование классов (я рекомендую подход через абстрактные типы данных)  
- `defensive copying` при необходимости.

**Defensive copying** хочу отметить отдельно. Тут речь о том что в целом конечно класс может иметь изменяемый объект в качестве поля. Тогда будут два возможных случая, как может измениться состояние изменяемого поля объекта:

1. Мутабельный объект инкапсулирован внутри класса-владельца, и его состояние может быть изменено только этим классом, так как этот класс единственный, который "напрямую" знает о его существовании.

2. Состояние мутабельного объекта может быть изменено как собственным классом, так и его использующими: класс-владелец просто "указывает" на изменяемый объект, который был создан в другом месте.

Оба случая -- допустимые варианты дизайна, но вы должны знать, какой из них подходит для каждого случая. В идеале конечно желательно **всегда придерживаться первого случая**. А если состояние поля изменяемого объекта может изменяться откуда-то из-за пределов класса- владельца, то по-взрослому надо создавать **защитную копию изменяемого объекта**. Так делаем каждый раз, когда он передаётся из геттера или модифицируется внутри сеттеров.

Таким образом мы гарантируем, что внутри класса-владельца всегда будет самая свежая версия мутабельного объекта, и не существует никаких внешних ссылок, через которое его можно было имплицитно изменять. Иначе вызывающему объекту будет легко нарушить инкапсуляцию, изменив состояние объекта, который одновременно виден и ему, и классу-владельцу.

Эти механизмы в совокупности позволяют создавать действительно **неизменяемое глобальное состояние**, которое слабо чистые функции не смогут модифицировать.

---

Может показаться, что изменение аргументов функции и изменение глобального состояния -- это примерно одно и то же, но нет.

Например:

```java
startMusic();
...
stopMusic();
```

Эти функции явно как-то изменяют неведомое глобальное состояние, и также очевидно, что корректность работы зависит от порядка их вызова. Причём `stopMusic()` может располагаться далеко ниже в коде модуля с комментарием наподобие "Завершить приём музыки по сети" (что так и просится на отдельный метод` shutDownMusicNetwork`).

Далее вы просматриваете код и обнаруживаете, что эти два вызова находятся на семи уровнях вложенности друг от друга, и никакой промежуточный код не может быть безопасно удалён.

Если же мы решим использовать слабо чистую функцию, то ситуация, на первый взгляд, изменится не сильно:

```java
startMusic(my_track);
...
stopMusic(my_track);
```

Подразумевается, что объект `my_track` передаётся по ссылке.

Однако теперь наглядно видно, что эти две функции влияют друг на друга. Существует явная зависимость потока данных во втором вызове от первого. Теперь странно будет разнести их на разные уровни вложенности, причём это скорее всего и не будет возможно, так как в обоих вызовах требуется доступ к `my_track`.

---

А лучше всего **запрещать ошибочные последовательности вызова методов на уровне компилятора**: используйте подходы из функционального программирования. У вас ведь есть статические типы, с помощью которых вполне возможно обеспечить и соблюдение порядка вызовов, и иммутабельность по умолчанию.

Пусть например `startMusic()` возвращает объект специального типа, который требуется параметром в `stopMusic()`.