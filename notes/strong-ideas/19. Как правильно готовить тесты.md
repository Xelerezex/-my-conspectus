
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-19-howto-prepare-tests-correctly.zip

---

**"Тестируйте то, что код должен делать, а не то, что он случайно делает".**

Как именно вы определяете, какие писать юнит-тесты?

Например, имеется интернет-магазин, и вам надо написать модульные тесты для контроля за работой корзины покупок, где на товары действует сложная система ценообразования со множеством правил. Возможно, вы напишете тест, который проверяет такой use case, когда покупатель добавляет два товара, затем вводит код для скидки "два по цене одного", а затем удаляет один товар, и скидка должна исчезнуть. Возможно, вы напишете тест, согласно которому, если покупатель сперва вводит код на скидку 20% на всю электронику, а затем добавляет несколько сматрфонов, то скидка успешно применяется и к новым товарам. Возможно, вы проверите, что если клиент добавляет несколько товаров, а затем меняет адрес доставки...

В какой момент вы остановитесь?

Ответ можно получить, только оторвавшись от экрана с редактором кода, и подумав как следует над вопросом "Что на самом деле означает корректность корзины покупок?".

**Корректность подразумевает некоторое множество свойств**. Например, все протестированные сценарии фактически подпадают под одно свойство: произвольные последовательности действий по добавлению/удалению/применению скидки должны давать тот же результат, что и простое поочерёдное добавление всех товаров в итоговую корзину с последующим применением кодов скидок к каждому добавлению.

Другое свойство корректности может заключаться в том, что если товар добавлен в корзину, то этот товар находится в корзине.  
Звучит тривиально? А что, если в корзине уже есть 2^31 товар? Или, более реалистичный случай, который мы уже рассматривали: товар в корзину добавлен, однако из-за непродуманной интеграции бэка с фронтом корзина некоторое время (секунды, минуты...) показывается пустой.

Когда вы сформулировали такие свойства, появляется несколько способов проверить их истинность. Классический способ заключается в том, чтобы придумать набор сценариев, которые отрабатывают все случаи, сводя задачу к проблеме определения того, какие последовательности действий могут привести к "правильному" поведению. Это отдельная тема, по ней создана отдельная методология BDD (Behavior Driven Development).

Другой вариант -- фазз-тестирование на случайных последовательностях, поскольку компьютер в подобных задачах может быть более креативным, чем вы. Или вы можете выбрать третий способ тестирования, знакомый, но часто недооцениваемый: просто ручная проверка кода (code review, метод пристального взгляда).

Не менее важно, что этот подход также через свойства корректности подскажет вам, что **не следует проверять**. В одном из свойств определено, что если клиент заказывает более 10 единиц чего-либо, то должна применяться скидка. Тогда вам не следует проверять, что сама скидка составляет например 10%, достаточно протестировать просто сам факт скидки (уменьшение стоимости).

И сделайте это для всех свойств. Теперь вы точно знаете, что делает каждый юнит-тест, и как они объединяются, гарантируя правильность работы корзины (по вашей модели корректности).

При таком подходе каждая новая функция превращается в довольно забавную игру по определению её свойств корректности. Получившийся список свойств станет вашим руководством для написания всевозможных тестов. А всё, что не получится автоматизировать, будет удобным справочником для отдела QA. Надежность кода и стабильность тестов повышаются.

Мне иногда удавалось убеждать ребят из разных команд, что именно так и нужно проводить тестирование, и где-то это закрепилось как рабочий процесс.

Но затем этот процесс обычно терпел неудачу, потому что декомпозиция корректности на свойства -- это новый и непривычный навык для большинства программистов. Я убедил их, но не обучил до конца. Возможно потому, что этот мой подход -- по сути такая сильно облегченная лайт-версия BDD.

Поэтому сегодня я пытаюсь обучить этому вас.

1 Подумайте
2 Напишите список свойств, который задаёт корректность некоторой фичи
3 По каждому свойству
- выберите способ тестирования (модульный, фазз, ручной, обзор кода...)
- реализуйте

Конкретный пример.

**Фича:** Система подбора предметов

**Описание:** Игрок может подбирать предметы, разбросанные по уровню. Подбор происходит при соприкосновении персонажа с предметом.

**Свойства, задающие корректность:**

- Триггер подбора: При соприкосновении персонажа с предметом должен активироваться триггер подбора.  
- Удаление предмета: После подбора предмет должен быть удален из мира игры или скрыт от игроков.  
- Добавление в инвентарь: Предмет должен быть добавлен в инвентарь игрока (или соответствующий слот).  
- Обновление интерфейса: Интерфейс должен обновиться для отображения изменения состояния инвентаря.  
- Звуковой эффект: При подборе предмета должен воспроизводиться звуковой эффект.  
- Анимация: Персонаж должен выполнить анимацию подбора предмета.  
- Логирование события: Событие подбора должно быть зафиксировано в логах игры для последующего анализа.  
- Проверка условий: Перед подбором необходимо проверить условия (например, наличие свободного места в инвентаре).

Вот возможные способы тестирования каждого свойства для данной фичи.

1. Триггер подбора:  
- Способ: Модульный тест  
- Описание: Проверка активации события подбора через модульные тесты, имитирующие соприкосновение персонажа с предметом.

2. Удаление предмета:  
- Способ: Интеграционный тест  
- Описание: Проверка удаления предмета из мира игры путем интеграции логики подбора и визуализации.

3. Добавление в инвентарь:  
- Способ: Модульный тест  
- Описание: Проверка добавления предмета в инвентарь через модульные тесты, тестирующие функцию обновления инвентаря.

4. Обновление интерфейса:  
- Способ: UI тест  
- Описание: Проверка визуального обновления интерфейса после подбора предмета с использованием инструментов автоматизации UI тестов.

5. Звуковой эффект:  
- Способ: Модульный тест  
- Описание: Проверка воспроизведения звука через модульные тесты, которые проверяют вызов функции воспроизведения звука при подборе предмета.

6. Анимация:  
- Способ: UI тест  
- Описание: Проверка выполнения анимации подбора через инструменты автоматизации UI тестов, которые отслеживают состояние анимации.

7. Логирование события:  
- Способ: Обзор кода  
- Описание: Проверка наличия и корректности логирования событий подбора предметов через ревью кода и анализ лог-файлов.

8. Проверка условий (например, наличие свободного места в инвентаре):  
- Способ: Интеграционный тест  
- Описание: Проверка условий подбора (например, наличие места в инвентаре) через интеграционные тесты, которые охватывают взаимодействие между логикой подбора и состоянием инвентаря.
