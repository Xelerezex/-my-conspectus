
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-8-3-important.zip`

---

Три простых шага правильного кодирования, полезные и джуниорам, и сеньорам.

#### **1. Заставьте это работать.**

Код, который не компилируется, бесполезен. Аналогично, код, который выглядит красиво, но не выполняет поставленную задачу, вероятно, также бесполезен. Вот почему первым шагом в процессе работы всегда будет **приведение вашего кода в рабочее состояние**. Слишком многие программисты зацикливаются на том, чтобы делать что-то "правильно". Корректность в целом важна до внесения изменений, когда мы думаем на третьем логическом уровне, однако, признаемся, у многих ли так получается регулярно?

Чтобы сосредоточиться на том, чтобы всё работало на начальном этапе (и ни на чём другом), идеально придерживаться TDD. Но опять-таки, у многих так получается регулярно?  
_(На треке "Элитный программист" изучите материалы по технике мгновенной перефокусировки.)_

Я нередко составляю список моментов, к которым я хотел бы вернуться в процессе создания кода -- в виде маленького readme под конкретную задачку (в виде комментов в код включать их нежелательно). Определённая логика должна быть заключена во вспомогательный метод? Записываю её его в качестве подзадачки. Жёстко заданная строка при повторном использовании должна быть преобразована в константу? В список добавляется ещё один пункт. Я использую такой readme, чтобы не попасть в другие связанные с этим "кроличьи норы" или "побочные квесты" при реализации первоначальной задачи.

Хотя это кажется достаточно простым делом, нередко одна "простая" задача приводит к двум другим, каждая из которых разрастается ещё на три, как головы Змея Горыныча, и т.д. Не успеете оглянуться, как вы уже выполняете глубокий рефакторинг и реструктуризацию нафигаченного кода на нескольких уровнях -- и всё это во имя исходного задания/тикета. Но не волнуйтесь, достаточно скоро вы разберётесь со всеми пунктами в вашем readme, которые неизбежно вас беспокоят -- но не раньше, чем сделаете свой код "правильным" =>

---

#### **2. Сделайте это правильно.**

Как только ваш код заработал, пришло время **заняться его исправлением** :) Под этим я подразумеваю создание тестов, условно "гарантирующих", что ваш код работает должным образом, а не только в некоторых "счастливых" случаях. Этот шаг направлен на логическую корректность вашего кода. Он не только более-менее обеспечивает функциональность, которую вы ожидаете, но и корректно обрабатывает крайние случаи предпочтительным способом. В этой связи настоятельно рекомендую пройти мой первый курс по Software Design **"Скрытые механизмы логики"**.

Один из отличных инструментов, помогающих в этом -- [мутационное тестирование](https://habr.com/ru/articles/334394/).

Мутационное тестирование (своего рода, мета-тестирование) используют для оценки качества создаваемых вами тестов. Оно изменяет небольшие фрагменты кода, на которые опираются ваши тесты. Этот изменённый код называется **мутантом**. Например, один мутант может изменить условие в вашем исходном коде, из

```java
if (dwarf_is_alive && dwarf_is_drunk)
```

в

```java
if (dwarf_is_alive || dwarf_is_drunk)
```

В идеале, изменение такого условия должно привести к сбою какого-нибудь существующего теста. Если же этого не происходит, значит дела ваши плохи :) Поэтому вам придётся добавить дополнительный тест на подобную ситуацию, чтобы **устранить** мутант. И хотя борьба с мутантами обычно бывает утомительной, гораздо важнее обеспечить уверенность в своём наборе тестов: ведь тесты полезны только в том случае, если они периодически терпят неудачу. Иначе у вас будут по крепости бегать мертвые пьяные гномы (или живые, но трезвые :).

Но если вы вместо... (спойлер)

... написания теста-антимутанта сперва бросились сразу править код, это ужасающая методологическая ошибка ))) Поэтому в частности, ещё и ещё раз порекомендую TDD.

---

Функция, проверяющая, чётное ли число:

```java
public class NumberUtils
{
    public boolean isEven(int number)
    {
        return number % 2 == 0;
    }
}
```

Тесты для неё:

```java
public class NumberUtilsTest
{
    @Test
    public void testIsEven()
    {
        NumberUtils utils = new NumberUtils();
        assertTrue(utils.isEven(2));
        assertFalse(utils.isEven(3));
    }
}
```

И вроде бы всё хорошо, можно добавить проверку на ноль и большое число. Затем запускаем мутационные тесты, по прежнему всё в порядке, всё работает... Однако мутант оказался таким:

```java
public class NumberUtils
{
    public boolean isEven(int number)
    {
        return number / 2 == 0; // мутант
    }
}
```

Очевидно, что логика его стала совсем другая, но наши тесты не сломались, что печально.  
Как минимум, нам требуется такое множество тестов:

```java
        assertTrue(utils.isEven(2));
        assertFalse(utils.isEven(3));
        assertTrue(utils.isEven(4)); // доп.случай
        assertFalse(utils.isEven(1)); // доп.случай
```

Как правильно готовить тесты, чтобы они страховали 98% мутаций? Как минимум, прогонять функцию через большое число случайных тестов (этому я учу на втором начальном курсе :). Желательно также фазз-тестирование, и т.п. Тему правильного тестирования рассмотрим в следующих материалах.

---
#### 3. **Наведите порядок**.

Итак, вы заставили свой код работать "правильно", и как бы "доказали" его корректность с помощью достаточно "надёжных" тестовых случаев -- и **только теперь** вы можете браться **за его правку**. Теперь, когда у вас есть тесты, вы можете свободно выполнять рефакторинг, не опасаясь непреднамеренного изменения существующего поведения. Теперь у вас есть возможность вернуться к (возможно/скорее всего) весьма обширному readme, который вы подготовили, когда создавали свой код на первом шаге. Не стесняйтесь выделять дублирующиеся блоки кода в отдельные функции, переименовывать переменные в более наглядный вид, переносить логику между файлами, и т.д.

Просмотрите свой readme и отметьте каждый пункт по очереди. Весьма возможно, что ваша исходная задача разрослась и стала "множественной", и это нормально, поскольку вы достигли своей главной цели! Теперь вы просто выполняете второстепенные задания. Просто убедитесь, что вы всегда запускаете свой набор тестов заблаговременно и почаще, по мере продолжения рефакторинга (в идеале: после каждой "атомарной" правки). Чем раньше вы узнаете, что случайно нарушили условия теста, тем быстрее сможете вернуться к "зелёному" режиму.

---

Эти три, казалось бы, тривиальных шага помогли и мне, и многим другим, продуктивно выдать много-много качественного кода. Я надеюсь, что они смогут сделать то же самое и для вас.

