
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-14-debugging-as-science.zip

---
Существует ли теория отладки в целом?

С курса карьеры, полезно будет разработчику любого уровня, базовые рекомендации по отладке:  
[Отладка](https://skillsmart.ru/self/zd9sv4d.html)  
[Базовая методика отладки](https://skillsmart.ru/self/f2a22dc80e.html)

---
## Отладка

Как программист, я могу гарантировать вам одно наверняка: **вы потратите много времени на отладку кода**.

В жизни есть определенные вещи, которые неизбежны: смерть, налоги и программисты, делающие ошибки.

Поскольку реально много времени вы будете тратить на отладку кода, то, наверное, это хорошая идея -- иметь хороший навык отладки, не так ли?

К сожалению, многие разработчики - даже очень опытные - ну... весьма слабы в отладке.

Существует множество разработчиков, которые вроде бы реализуют поток новых фич и регулярно набрасывают код в мастер, но кто подтирает за ними тот хаос ошибок, которые они оставляют после себя?

Одно дело знать, как писать хороший код; другое -- знать, как отлаживать самый уродливый код, который вы когда-либо видели в своей жизни, что-то, написанное легендарным Олегом, который собрал первую версию системы за 48 часов на своей кухне, и был вроде как весьма "странным" парнем.

**К счастью, отладка, как и любой другой навык, -- это то, чему можно научиться.**

Если вы применяете правильные техники и практики, вы можете стать в этом великим.

Кто знает? Вам даже это может понравиться.

Ключ к отладке -- осознание того, что все дело в психологическом настрое.

Речь идёт о **систематическом подходе к ошибкам**: не торопитесь, и не ожидаете, что сможете просто найти проблему, войти в неё и быстро выйти с победой.

Речь идет о том, чтобы оставаться спокойным и собранным: атаковать проблему с логической и аналитической точек зрения, а не с эмоциональной.

В этом занятии я изложу системный подход к отладке, который поможет вам избежать этого ужасного первобытного отладочного мышления и выведет ваши навыки отладки на новый уровень.

### Что такое отладка?

Прежде чем погрузиться вглубь, давайте побарахтаемся на мелководье.

Что вообще такое отладка?

Это кажется довольно очевидным, верно?

Вы открываете отладчик и "отлаживаете" проблемы с кодом.

Ага, но вот тут вы ошибаетесь.

**Отладка не имеет никакого отношения к отладчику.**

Отладка имеет полное отношение к поиску источника ошибки в коде, выявлению возможных причин, проверке гипотез -- до тех пор, пока не будет найдена первичная причина -- а затем, в конце концов, устранению этой причины и обеспечению того, что это никогда больше не повторится.

Хорошо, я полагаю, мы можем назвать это так: исправление ошибок.

Суть в том, что отладка -- это нечто большее, чем бесконечная возня в отладчике и правка кода "на удачу" до тех пор, пока он не заработает.

### Первое правило отладки: не используйте отладчик

Эй, Петя, мне надо срочно пофиксить баг!

О, он уже занесён в джиру?

Не волнуйся, я сейчас направлю всю свою интеллектуальную мощь на этот нечестивый ужас.

С таким мышлением, вы, программист, садитесь за свой стол.

Вы запускаете отладчик.

Осторожно проходите по коду, выискивая ту самую строку кода, которая привела к ошибке.

Время кажется размытым, минуты превращаются в часы, часы -- в недели.

И вот ты уже старик, сидящий за клавиатурой, все в том же сеансе отладки, и каким-то образом ты уже "ближе".

Все ваши дети выросли. Ваша жена бросила вас.

Остаётся только... баг.

Первое, что делает большинство программистов, когда они хотят пофиксить ошибку - это запуск старого доброго отладчика и последующая суета в исполняющемся по шагам коде.

Неправильно.

Не делайте этого.

**Отладчик должен быть вашим самым последним средством.**

Когда вы сразу же запускаете отладчик, вы фактически говорите: "я понятия не имею, что является причиной проблемы, но я просто посмотрю на код и, возможно, что-то пойму".

Это словно ваша машина ломается, и вы ни хрена не понимаете в автомобилях, но открываете капот и с умным видом смотрите, что же там могло пойти не так.

Что вы хотите там увидеть?

Вы даже не знаете этого.

Не поймите меня неправильно.

Отладчик -- прекрасный и мощный инструмент.

При правильном использовании отладчик поможет решить всевозможные проблемы, а также покажет, что происходит во время работы кода.

Тем не менее, это не та точка, с которой надо начать; многие ошибки могут быть решены без запуска отладчика.

Видите ли, так же, как забавные видео с котиками на ютубе, отладчик имеет свойство быстро засасывать вас в себя.

### Воспроизведите ошибку

Итак, если вы не запускаете сразу отладчик для выявления проблемы, что же вы делаете?

Ну, я рад, что вы спросили.

Первое, что любой здравомыслящий человек должен сделать, это **точно воспроизвести ошибку в вашем рабочем окружении**, чтобы убедиться, что это действительно ошибка, и что вы сможете отладить её.

Сто процентов проблем, которые не могут быть воспроизведены, не могут быть и отлажены.

Так что если вы не можете воспроизвести проблему, нет смысла её отлаживать. Вы меня понимаете?

Вы не только не можете отладить баг, который не может быть воспроизведён, но даже если вы его случайно исправите, вы не сможете проверить, что он действительно был исправлен.

Итак, самое первое, что вы должны делать, когда пытаетесь пофиксить ошибку -- это убедиться, что вы можете воспроизвести ошибку самостоятельно.

Если вы этого не можете, идите за помощью.

Если баг нашёл тестировщик, попросите его воспроизвести ошибку специально для вас.

Если ошибка то появляется, то исчезает, и не может быть стабильно и достоверно воспроизведена, это означает, что вы не выяснили обстоятельства, необходимые для воспроизведения бага.

**Нет такой вещи, как случайно появляющийся баг.**

Если это ошибка, она может быть точно воспроизведена; вы просто должны выяснить, как.

### И всё же, как быть с противными, изредка появляющимися багами?

Начальник сказал, что вы должны исправить ошибку, которую пока не удалось повторяемо воспроизвести.

Хорошо, тимлид видел этот баг в продакшене. Ваши клиенты с ним встречались. Это определенно проблема.

Отмазка "я не могу его воспроизвести" не работает -- клиенты платят за продукт без ошибок.

Что вам делать?

Вы пока ещё не можете взяться за полноценную отладку ошибки, потому что не можете её воспроизвести.

Но что вы точно можете сделать, так это **собрать больше доказательств**.

Соберите как можно больше подробностей о том, когда возникает ошибка, и при каких условиях, по возможности от всех, кто с ней встречался.

Зная примерное время её появления, поизучайте логи (если они ведутся) в соответствующие периоды времени, не возникало ли там что-то необычное.

Добавьте в код, в наиболее подозрительные модули, побольше новых инструкций логирования.

Расставьте побольше assert-ов (см. далее).

Искусственно воссоздайте среду и обстоятельства появления бага, если сможете.

Не поддавайтесь соблазну деплоить "исправления" ошибки, которую вы пока не смогли воссоздать и лишь предполагаете, где она может возникать.

Если вы не понимаете проблему настолько, чтобы точно воссоздать её, будет очень, очень низкая вероятность исправить её случайно -- по интуиции, и вдобавок вам будет очень трудно понять, сработало ли вообще ваше исправление.

Найдите способ стабильно воспроизвести баг.

### Сидите и думайте

После того, как вы смогли наконец воспроизвести ошибку, следующий шаг - это шаг, который большинство разработчиков к сожалению пропускают, потому что они хотят поскорее пофиксить баг - но этот шаг имеет решающее значение.

Это действительно простой шаг.

**Просто сядьте и подумайте.**

Да, это так.

Подумайте об ошибке и о её возможных причинах.

Можете не сидеть, а ходить например. Главное, подумайте некоторое время о выявленной ошибке не за компьютером.

Думайте о том, как работает внутри система с этой ошибкой, и что может привести к странному поведению, которое вы выявили.

Вы можете поспешить, побыстрее запрыгнуть в код и запустить отладчик, чтобы начать изучать проблему "вживую" -- но прежде чем вы начнёте это делать, вам важно понять, что конкретно вы ищете и что конкретно в коде надо смотреть.

Скорее всего, вы придумаете несколько идей насчёт того, что может стать причиной бага.

Пока вы не придумаете такие идеи, сохраняйте терпение. Продолжайте сидеть (или ходить) и думать.

Прежде чем двигаться дальше, подготовьте несколько гипотез, которые вы собираетесь проверить.

Если вы абсолютно ничего не можете придумать, продолжайте сопротивляться обращению к отладчику, вместо этого поизучайте исходные тексты методом пристального взгляда и прикиньте, сможете ли вы подобрать ещё несколько идей по поводу того, как система должна работать правильно.

У вас должно быть **как минимум две или три хорошие гипотезы**, которые вы можете проверить, прежде чем вы перейдете к следующему шагу.

### Проверяйте ваши гипотезы

Хорошо, значит, у вас теперь есть хорошие идеи насчёт этого странного бага, верно?

Вы забыли добавить +1 в цикле, или не учли граничный случай, или не вызываете родительский конструктор, или...

Эээ... что-то в этом роде.

Ладно, давайте запустим отладчик и проверим наконец наши гипотезы! Да, бро, давай сделаем это!

Нет! Неправильно.

Вцепитесь покрепче в подлокотники.

Нам пока не нужен отладчик.

Подожди-ка, что? Как же я проверю свои гипотезы, если не смогу использовать отладчик?

**Юнит-тесты.**

Да, ты верно понял: юнит-тесты.

**Напишите юнит-тест для каждой своей гипотезы, чтобы проверить их.**

Если вы считаете, что какая-то часть системы работает некорректно, напишите модульный тест, который, по вашему мнению, проверит эту проблему.

Это очень важно и абсолютно обязательно.

Если вы оказались правы и правильно выявили причину бага, и вы можете исправить её в нужном месте кода, значит, это исправление надо покрыть тестом, чтобы проверить итоговую версию и убедиться, что это больше никогда не повторится.

Только конечно, сперва убедитесь, что вы пытаетесь воспроизвести реально существующую ошибку, прежде чем называть ее исправленной.

Если же вдруг вы сделаете что-то, не связанное с багом, и юнит-тест, который вы пишете, пройдёт нормально, это значит, что вы просто сделали систему немного более надежной, добавив в проект еще один модульный тест.

Каждый раз, когда вы пишете модульный тест, и он проходит успешно, вы снижаете вероятность ошибочной работы проекта. Конечно подразумевается, что ваш юнит-тест сделан так, что действительно может закончиться неудачей. Убедитесь, что все юнит-тесты, которые вы пишете, не просто будут всегда проходить при любых условиях работы программы, они действительно что-то проверяют -- это вроде бы очевидно, но так случается на удивление далеко не всегда.

**Вы движетесь путём отладки, наглухо закрывая и запирая за собой все двери, как только выясняете, что они ведут в тупик**.

Если вы когда-либо теряли несколько часов, а то и дней в сеансе отладчика, вы должны немедленно осознать, насколько это ценно.

Одна из причин, по которой использование отладчика настолько плохо, заключается в том, что **отладчик подталкивает вас к постоянному пересмотру одних и тех же неправильных маршрутов, снова и снова**, по мере того, как вы проверяете и перепроверяете свои предположения, либо забывая о том, что вы уже искали, либо опасаясь, что вы искали недостаточно усердно.

Модульный тест подобен альпинистскому восхождению на гору и вбиванию крюка в скалу, который гарантирует, что в случае чего вы не слетите слишком далеко назад.

Написание юнит-тестов для проверки ваших гипотез также гарантирует, что вы не будете беспорядочно смотреть на код и пробовать разные идеи случайно и бессистемно.

**Вы должны прежде всего сформулировать конкретные предположения для их проверки с помощью юнит-тестов**.

Я прагматик.

Я понимаю, что иногда будет крайне сложно, а то и действительно невозможно написать юнит-тест для проверки гипотезы.

В этом случае можно запустить отладчик -- но только если вы обязуетесь следовать единственному правилу:

**Иметь конкретную цель для запуска отладчика.**

Точно знайте, что именно вы ищете и что собираетесь проверить с помощью отладчика.

Не просто заходите в IDE, чтобы осмотреться, потыкать в разные файлы проекта и только через пять запусков отладчика едва припомнить, где находится именно тот код, который вы намерены изучить более детально.

Так совсем не годится.

**Тренируйте свою память и понимание проекта на хороших уровнях абстракции, чтобы быстро ориентироваться в логике кода.**

Может показаться, что я излишне педантичен, но поверьте мне, для этого есть причина.

Я хочу, чтобы вы научились очень умело работать с отладчиком, и вы добьётесь этого, только **регулярно обдумывая, как именно и что именно вы отлаживаете**.

### Проверяйте свои предположения

В большинстве случаев ваши предположения о возможных причинах ошибки не сбудутся.

Это просто жизнь.

Если это так, то следующее, что вы можете сделать правильно -- это начать проверять свои предположения о том, а **как именно всё работает именно так, как сейчас**.

Обычно мы предполагаем, что код работает некоторым определенным образом, или что некоторый вывод должен быть таким-то значением.

Если вы программируете достаточно много, вы наверняка думали иногда: "Ну, этого не может быть. Я смотрю на код вот тут, и не может быть, чтобы он выдавал такой результат".

Часто мы ошибаемся.

Такое регулярно случается с самыми лучшими из нас, и со мной, конечно, тоже.

Лучшее, что вы можете сделать со своими предположениями о проекте -- это проверить их.

А как лучше всего их проверить?

Да, вы правильно поняли, именно так. **Больше модульных тестов**.

Напишите несколько модульных тестов, которые проверяют очевидные вещи, которые "должны работать" в той ситуации, которую вы пытаетесь отладить.

Большинство этих тестов должно легко пройти, и вы скажете: "ура!".

Но время от времени, когда вы будете писать модульный тест для проверки какого-то очевидного предположения, вы будете шокированы результатами.

Помните, что если бы ответ на вашу проблему был очевиден, то это не было бы проблемой вообще.

И снова прагматичная часть меня должна вам сказать, что да, можно конечно открыть отладчик, чтобы проверить свои предположения.

**Но только после того, как вы сначала попробуете проверить эти предположения с помощью модульных тестов.**

Опять же, это как подниматься на гору и вбивать крючья по пути.

**Всегда избегайте отладчика насколько только можно**; используйте его, только если уж совсем необходимо, но, опять же, только для того, чтобы подтвердить или опровергнуть конкретные предположения, которые вы уже осознанно сформулировали ранее.

### Разделяй и властвуй

Многие опытные программисты, умеющие формулировать хорошие предположения о проблемной ситуации, тем не менее периодически попадают в ситуацию, когда код системы столь огромен (десятки, сотни тысяч строк кода...), что протестировать все вероятные проблемы не представляется возможным физически.

Иногда, когда вы зашли в тупик при отладке, **вам нужно придумать способ сократить проблему наполовину** - или оторвать от неё как можно больший кусок.

Например, создайте локальную копию проекта и удалите или закомментируйте все части, которые не связаны с ошибкой.

В зависимости от бага этот подход может сильно меняться, но постарайтесь придумать, как можно убрать большой объём кода или удалить большую часть системы и при этом воспроизвести ошибку.

Попробуйте придумать тесты, которые полностью исключают часть системы, ответственную за ошибку.

Затем делайте это снова... и снова.

Уменьшите файл с кодом в два раза.

Ошибка всё ещё там.

Тогда снова разрежьте его пополам.

Ошибка исчезла?

Попробуйте другую половину.

**Продолжайте резать файлы проекта, пока не сократите код с нескольких тысяч строк кода до единичных строк**.

Если вы продолжите разбираться таким образом, то, скорее всего, найдете критические компоненты, необходимые для возникновения ошибки, и тогда проблему будет относительно легко решить.

### Assert-ы

Очень полезная техника отладки -- точнее, быстрой локализации ошибок, которая позволяет выявлять баги практически с линейной скоростью -- это активное использование assert-ов (только не из библиотеки тестирования, а встроенных в сам язык). Возможно, вы изучали эту тему на одном из моих первых курсов, напомню полезную статью на эту тему:  
[https://vk.com/wall-152484379_1758](https://vk.com/wall-152484379_1758),  
обязательно изучите её рекомендации и активно применяйте.

### Когда вы фиксируете это, понимайте, почему

Я дам вам последний совет по отладке - хотя я думаю, что мог бы написать целую книгу на эту тему.

**Если вы устраняете проблему, поймите, почему то, что вы сделали, устранило её.**

Если вы не понимаете, почему то, что вы сделали, устранило проблему, значит вы ещё не закончили отладку.

Возможно, своими случайными по сути правками вы создали новую ошибку, или - что очень вероятно - вы пока не разобрались со своей первоначальной проблемой.

**Ошибки не исчезают сами по себе.**

Если вы не устранили баг сознательно, я могу гарантировать вам, что он не пофикшен. Он просто затаился.

Но если вы устранили ошибку, не останавливайтесь на достигнутом. Исследуйте проблему немного поглубже и убедитесь, что вы точно понимаете, что именно привело к её возникновению, и как то, что вы сделали, устранило её, и нету ли в коде в других местах похожих опасных моментов.

Слишком много разработчиков отлаживают код, просто "подкручивая байты" (и этому есть более грубый, но справедливый термин), подставляя костыли и фигача приляпки, и система вроде бы начинает работать, и они считают, что ошибка устранена, даже не зная, почему.

Это опасная привычка по многим причинам.

Как я уже говорил, когда вы произвольно модифицируете систему и правите кусочки кода то тут, то там, вы легко можете вызвать множество других проблем, о которых вы не подозреваете.

Но, что ещё хуже, **вы при этом приучаете себя к тому, что отладчик из вас никудышный**.

Вы вырабатываете ужасную привычку возиться с кодом до тех пор, пока он не заработает. Никакой методики, никакой дисциплины.

Иногда вам может случайно везти, но у вас не будет хорошего рабочего процесса, надежного набора навыков для продуктивной отладки.

Вы должны не только понять, что сломалось, и почему и как вы это исправили, но и проверить свой фикс.

Я знаю, что это выглядит очевидным, но я не могу сказать вам даже примерно, сколь много времени теряют программисты, "устраняя баги" и полагая, что их фикс сработал -- и передавая код тестировщикам только для того, чтобы они снова воспроизвели ошибку и вернули её разработчику, который должен начать все с начала.

Это огромная потеря времени для команды, которую можно предотвратить, потратив дополнительные пять минут на проверку того, что то, что вы исправили, действительно исправлено.

На самом деле, не просто проверьте своё исправление; **напишите регрессионный тест для этой ошибки, чтобы она никогда не повторилась.**

Если вы действительно понимаете баг, который вы исправили, вы должны быть в состоянии без проблем написать модульный тест, который проверяет эту ошибку, а затем ваш фикс должен заставить этот модульный тест успешно пройти.

И наконец, **поищите другие экземпляры этого же класса ошибок**.

Ошибки обычно держатся вместе.

Если вы нашли что-то неправильное в одной инструкции, или в каком-то неправильно закодированном модуле или классе, очень вероятно, что есть и другие баги, вызванные этой же ошибкой.

Вы теперь понимаете, почему так важно понять, в чем заключалась реальная проблема, и почему ваше решение устранило её?

Между прочим, азиатские заказчики активно практикуют такой стиль общения с подрядчиками, когда требуют подробно рассказывать, в чём была причина каждого обнаруженного бага, и почему вообще эта причина была допущена.

Если вы знаете, что произошло и почему так произошло, вы сможете быстро понять, существует ли вероятность возникновения других багов, вызванных той же самой основной ошибкой.

### Искусство и наука

Помните, что отладка, как и разработка - это частично искусство и частично наука.

Вы можете добиться хороших результатов в отладке, только лишь практикуясь.

Но для достижения мастерства одной практики недостаточно. **Вы должны специально, систематически, осознанно выполнять отладку, отдавая себе отчёт, зачем вы делаете то, и почему возникла именно такая ситуация, а не просто играться с отладчиком**.

Надеюсь, я дал вам хороший обзор того, как это делать; остальное зависит от вас.

---

Изучите также материал **"Базовая методика отладки и устранения багов"**.

### Задание

Подробно опишите пять случаев ошибок, которые вы исправили по вышеописанной схеме.

По каждому случаю составьте список юнит-тестов и прокомментируйте его: какой тест для какой цели создавался.

---
## Базовая методика отладки и устранения багов

**1. Воспроизведите ошибку повторяемо.**

Этот момент, пожалуй, самый трудный, и связан больше с опытом и интуицией, нежели с логикой. Прежде всего вам необходимо последовательно воспроизвести ошибку, если вы хотите понять, что и где пошло не так. Однако невозможно рационально объяснить, как именно перейти от "я уже встречал эту ошибку дважды" к "я могу последовательно воспроизвести эту ошибку на своём компьютере локально".

**2. Воспроизведите ошибку быстро.**

Все также согласны с тем, что крайне полезно иметь возможность быстро воспроизвести ошибку -- иначе, если вам требуется по 5 минут, чтобы проверить, помогло ли очередное изменение кода, то это означает, что ваш рабочий цикл идёт ОЧЕНЬ медленно.

Несколько рекомендаций:  
- если вы отлаживаете веб-систему, и баг воспроизводится длинной последовательностью пользовательских действий в UI, используйте сервисы записи и автоматизации действий (например, [Selenium](https://www.selenium.dev/)).  
- напишите скрипт или найдите подходящую системную команду, которая смоделирует нужные действия (например, curl).  
- (лучшее, но не всегда возможное) напишите юнит-тест, который повторяемо воспроизводит ошибку (бонус: добавьте его в общий набор тестов).

**3. Признайте, что виноват, скорее всего, ваш код.**

Я начал программировать в 1979-м, и с тех пор постоянно (!) встречаю жалобы программистов, что дескать в очередном странном баге виновато что угодно (ОС, фреймворк, библиотека, хакеры, вирусы...), но только не их код, который они "точно проверили на 100%". Однажды мне долго доказывали, что в неверной логике игры (!) шахматной программы виноват вирус, который заражает объектные файлы (формат .obj -- результат промежуточной компиляции Си-файлов).

Ну конечно, сломалось НЕЧТО ДРУГОЕ, НО ТОЛЬКО НЕ МОЙ КОД, да-да.

Ну наверное бывает 0.1% случаев, когда действительно виноват не мой код, но во всех остальных случаях, если говорить о стандартной библиотеке и о моём коде, который я написал в прошлом месяце, то практически всегда проблема в моём коде, который я написал в прошлом месяце :)

**4. Начните эксперименты.**

Сперва полностью осознайте ошибку: что вообще происходит? Что вы ожидаете в данном случае? Когда это происходит? Когда это не происходит? Затем примените своё понимание системы, чтобы предположить, что может быть сломано, и придумайте эксперименты, подтверждающие это.

Экспериментами могут быть временное изменение или удаление кода, вызовы API, попытка выполнения с новыми входными значениями, просмотр значений в логах и с помощью отладчика.

Делайте предположение ровно об одном аспекте того, что может происходить ("эта переменная имеет значение 42, а должна быть 24", "серверу отправлен неправильный запрос", "этот код вообще не выполняется"), потому что если вы попытаетесь проверять одновременно несколько предположений (так называемый многофакторный анализ), количество возможных вариантов проверок резко возрастёт, и вы только запутаетесь. Проведите эксперимент, чтобы проверить только одно это предположение за раз. Повторяйте эту схему, пока не поймете точно, что происходит.

Отладка очень часто приводит к осознанию того, что то, в чем вы были уверены ("подождите, этот запрос ведь идёт на новый сервер, а не на старый??"), на самом деле... не соответствует действительности. Вот некоторые распространенные классы неверных предположений:

- эта переменная имеет значение X ("это имя файла задано правильно")  
- значение этой переменной никак не могло измениться от X к Y  
- этот код раньше работал верно  
- эта функция делает X  
- я редактирую правильный файл  
- после копирования похожего кода я исправил его верно  
- в этой строке не может быть опечаток, это всего лишь 1 строка кода  
- так написано в документации  
- код, на который я смотрю, когда-то будет выполняться  
- эти две части кода выполняются последовательно, а не параллельно  
- код работает одинаково при компиляции в режиме debug и release

**5. Пишите код так, чтобы его было легко отлаживать.**

В частности, активнее применяйте [assert-ы](https://vk.com/wall-152484379_1758) и блоки try. Да, отлаживаемый код далеко не всегда получается "чистым", и когда в нём много проверок и обработчиков ошибок, читать его совсем не так приятно. Но очень важно, чтобы каждый раз, когда возникает ошибка, программа сообщала в понятной форме, что именно пошло не так, а также примерное место сбоя. Отсюда уже достаточно легко добраться до самого бага.

Лучше всего немедленно возвращать сообщение об ошибке и завершать работу приложения вместо того, чтобы продолжать молча использовать неправильные данные или передавать бессмысленное/нулевое значение другой функции, которая будет делать с ним неведомо что, и ошибка будет только расползаться, удаляясь всё дальше от своего источника. Далеко не во всех системах такое возможно, однако полезно как минимум немедленно сообщать об ошибке -- например, тимлиду.

**6. Учитывайте, что стандартные сообщения об ошибках часто сами по себе требуют понимания.**

Не экономьте на подробностях пойманной ошибки. Выводите в лог всю доступную информацию, в таком случае вам, возможно, даже не придётся отыскивать причину бага: о нём подробно будет сказано в сообщении. В частности, очень полезно сохранять в логе весь стек вызовов, приведших к сбою.

Однако нередко правильно интерпретировать сообщения об ошибках нелегко, потому что правильное понимание может подразумевать изучение новой концепцию. Например, сообщение "Ваш код использует переменную вне области видимости, в которой она определена" подразумевает ваше знание области видимости переменной. Подобная проблема характерна, в частности, для языков Go и Rust.

Кроме того, тоже довольно часто конечные сообщения об ошибках вызываются проблемами, сильно отличающимися от текста сообщения. Например, если сервер отключился, а такая ситуация в коде обрабатывается плохо (подробно разбираем этот момент на курсе по распределённым системам), то может возникнуть цепочка самых странных вызовов функций с непонятными аргументами.

Вдобавок, навык понимания сообщений об ошибках плохо передается при переходе, например, на новый язык или фреймворк, так что это определённо проблема не только начинающих программистов.

**7. Итог.**

Конечно, легко сказать "ну, вам нужно воспроизвести баг, затем уточнить это, затем начать придумывать догадки о возможной причине, и проверять их, затем разобраться в коде, пофиксить баг и, надеюсь, написать тест ". Но где мы действительно застреваем на практике? Какие шаги тут будут самыми трудными именно для вас? Рефлексируйте регулярно, фиксируйте время по каждому такому шагу, собирайте статистику. Скорее всего, вы будете сильно удивлены, на что именно уходит львиная доля времени в вашей отладке; подумайте, как соответствующий шаг можно оптимизировать.

Много технических приёмов отладки, о которых вы скорее всего не слышали, подробно рассматриваем на курсе Ясное Легаси.

---
Едва ли не на каждом командном митинге встречаются заявления в духе "клиенты/тестировщики видят странное поведение в нашей системе, помогите им разобраться, что происходит". У хорошего профессионала это обычно получается неплохо, однако при этом хотелось бы также объяснить другим людям, что вообще такое "хорошая отладка".

В основе теории отладки лежит универсальный метод: **вы можете ускорить отладку, задавая более "широкие" вопросы**.

Отладка -- это действительно применение научного метода. Мы наблюдаем несоответствие между ожидаемым поведением системы и фактическим поведением. Основываясь на наших наблюдениях, мы выдвигаем гипотезу о том, почему они расходятся. Затем мы проверяем нашу гипотезу -- например, добавляя отладочные логи, подготовив тесты или просто опробовав фикс "на глазок". Наконец, мы либо подтверждаем нашу гипотезу, либо опровергаем её, и в последнем случае мы выдвигаем новую.  
**Большую часть времени однако мы задаём "узкие" вопросы, которые полезны при подтверждении гипотезы, но бесполезны для её опровержения**. Если вы делаете много неправильных прогнозов, то отладка сводится к угадыванию и проверке такого гадания. Если вместо этого вы будете задавать общие вопросы, вы узнаете меньше, если они верны, но больше, когда это не так. Таким образом вы итеративно приближаетесь к фактическому источнику ошибки.

Допустим, у вас есть система продажи корма для котиков, которая случайным образом выходит из строя, но только по понедельникам, и иногда по воскресеньям. Это сложная система, поэтому существует множество возможных ошибок, которые формируют своего рода "пространство ошибок" (допустим, 100 возможных причин).

"Естественно" напрашивалось бы подозрение, что баг связан с началом рабочей недели, когда например сервера перезапускаются, или растёт нагрузка, но тогда при чём здесь воскресенье? Ещё более подозрительный разработчик может подумать так: "Ага! В словах "понедельник" и "воскресенье" по 11 символов! Бьюсь об заклад, это связано с тем, что название дня хранится в фиксированном массиве символов, где выделено слишком мало места, а сбой -- это его переполнение". Довольно странно конечно, но и вы, и я видели и куда более странные ошибки.  
Однако этот прогноз узкий -- он охватывает только одно возможное объяснение ошибки.

Теперь я проверяю эту гипотезу, и, о ужас, оказывается, что это совсем не так. Вместо того, чтобы исключить 99 объяснений, я исключил всего 1. Это предсказание не принесло мне особой пользы.

Теперь давайте вместо этого сделаем общий прогноз. Я предполагаю, что есть что-то другое в том, как система используется в воскрессенье и понедельник, и это другое использование вызывает ошибку. Это намного более расплывчато, чем "‘Понедельник -- это переполнение", и если это правда, это не даёт мне одного очевидного кандидата на баг, а не менее 20 возможных кандидатов.  
С другой стороны, если это ложь, это всё равно исключает 20 возможностей! Это сужает круг поисков гораздо быстрее. Если я делаю три широких предсказания, и все они неверны, я исключаю более половины возможных объяснений, тогда как 3 неправильных узких предсказания оставляют мне 97 возможностей.

Итак, есть причина, по которой мы обычно задаём узкие вопросы. Широкие вопросы имеют три недостатка:  
- Такие вопросы сложнее задавать. Я обнаружил, что естественным образом перескакиваю от одной узкой догадки к другой, и подсознательно заставляю себя уменьшать масштаб, вследствие чего задавать серьёзные вопросы становится ещё сложнее.  
- Общий прогноз сложнее проверить. Одно дело проверять переполнение буфера, и совсем другое -- находить все различия в шаблонах использования понедельника и воскресенья.  
- Кажется, что как будто общие вопросы дают вам двоичное "да" / "нет", но на самом деле это не так. Даже если по воскресеньям система используется по-другому, это может быть просто совпадением. Скорее, общие вопросы делают некоторые объяснения более или менее вероятными. Вам всё равно придётся делать узкие прогнозы, чтобы сузить круг поисков.

Очевидный ответ заключается в том, что широкие прогнозы -- это всего лишь инструмент, как и любой другой инструмент, который вы используете при необходимости. Верно и то, что это инструмент, для использования которого требуется больше навыков. Поэтому я не просто утверждаю, что "вы должны задавать более широкие вопросы при отладке", но также и то, что **"вы должны задавать более широкие вопросы при отладке, даже если это не обязательно кажется таким полезным, потому что требуется некоторое время, чтобы освоиться с этим, и потратить время на это действительно того стоит"**.

Чтобы "задавать широкие вопросы" быстрее стало полезным, вот хороший приём. Всякий раз, когда я нахожу сложную ошибку, я спрашиваю себя: "Как я мог найти это быстрее? Было бы проще, если бы я лучше знал/применял свои инструменты отладки? Если бы я знал больше о более широкой системной архитектуре? Если бы я быстрее обратился за помощью к товарищу по команде?".  
Цикл подобной рефлексии и обратной связи помогает существенно быстрее повышать квалификацию в этой важной теме.

---

Типовая ситуация: система обрабатывает большое количество данных несколькими потоками. Одна из задач периодически запрашивает внешний API, который из-за высокой нагрузки на сервер может периодически сбоить.

Такие ошибки трудно воспроизводимы и сложны для диагностики, поскольку они будут возникать только в определённых условиях нагрузки и чередования запросов. Кроме того, сама по себе ошибка может быть довольно простой (например, таймаут при вызове API), но её корень окажется в более сложных взаимодействиях между потоками.

Обычно такие ошибки находят с помощью стандартных средств отладки: логирование, профилирование, анализ стека вызовов, однако такой процесс может занимать буквально месяцы.

Но есть и нешаблонный подход, который помогает выявлять подобные ошибки существенно быстрее: хаотическое/обезьянье тестирование (chaos/monkey testing). Оно малоизвестно, однако может давать отличные результаты. Мы намеренно вводим в систему отказы и сбои, чтобы проверить, как она на них реагирует. Например, можно имитировать временнЫе сбои при обращении к внешнему API, чтобы выявить слабые места в обработке ошибок, и т.п.

Ключевая идея -- не полагаться только на "штатные" сценарии, а активно создавать нештатные ситуации, чтобы проверить устойчивость вашего кода. В этом хорошо поможет и фазинг, и мутационное тестирование, и т.п. Это всё подразумевает определённое изменение мышления, но значительно ускоряет процесс отладки сложных багов.