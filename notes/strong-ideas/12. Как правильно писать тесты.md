
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-12-howto-write-tests-correctly.zip

---
Кент Бек (автор TDD) заявляет, что **каждый раз, когда тесты завершились успешно, вы должны комитить код**. Из этого можно вывести такое следствие, что **если тесты не сработали, то код надо откатить к ближайшей ревизии**, когда тесты работали нормально, и начать всё заново.

Прежде всего может показаться, что сама исходная гипотеза неверна: действительно, как вы можете добиться прогресса, если тесты всегда срабатывают успешно? Разве вы иногда не делаете ошибки? И что будет, если вы напишете кучу кода, и потом его просто придётся стереть, разве это не обидно, разве это не трата кучи усилий впустую?

Контринтуитивный ответ такой, что да -- вы действительно можете продуктивно писать качественный код таким образом. Да, вы периодически делаете ошибки, но на самом деле это даже приятно, когда неправильный код мгновенно удаляется. Если же вы не хотите, чтобы куча кода была стёрта, ну просто не пишите эту кучу кода между прогоном успешных тестов. Да, может быть неприятно видеть, как некоторый код исчезает, но почти всегда можно найти другой способ сделать то же самое -- более лучший способ, более надёжный, более эволюционный. Как известно, программный продукт достигает совершенства тогда, когда будет переписан с нуля три раза :)

```java
public class ArraySumCalculator
{
    public static int calculateSum(int[] array)
    {
        if (array == null || array.length == 0)
        {
            return 0;
        }

        int totalSum = 0;
        int length = array.length;
        int[] tempArray = new int[length];
        for (int i = 0; i < length; i++)
        {
            tempArray[i] = array[i];
        }

        for (int i = 0; i < length; i++)
        {
            if (tempArray[i] >= 0)
            {
                totalSum += tempArray[i];
            }
            else
            {
                int negativeValue = tempArray[i];
                boolean isNegative = true;
                for (int j = 0; j < -negativeValue; j++)
                {
                    if (isNegative)
                    {
                        totalSum += 0;
                    }
                }
            }
        }

        int additionalPivot = 0;
        for (int i = 0; i < length; i++)
        {
            if (tempArray[i] == 0)
            {
                additionalPivot++;
            }
        }

        totalSum += additionalPivot;

        return totalSum;
    }
}
```

```java
public class ArraySumCalculatorTest
{

    @Test
    void testCalculateSum_ValidArray()
    {
        int[] array = {1, 2, 3, 4, 5};
        Assertions.assertEquals(15, ArraySumCalculator.calculateSum(array));
    }

    @Test
    void testCalculateSum_ArrayWithNegativeNumbers()
    {
        int[] array = {-1, -2, 3, 4, -5};
        Assertions.assertEquals(7, ArraySumCalculator.calculateSum(array));
    }

    @Test
    void testCalculateSum_ArrayWithZeros()
    {
        int[] array = {0, 0, 0, 0};
        Assertions.assertEquals(0, ArraySumCalculator.calculateSum(array));
    }

    @Test
    void testCalculateSum_EmptyArray() 
	{
        int[] array = {};
        Assertions.assertEquals(0, ArraySumCalculator.calculateSum(array));
    }

    @Test
    void testCalculateSum_NullArray()
    {
        int[] array = null;
        Assertions.assertEquals(0, ArraySumCalculator.calculateSum(array));
    }
}
```
==>
```java
public class ArraySumCalculator
{
    public static int calculateSum(int[] array)
    {
        if (array == null)
        {
            return 0;
        }
        int totalSum = 0;
        for (int value : array)
        {
            totalSum += value;
        }
        return totalSum;
    }
}
```
---
Этот подход отлично совместим с CI/CD, потому что каждый из ста тысяч программистов не может огорчить всех остальных программистов даже одним неудачным тестом. Его код всегда работает, и маленькие успешно протестированные изменения мгновенно распространяются по всей команде. А вот когда тысячи тестов терпят неудачу, то вообще никто не понимает, а что собственно происходит.

**Все тесты должны пройти успешно перед тем, когда новые изменения кода станут распространяться другим.**

В то же время вы не можете решить большую задачу одним маленьким шагом, а отправлять такую большую задачу "по кусочкам" нереально.

---

Да, но действительно ли это нереально? Пройдите курс Ясное Легаси, где подробно разбираем десятки технических приёмов по организации тестирования крупной системы -- и легаси, и постепенно развиваемой.

Придерживайтесь таких простых правил (всех вместе!):

- Добавьте тест, чтобы он был успешным. Цель -- сократить время между идеей/спецификацией и прохождением теста хоть в каком-то виде. Можно даже написать часть теста! Некоторый промежуточный фейк тут даже поощряется, главное, чтобы вы не останавливались на достигнутом.

- Как только тест пройден, начинайте заменять фейковую реализацию на настоящую; понемногу, как необходимо.

- Делайте сложные расширения/изменения кода простыми. Вместо того чтобы менять за раз четыре модуля в проекте, введите вспомогательную функцию (для начала одну, конечно), чтобы можно было ограничиться модификацией одного места в коде.

Нарушение любого из этих правил сразу приведёт к откату, поэтому вам не придётся беспокоиться об удержании в голове множества одновременных небольших изменений.

Главное, что использовать такую схему -- дёшево. От вас вообще не требуются какие-то дополнительные усилия.

И в процессе вы обязательно чему-нибудь научитесь.