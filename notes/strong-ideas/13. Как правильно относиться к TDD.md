
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-13-howto-treat-TDD-correctly.zip

---
Многие поклонники TDD довольно справедливо жалуются, что TDD сильно недооценён в ИТ-мэйнстриме, однако занимая при этом весьма экстремальную позицию: дескать, TDD так же важно в программировании, как и мытьё рук в медицине, что лишь сильнее вызывает отторжение у других. По мне, важность TDD (безусловно, высокая в инженерном плане) однако прежде всего заключается в том, что это по сути **первый шаг в тему применения формальных методов в разработке**. Мы учимся с самого начала думать над кодом в терминах спецификации, предметной области, домена: берём техническое задание и транслируем его в формальный вид в виде тестов, которые уже однозначно задают нужную логику поведения. Получив хорошую практику в TDD, дальше будет уже существенно легче переходить на следующую ступень, используя языки спецификаций наподобие TLA.

При этом уже не так важен канонический цикл TDD (красный-зелёный-рефакторинг), которого требуют свято придерживаться его фанаты:
```Java
public class Calculator
{
    public int add(int a, int b)
    {
        return 0;
    }
}
```
- Напишите минималистичный тест, который завершится неудачей.
```java
public class CalculatorTest
{
    @Test
    void shouldAddTwoNumbers()
    {
        Calculator calculator = new Calculator();
        int result = calculator.add(2, 3);
        assertEquals(6, result);
    }
}
```
- Напишите минимально возможный код для успешного прохождения теста.
```java
public class Calculator
{
    public int add(int a, int b)
    {
        return a + b;
    }
}
```
- Выполните рефакторинг кода, не добавляя в него нового поведения/новой логики.
```java
public class Calculator
{
    public int add(int a, int b)
    {
        return sum(a, b);
    }

    private int sum(int a, int b)
    {
        return a + b;
    }
}
```
(Пример условный конечно , идея , что мы абстрагируем логику вычислений.)

В чистом виде мы получим подход "test && commit || reset" (TCR) Кента Бека, о котором я рассказывал в материале "Как правильно писать тесты": если минимальный код не проходит, **сотрите все изменения** и начните сначала.

Это действительно здорово, и это отлично работает, и я очень рекомендую этот подход. Однако у нас разные взгляды на то, "зачем делать TDD". Сторонники чистого TDD заявляют, что это не техника тестирования, а скорее "техника проектирования", которая использует тестирование, как я уже говорил. Однако Hillel Wayne (известный специалист в области формальных методов в разработке и автор учебника "Learn TLA+") не согласен с такой постановкой вопроса по двум причинам. Во-первых, они используют понятие "дизайн" в совершенно ином смысле, чем принято в парадигме формальных методов: у них имеется в виду организация локального кода (_programming in small_), а не соблюдение спецификаций системы (_programming in large_). Во-вторых, в оригинальной книге Кента Бека TDD называлась именно **техникой тестирования** :)

---
Но основной постулат современных фанатов TDD такой, что TDD делает именно ваш дизайн лучше. Другими словами, они считают, что TDD - это именно парадигма разработки, а небольшая оппозиционная группа, включая и меня, полагает, что **TDD - это именно техника, хотя и дающая крайне полезные навыки в плане формального проектирования**.

TDD-максималисты заявляют например так:  
_"Никому не нравится слышать, что он делает это неправильно, и меньше всего, когда он действительно делает это неправильно. Но что, если вы попробовали TDD и он не "сработал" (что бы это ни значило), но на самом деле то, что вы попробовали, вовсе не было TDD?"_

Однако подобное отношение к TDD приводит к тому, что его ярые фанаты требуют буквально такое:  
- TDD следует использовать во всех случаях, кроме самых исключительных;  
- Цикл TDD должен соблюдаться настолько строго, насколько это возможно (хотя заявляют, что при этом TCR Кента Бека не нужен :);  
- "Тестирование сначала" -- это не TDD;  
- TDD всегда приводит к лучшему дизайну;  
- TDD исключает другие формы проектирования;  
- TDD исключает другие формы верификации;  
- TDD не может потерпеть неудачу. Если он вызывает проблемы, то это потому, что вы сделали это неправильно.

Короче говоря, тесты -- это вход TDD, а чистый дизайн и ясный код -- это выход TDD :)

---
Но по сути весь этот максимализм в пользу TDD строится на двух её преимуществах: это хорошо для вашего тестирования и это хорошо для вашего дизайна. Дядюшка Боб в этой связи высказывался, что дескать TDD и бухгалтерия с двойной записью -- это одна и та же дисциплина, одни и те же рассуждения, один и тот же результат.

Естественный аргумент довольно прост: при максимальном TDD каждая написанная строчка кода покрывается тестом, что позволяет отловить больше ошибок. Я с этим согласен! Большее покрытие тестами безусловно означает меньшее количество ошибок.

Проблема в том, что **тесты в TDD сами по себе очень ограничены**. Чтобы сохранить быстрый цикл TDD, ваши тесты должны быть быстрыми в написании и выполнении ("сотни тестов в секунду"). Единственные тесты, которые соответствуют всем трём критериям -- это простые модульные тесты. Но это исключает другие формы тестирования:  
- интеграционное тестирование  
- сквозное тестирование  
- мутационное тестирование  
- фаззинг  
- тестирование свойств  
- тестирование на основе моделей

Чтобы юнит-тестирование стало полностью самодостаточным, оно должно вытеснить все эти иные формы тестирования. Кроме того, оно должно вытеснить и все методы верификации, не основанные на тестировании:  
- ручное тестирование  
- инспекции кода  
- тайп-чекеры  
- статический анализ  
- контрактное программирование  
- распихивание assert-ов повсюду :) (очень полезный подход!)

Но это невозможно в принципе. В юнит-тестах не проверяются побочные эффекты, недетерминизм или _use cases_ (последовательности событий). Они охватывают ровно то, что программист решил протестировать, и только те конкретные входные значения, которые он выбрал. Но многие серьёзные ошибки существуют на более высоком уровне -- например, в результате неправильного взаимодействия правильных компонентов, или только при очень специфических значениях входных данных. Или они всегда случаются при появлении null, причём только в некоторой определённой цепочке вызовов, где передаётся null. И вы никогда не узнаете, будут ли недопустимые состояния действительно никогда не представимыми.

---
Что такое дизайн? Сторонники формальных подходов к разработке считают, что **дизайн -- это спецификация программной системы**. У нас есть проблема, которую мы хотим решить, и набор свойств, которые мы хотим сохранить, удовлетворяет ли наша система этому всему? Например, есть сервис, который извлекает данные из трёх потоков, объединяет их вместе и загружает в базу данных. Мы хотим быть уверенными, что записываемые в БД данные не дублируются, что время простоя любого потока обрабатывается корректно, что все поступившие данные в конечном итоге объединяются, и т. д. При этом мы совершенно не интересуемся, какие методы вызываются для выполнения "API-запросов", или как код превращает JSON-ответ в объекты домена. Нас волнует только то, что именно код делает с данными. Фактически это третий логический уровень думания о программе.

"Дизайн" в контексте TDD прямо противоположен этому подходу. Он по сути явно определяет, как организован код. Будет ли `foo()` публичным или приватным методом? Должны ли мы разделить обработчик HTTP-ответа на отдельные объекты? Каковы параметры метода `check_available()`?

Сторонники TDD говорят о том, что нужно "слушать свои тесты": если написание тестов затруднено, то это указывает на проблему в коде. Вам следует отрефакторить такой код, чтобы сделать его более удобным для тестирования. Другими словами, код, который трудно тестировать с помощью TDD, плохо организован.

Напомню, это позиция TDD-максималистов.

---
Но действительно ли TDD гарантирует хорошую организацию кода? Не похоже; любой, кто работал по TDD, знает, что результирующий код "на выходе TDD" выглядит иначе, чем обычный. В частности, для него характерны:

- **Инъекция зависимостей** -- делает код более настраиваемым, однако расплата в том, что он становится намного сложнее.

```java
public class EmailSender
{
    public void sendEmail(String to, String subject, String body)
    {
        // Логика отправки email
    }
}
```

```java
public class UserService
{
    private final EmailSender emailSender;

    public UserService(EmailSender emailSender)
    {
        this.emailSender = emailSender;
    }

    public void registerUser(String email, String name)
    {
        // Логика регистрации пользователя
        emailSender.sendEmail(
	        email, 
	        "Welcome!", "Welcome to our service, " + name + "!"
		);
    }
}
```

Казалось бы, все выглядит хорошо - мы используем принцип инверсии зависимостей, передавая `EmailSender` в качестве зависимости `UserService`. Это позволяет нам легко заменить реализацию `EmailSender` на другую, если это потребуется.

Однако давайте представим, что у нас есть несколько разных способов отправки email, и мы хотим использовать их в зависимости от различных условий: тип пользователя, важность сообщения и т.д. Для этого мы можем ввести абстракцию `EmailProvider`, которая будет предоставлять необходимый `EmailSender` в зависимости от ситуации:

```java
public class EmailProvider
{
    public EmailSender getEmailSenderForUser(User user)
    {
        if (user.isPremium())
        {
            return new PremiumEmailSender();
        }
        else
        {
            return new BasicEmailSender();
        }
    }
}

public class PremiumEmailSender implements EmailSender
{
    public void sendEmail(String to, String subject, String body)
    {
        // Логика для отправки "премиум" email
    }
}

public class BasicEmailSender implements EmailSender
{
    public void sendEmail(String to, String subject, String body)
    {
        // Логика для отправки "базового" email
    }
}
```

```java
public class UserService
{
    private final EmailProvider emailProvider;

    public UserService(EmailProvider emailProvider)
    {
        this.emailProvider = emailProvider;
    }

    public void registerUser(User user)
    {
        // Логика регистрации пользователя
        EmailSender emailSender = emailProvider.getEmailSenderForUser(user);
        emailSender.sendEmail(
	        user.getEmail(), 
	        "Welcome!", 
			 "Welcome to our service, " + user.getName() + "!"
		 );
    }
}
```

И вроде бы всё выглядит элегантно, однако код без сомнения усложнился.

- **Множество маленьких функций** вместо нескольких больших функций;  
- **Массовое использование публичных методов** вместо глубокого/точечного использования приватных методов.

Обязательно ли эти характеристики дают плохой дизайн? Нет. **Могут ли** они давать плохой дизайн? Да! Иногда большие функции предлагают лучшие абстракции, а маленькие функции приводят к запутанным схемам взаимодействия. Иногда инъекция зависимостей делает код намного сложнее и труднее для понимания. Иногда "широкие" публичные API усиливают связь между модулями. Если TDD противоречит вашему подходу, то иногда и TDD бывает неправильным.

По большому счёту, этот аргумент слабый, потому что он в равной степени относится к любому подходу, воздействующему на дизайн. Более конкретная проблема TDD-максимализма заключается в том, что код формируется чрезвычайно малыми шагами, что приводит к зависимости результата от пути: **конечный код сильно зависит от пути, который вы выбрали**, чтобы добраться до него. Об этом, собственно, мой трек курсов по ООАП: как правильные подходы к объектно-ориентированному проектированию позволяют избавиться именно от подобных последовательностей, но TDD тут вообще не играет никакой принципиальной роли.

---
Максималистский TDD явно подразумевает превосходство локальной организации системы над глобальной. Но если TDD может помешать вам думать о функции целостно, то он также может помешать вам думать целостно обо всём компоненте, или о взаимодействии между компонентами.

Но, безусловно, неканонический "ослабленный" TDD (который применяет, наверное, 90% команд, утверждающих, что следуют TDD), имеет такие несомненные плюсы:  
- **Вы пишете тесты, и пишете их много**. Даже если написание тестов "мешает" написанию кода, вы всё равно должны это делать. Потому что если вы потенциально можете написать тесты позже, то вы скорее всего так и будете откладывать их на потом, и так и не доберётесь до них. Это главное преимущество обучения TDD программистов, не знакомых с этим подходом.  
- **Вам становится легче проводить рефакторинг**, так как вы по определению написали множество регрессионных тестов.  
- **У вашего кода теперь есть как минимум один пользователь** (тесты), что неплохо помогает в понимании, насколько удобны (или неудобны) ваши интерфейсы.  
- **TDD приучает вас думать о том, как именно ваш код будет проверяться**.

Максималисты могут возразить, что дескать это те же самые преимущества, что и в каноническом TDD! Вы должны "прислушиваться" к своим тестам, и TDD часто делает ваш дизайн лучше!

Hillel Wayne тут отмечает, что TDD также может сделать ваш дизайн хуже. Хоть какой-нибудь TDD лучше, чем отсутствие TDD, но никакой TDD не лучше, чем чрезмерный TDD. Иногда совет TDD будет правильным, а иногда - неправильным, и иногда он будет настолько неправильным, что вам не следует использовать TDD в соответствующих обстоятельствах. И это можно сказать о большинстве технологий, потому что их сегодня очень много.

Например, изучение shell scripting в вашей ОС обычно окупается десятикратно; многие профессиональные разработчики убеждены, что каждый программист должен это знать. Важнее ли это, чем TDD? Если у людей нет времени на то, чтобы выучить и то, и другое, что им выбрать? Что, если "правильное" TDD потребует столько времени, за которое вы могли бы изучить и shell-сценарии, и практику отладки? Когда люди должны остановиться?

И это наверное главная причина, почему TDD (и многие другие хорошие методы) не стал повсеместным. Она не техническая и не методологическая, она **организационная**.