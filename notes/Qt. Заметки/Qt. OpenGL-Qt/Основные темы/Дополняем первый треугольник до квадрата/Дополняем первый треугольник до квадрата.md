При рендеринге еще очень часто испульзуется, такой объект, как Элементный/Индексный Буфферный Объект (Element Buffer Object [EBO], Index Buffer Object [IBO]).

Пердположим, что нам надо отрисовать прямоугольник, а не треугольник, для это мы зададим вершин, как в двух трецугоьниках (OpenGL чаще всего работает как раз с треугольниками).

```C++
constexpr std::array<float, 18> vertices = {
    // Первый треугольник
     0.5f,  0.5f, 0.0f,  // Верх право
     0.5f, -0.5f, 0.0f,  // Низ право
    -0.5f,  0.5f, 0.0f,  // Верх лево
    // Второй треугольник
     0.5f, -0.5f, 0.0f,  // Низ право
    -0.5f, -0.5f, 0.0f,  // Низ лево
    -0.5f,  0.5f, 0.0f   // Верх лево
}; 
```

И как мы можем наблюдать - данный подход имеет оверхед, Верх Лево встречается целых 2 раза. Оверхед по памяти почти на 50% процентов, так мы используем 6 вертексов, вместо 4.

Было бы очень круто - если бы была структура, в которой можно хранить только униакальные значения Вертексов, и просто потом вызывать их в нужной последовательности. Так нам надо было бы хранить только 4 вершины и последовательность их вызовов.

К счастью Элемент Буффер работает именно так. EBO (Element Buffer Object) - такой же буффер, как и VBO, только вместо вершин он хранит обычные индексы вертексов. Эти индексы показывают в какой последовательности вызывать отрисовку тех или иных вертексов.

```C++
constexpr std::array vertices = {
     0.5f,  0.5f, 0.0f,  // Верх право
     0.5f, -0.5f, 0.0f,  // Низ право
    -0.5f, -0.5f, 0.0f,  // Низ лево
    -0.5f,  0.5f, 0.0f,  // Верх лево
}; 
constexpr std::array<unsigned int, 6> indices = {
    0, 1, 3,   // Первый треугольник
    1, 2, 3    // Второй треугольник
};
```

Теперь нам надо сгенерировать объект для будущего EBO:

```C++
m_pData->pFunc->glGenBuffers(
    m_pData->indicesBufferObjectCount,
    &m_pData->indicesBufferObjectId
);
if (0 == m_pData->indicesBufferObjectId)
{
    qDebug() << "Error while generating Indices Buffer Object";
    return false;
}
```

Далее байндим EBO к его типу буфера. И помним так же, что к каждому типу буфера мы можем байндить только один буфер:

```C++
m_pData->pFunc->glBindBuffer(
    GL_ELEMENT_ARRAY_BUFFER,
    m_pData->indicesBufferObjectId
);
```

Теперь аллоцируем память для индексного буффера:

```C++
m_pData->pFunc->glBufferData(
    GL_ELEMENT_ARRAY_BUFFER,
    sizeof(indices),
    indices.data(),
    GL_STATIC_DRAW // Same as in VBO
);
```

И останется только заменить основной метод отрисовки в цикле репейнта с `glDrawArrays` на `glDrawElements`

```C++
m_pData->pFunc->glDrawElements(
    GL_TRIANGLES, 
    6, 
    GL_UNSIGNED_INT, 
    nullptr
);
```

Функция `glDrawElements` вытаскивает индексы на отрисовку напрямую из сбайнженого EBO (А я напомню, что сбайндить можно только 1 объект 1го типа за раз). Поэтому либо стоит каждый раз байндить EBO когда дергается метод `glDrawElements`, либо просто неразбайнживать его.

Но при этом стоит помнить, что когда существет уже сбайнженый объект VAO и мы его кофигурируем, и если в этот момент буде тсбайнжен EBO, то он запишеся в VAO, и нам в дальнейшем прям перед отрисовкой надо будет все так же байндить только VAO:

![[vao_with_ebo.png]]

**Заметка**: В _**compat**_ профиле (мы используем _**core**_) существует предустановленый объект _**VAO**_ по индексу 0. Поэтому рисуя минимальные фигуры - можно его даже не задавать, все наши движения итак запишутся в нулевой 0 _**VAO**_. В core профилк же мы получим ошибку, там нам всегда явно надо задавать _**VAO**_.

Поэтому разбайнживаем EBO только после того, как разбайндили _**VAO**_.

Так же для того, что бы просто отрисовать например линии фигур без заливки, можно использовать методы:

```C++
m_pData->p45CoreFunc->glPolygonMode(
    GL_FRONT_AND_BACK, 
    GL_LINE
);
```

По дефолту OpenGL всегда использует такую конфигурацию:

```C++
m_pData->p45CoreFunc->glPolygonMode(
    GL_FRONT_AND_BACK, 
    GL_LINE
);
```