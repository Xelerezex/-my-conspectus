Мы уже знакому с тем, как при помощи матриц управлять объектами на сцене, это поможет нам в этой части.

**OpenGL** предполагает, что все вершины должны быть заданы в диапазоне от $-1.0$﻿ до $1.0$﻿, иначе **OpenGL** просто не отрисует вершины, которые находятся за пределами этого рейнджа.

Но так как все мониторы разные и мы не можем высчитывать для каждого отдельно где будет располагаться тот или объект, посредствам задания координат типа $0.66666666666667$﻿ - нам надо как-то по другому переводить все вертексы в Нормализованные Координаты Устройства (_normalized device coordinates_ (_NDC_)). Эти _NDC_ потом передается растеризатору для трансформации их в 2D координаты/пиксели на экране.

Трансформация координат к _NDC_ обычно осуществляется за несколько шагов, шаг-за-шагом, где для начала мы трансформируем координаты вершин последовательно в несколько координатных систем и только потом происходит перегонка в _NDC_ формат.

Преимущества трансформаций в несколько промежуточных систем координат состоит в том, что некоторые операции/вычисления гораздо проще делать в этих системах координат.

Существует как минимум 5 систем координат, которые будут нам интересны:

1. Локальное пространство (или объектное пространство)
2. Мировое пространство
3. Пространство вида (или пространство наблюдателя)
4. Пространство отсечения
5. Пространство экрана

Это все разные состояния наших вершин, до тех пор, пока они не будут окончательно превращены в фрагменты.

## Глобальная Картина

Для трансформации коориднат из одного пространства в другое - мы используем несколько матриц трансформации, из которых самые важные будут - _**Матрица Модели**_, _**Матрица Представления**_ и _**Проекционная Матрица**_.

Теперь пройдемся по общему пайплайну трансформаций - наща вершина сначала начинает свое существование в _**Локальном Пространстве**_ в виде _**Локальных Координат**_ и после этого они проганяются через _**Мировое Пространство**_, далее в _**Пространство Наблюдателя**_, далее в _**Пространство Отсечения**_ и в конечном итоге вершина попадает в _**Пространство Экрана**_.

![[coordinate_systems.png]]

1. _**Локальные Координаты**_ - это координаты нашего объекта относительно его внутреннней локальной точки отсчета (это координаты, где наш объект начинает свое существование).
2. _**Мировое Пространство Координат**_ - следующий шаг, куда трансформируются координаты из _**Локального Пространства**_. Данные координаты по смыслу являются Координатами более общего, большого, мира - и они относительны некой общей точки отсчета. В этом пространстве уже также находится и множество других объектов, расположенных также относительной общей глобальной точки отсчета.
3. _**Пространство Вида**_ - следующий шаг, после трансформации из _**Мирового Пространства Координат**_. В данном пространстве все множество объектов будет отображаться с позиции расположения _Камеры_.
4. _**Пространство Отсечения**_ - сюда мы приходим из _**Пространства Вида**_, поняв как камера видит множество объектов. В данном пространстве как раз и происходит проецирование множества объектов на коордианты вида от $-1.0$﻿ до $1.0$﻿ и определяет где конкретно на экране в дальнейшем отобразится тот или иной объект. Так же при проекции на _**Пространство Отсечения**_, может быть добавлена _Перспектива Объектов_ (если использовалась матрица перспектив).
5. _**Пространство Экрана**_ - завершающий шаг пайплайна трансформации координат объектов, в него мы попадаем из _**Пространства Отсечения**_. В процессе отработки ворфлоу данного пространства вызывается _трансформация области просмотра_ (_viewport transform_), которая трансформирует вершины из координат $-1.0$﻿**,** $1.0$﻿ в координаты реального экрана, которые заданы функцией `glViewport()`.
    
    И как раз координаты, полученные после данного преобразования отправляются в _Растеризатор_ для дальнейшего преобразования их в _Фрагменты_.
    

Причина по которой мы занимаемся такким большим количеством трансформаций (целый полноценный пайплайн) заключается в том, что некоторые операции, которые мы будем проделывать над координатами вершин - имеют смысл и делаются гораздо проще, именно в конкретных пространствах.

К примеру - изменять сам объект логичнее и проще в _**Локальном Пространстве**_, а вычислять определенные операции над объектом по отношению к позиции других объектов - имеет больше всего смысла в _**Мировых Координатах**_.

При большом желании, мы можем определить одну матрицу трансформации для прогонки сразу из _**Локальных Координат**_ в _**Простраство Отсечения**_, но это лешает нас всей гибкости данного пайплайна.

## Локальное Пространство

_**Локальное Пространство**_ - это координатное пространство, считающееся локальным по отношению к конкретному объекту. Представим кубик из программы Блендер, точка отсчета в _**Локальных Координатах**_ (_origin_) скорее всего будет просто на ходится в координатах $(0, 0, 0)$﻿ даже при условии, что куб в конечном итоге отрисуется где-то, справа вверху монитора.

С высокой долей вероятности все модели, что мы будем использовать - будут иметь точку отсчета $(0, 0, 0)$﻿. Таким образом все вершины локальны по отношению к объекту, содержащему эти вершины.

К примеру, мы создавали ранее объект контейнера (прямоугольник с текстурой) с _**Локальными Координатами**_ $-0.5$﻿ и $0.5$﻿ с точкой отсчета $(0, 0, 0)$﻿ - это как раз и есть координаты объекта в _**Локальном Пространстве**_.

## Мировое Пространство

Если мы просто продолжим пользоваться _**Локальными Координатами**_, то получим картину, где у всех объектов точка отсчета $(0, 0, 0)$﻿, и все они расположены друг в дружке. Но мы же хотим получить представление этих объектов, такое, что бы они находились на разном растоянии друг относительно друга и относительно некой _**Мировой**_ точки отсчета.

Координаты в _**Мировом Пространстве**_ - это буквально и есть то, что зашито в название - координаты всех Вершин, относительно Мира (Игрового, 3D и тд).

В данном пространстве мы хотим получить объекты, расмазанные по всему миру (желательно в реалистичном ключи) для трансформации из Локальных Координат, мы будет использовать _Модельную Матрицу_.

_Модельная Матрица_ - это матрица трансформации, которая может Транслировать, Отскейлить и/или Повернуть объекты, разместив их в тех позиях и положениях, которые хочет программист.

В прошлой главе мы изменяли положения контейнера (прямоугольник с текстуркой) - это по факту мы и осуществляли трансформацию по средствам _Модельной Матрицы_.

## Пространство Вида

_**Вид**_, в контексте OpenGL обычно используется для обозначения _Камеры_ (само пространство иногда называется еще _пространство камеры_, или _пространство наблюдателя_).

Пространство вида есть результат трансформации вершин из координат _**Мирового Пространства**_ в _**Пространство Вида**_.

Такого эфекта получается добиться комбинируя Трансляцию и Повороты, что бы транслировать/повернуть сцену так, что бы все объекты на этой сцене повернулись к _Камере_.

Такая объединенная трансформация обычно хранится в _Видовой Матрице_, она трансформирует координаты вершин объектов из _**Мирового Пространства**_ в _**Пространство Вида**_.

## Пространство Отсечения

После отработки любого _Вертексного Шейдера_ **OpenGL** предполагает, что координаты вершин будут в определнном числовом диапазоне - все что в этот диапазон не попало - **отсекается**. Отсеченые координаты просто будут сохранены в памяти (тк например при повороте камеры нам надо будет их отрисовать), а те вершины, что попали в рейндж - пойдут дальше по пайплайну **OpenGL** и будет перегнаны в Фрагменты (которые как раз мы и увидим на экране).

Из-за того, что определение всех видимых координат в диапазоне от $-1.0$﻿ до $1.0$﻿ крайне контринтуитивная задача, мы определеяем свой собственный набор координат, взаимодействуем с ним, и только потом перегоняем из обратной в _NDC_, как того и ждет **OpenGL**.

Для трансформации вершинных координат из _**Видового Пространства**_ в _**Пространство Отсечения**_ мы должны определить _Матрицу Проекций_, у которой диапазон координат находится между $-1000$﻿ и $1000$﻿ в каждом измерении. Потом _Матрица Проекций_ конвертирует координаты, заданные этим специфическим диапазоном в Нормализованные Координаты Устройства (_NDC_) с диапазоном от $-1.0$﻿ до $1.0$﻿ (данная конвертация не происходит напрямую, посредине сидит такой шаг, как _Разделение Перспективы_).

Все вершины имеющие, в конечном итоге, координаты не лежащие в диапазоне от $-1.0$﻿ до $1.0$﻿ будут отсечены. К примеру, мы получили координаты одной вершины в следующем виде - $(1250, 500, 750)$﻿, координата $X$﻿ после прохождения трансформации не будут попадать в диапазон от $-1.0$﻿ до $1.0$﻿, поэтому эта вершина будет отсечена.

- Учитывайте!
    
    Обратите внимание на то, что если вне объема отсечения находится не весь примитив, например треугольник, а только его часть, то **OpenGL** перестроит этот треугольник в виде одного или нескольких треугольников, которые будут полностью находиться в диапазоне отсечения.
    

_Матрица Проекций_ создает такую вещь, как _Усеченная Пирамида_ (_frustum_), и всякая координата, что попадет в эту _Пирамиду_ - будет, в конечном итоге, отображена на экране у пользователя.

Окончательный процесс конвертации координат вершин из специфических координат, заданных ранее Матрицей Проекции, в NDC, так что все координаты могут быть легко отмаплены на 2D пространство называется - _**Проекция**_. Так как _**Матрица Проекций**_ _проецирует_ 3D координаты легко-отмапливаемые-на-2D Нормализованные Координаты Устройства (_NDC_).

В тот момент, когда все вершины трансформируются в _**Пространство Отсечения**_, конечная операция, называемая _Деление Перспективы_, применяется к координатам вершин. Выглядит это операция следующим образом - берутся компоненты $x, y, z$﻿ позиционного вектора и делятся на [[Гомогенные Координаты]] $w$﻿. _Деление Перспективы_ есть трансформация из 4D _**Кординат Пространства Отсечения**_ в 3D Нормализованные Пространственные Координаты (_NDC_). Этот шаг происходит автоматически в конце отработки Вертексного Шейдера.

Именно после этого шага и происходит наложение результирующих координат на координаты экрана (используя настройки, заданные в `glViewport()`) и потом они превращаются в фрагменты.

Обычно _**Матрица Проекции**_ принимает две различные формы (используется только одна), и каждая из этих форм задает свою _Усеченную Пирамиду_ (_frustum_) - можно создать либо _**Ортографическую Матрицу Проекции**_, либо _**Перспективную Матрицу Проекции**_.

[[Гомогенные Координаты]]

### Ортографическую Матрицу Проекции

_**Ортографическая Матрица Проекции**_ - задает кубоподобную _Усеченную Пирамиду_ (_frustum_), пирамида, в свою очередь, задает пространство, где попавшие в него Вершины не будут отсечены.

Задавая _**Ортографическую Матрицу Проекции**_ мы указываем ширину, высоту и длину видимой _Усеченной Пирамиды_. Все вершины, которые попадает координатами в эту _Усеченную Пирамиду_ в дальнейшем будут приведены к _NDC_.

Данная _Усеченная Пирамида_ напоминает грузовой контейнер:

![[orthographic_frustum.png]]

_Ортографическая_ _Усеченная Пирамида_ определяется при помощи:

- Ширины
- Высоты
- Ближней Плоскости
- Дальней Плоскости

Если какие-то координаты попадают перед Ближней Плоскостью - или за Дальней Плоскостью, они будут отсечены.

_Ортографическая_ _Усеченная Пирамида_ мапит все координаты в ND_C_ **напрямую**, безо всяких дополнительных сайд эфектов, так при трансформации не затрагивается координата $w$﻿ у трасформируемого вектора (Если координата $w$﻿ остается равна $1.0$﻿ то _Деление Перспективы_ не изменяет координаты).

В `glm` такое преобразование можно получить посредствам функции `glm::ortho`:

```C++
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
```

1. Первый аргумент - левая координата _Усеченной Пирамиды_.
2. Второй аргумент - правая координата _Усеченной Пирамиды_.
3. Третий аргумент - нижняя координата _Усеченной Пирамиды_ (ширина).
4. Четвертый аргумент - верхняя координата _Усеченной Пирамиды_ (высота).

Данными 4-мя аргументами мы опредееляем размер Ближней и Дальней Плоскости.

5. Пятый аргумент - определяет положение Ближней Плоскости, все Вершины, которые находятся до этого значения - будут отсечены
6. Шестой аргумент - определяет положение Дальней Плоскости, все Вершины, которые находятся после этого значения - будут отсечены

То есть по факту, эти 2 аргумента определеяют растояние от Ближней до Дальней плоскости.

И соответсвенно все координаты вершин по $x, y, z$﻿ попадающие в заданную _Ортографическая_ _Усеченная Пирамида -_ будут в дальнейшем переведены в NDC и отображены пользователю.

Но стоит учитывать, что так как _**Ортографическая Матрица Проекции**_ мапит координаты напрямую в 2D, без учета перспективы, если это изначально какой-то 3D объект - картинка получается нереалистичной. Для решения таких вопросов и существует _**Перспективная Матрица Проекции.**_

## Общая математическая сводка по пайплайну трансформаций

### Перспективная Матрица Проекции

Базовая концепция перспективы состоит в том, что чем дальше объект - тем меньше на 2D плоскости он кажется.

К примеру, если смотреть на бесконечное шоссе, уходящие вдаль - мы увидим следующую картинку:

![[perspective.png]]

Благодаря перспективе линии кажутся нам, с позиции наблюдателя, уходящими вдаль (хотя в какую даль они уходят, это пиксели в 2D?).

Именно под этот эффект и пытается мимикрировать трансформация осуществляемая _**Перспективной**_ _**Матрицей Проекции**_. Матрица проекции, в данном, случае мапит данную нам Усеченную Пирамиду для того, что бы отсечь пространство, но она также и манипулирует координатой $w$﻿ в каждой вершине, таким образом, что “чем дальше” находится координата от наблюдателя, тем больше становится значение компоненты $w$﻿. Ровно в тот момент, когда координаты трансформируются в пространство отсечения они должны попадать в диапазон от $-w$﻿ до $w$﻿ (все что находится вне диапазона - отсекается).

OpenGL требует, чтото бы конечным выводом вершинного шейдера были координаты между $-1.0$﻿ и $1.0$﻿, таким образом когда координаты еще находятся в _**Пространстве Отсечения**_, _Деление Перспективы_ применяется ко всем вершинным координатам:

$$out = \begin{pmatrix} x /w \\ y / w \\ z / w \end{pmatrix}$$

Каждая компонента вертексной координаты делется на компоненту $w$﻿ и таким образом достигается эффект - что при удалении от наблюдателя вертексной координаты, она становится меньше. Результирующие координаты - как раз потом и становятся _**NDC**_.

_**Перспективной**_ _**Матрицей Проекции**_ есть готовая в библиотеке `GLM`, вызывается она следующим образом:

```C++
glm::mat4 proj = glm::perspective(
		glm::radians(45.0f), 
		(float)width / (float)height, 
		0.1f, 
		100.0f
);
```

Функция `glm::perspective` создает _Усеченную Пирамиду_, которая определяет видимое , пользователем, пространство - все вершины вне этой _Пирамиды_ при дальнейшем переходе в _**Пространство Отсечения**_ не будут отрисовываться в конечном итоге.

Визуализировать _Усеченную Пирамиду Перспективы_ можно как коробку трапециевидной формы, каждая координата внутри которой будет отображена в точку в пространстве отсечения.

![[perspective_frustum.png]]

1. Первый аргумент - задает градус _Поля Обзора_ (_fov - field of view_) и выставляет - насколько широким оно будет. Обычно для реалистичной картинки достаточно $45^{\circ}$﻿ но для более думо-подобного варианта можно выставить и более высокие значения.
2. Второй аргумент - задает соотношение сторон, которое высчитывается посредствам деления ширины области видимости на её высоту.
3. Третий аргумент - задает ближнюю плоскость плоскость _Усеченой Пирамиды_. Самый обычный случай, когда этот аргумент задается как $0.1$﻿.
4. Четвертый аргумент - задает дальнюю плоскость _Усеченой Пирамиды_. Чаще всего этот аргумент задается как $100.0$﻿.

- **Заметка про задание ближней и дальней плоскости**
    
    Если задать ближнюю плоскость слишком высоким числом, типа $10.0$﻿. OpenGL будет вырезать все объекты расположенные слишком близко к _Камере_ (это объекты от $0.0$﻿ до $10.0$﻿), что может привести к такому визуальному эффекту - как в некоторых играх, когда подходишь слишком близко к какому-то объекту начинаешь видеть через это объект и еще несколько
    

### Небольшое саммари по Перспективной и Ортогографической Матрице Проекций

При использовании ортографической проекции каждая из вертексных координат напрямую мапится в _**Пространство Отсечения**_ без всяких _Преобразований Перспективы_ (Все еще к каждой координате применяется _Деление Перспективы_, просто учитывая, что компонента $w$﻿ равняется $1.0$﻿ - мы видим все вертексы как равнокдаленные от наблюдателя). Собственно из-за эффекта равноудаленности вертексов - ортографическая перспектива обычно используется только при рендеринге чистого 2D, либо в инженерных или архитектурных программах - где есть задача не искажать вершины перспективой.

Приложения же типа Бленда - рендерят объекты в 3D, поэтому для визуальной схожести с реальными объектами - используют _Перспективные Проекции_, и объекты визально начинают иметь длину по третей оси.

Пример как разные проекции будут выглядеть в Блендере:

![[perspective_orthographic.png]]

## Правосторонняя система

По соглашению **OpenGL** представляет все координаты в правосторонней системе координат. В классическом понимании, простыми словами, это значит, что положительная ось $\textcolor{\#FF3333}{+X}$﻿ смотрит _вправо_, а значит положительная ось $\textcolor{\#4D9900}{+Y}$﻿ смотрит вверх и положительная ось $\textcolor{\#4287FF}{+Z}$﻿будет смотреть прямо на наблюдающего (или назад относительно направления взгляда).

Выглдяеть это будет следующим образом:

![[right_handed_system.svg]]

Небольшая подсказка как определить систему как правосторонюю (Метод правой руки):

- Вытянете правую руку так, что бы ладонь смотрела на вас, а все пальцы ложились на $\textcolor{\#4D9900}{+Y}$﻿.
- Вытянете большой палец, что бы он смотрел направо ($\textcolor{\#FF3333}{+X}$﻿).
- Сожмите все остальные пальцы, кроме указательного, который смотрит наверх ($\textcolor{\#4D9900}{+Y}$﻿) и большого, который смотрит направо ($\textcolor{\#FF3333}{+X}$﻿).
- Вытянете средней палец перпендикулярно ладони, что бы он смотрел на вас ($\textcolor{\#4287FF}{+Z}$﻿).

Если проделать аналогичную операцию с левой рукой, а потом перевернув ее ладонью от нас, то мы получим картинку Левосторонней системы координат (именно такую и использует **DirectX**)

![[right-left-handed-system.png]]

## Немного математики

[[Математическа стоящая за Ортографической и Перспективной Проекцией]]

## Собираем все трансформации Вместе

Таким образом мы описали все матрицы трансформации для каждого, из вышеописанных шагов: _**Модели**_, _**Отображения**_ и _**Проекции**_. Координаты Вершины, потом будут трансформированы в _**Координаты Отсечения**_, следующим образом:

$$
V_{clip} \ =\ M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}
$$

Обратим внимание, чт оматрицы идут не по порядку, а в обратном положении (помним, что матричное перемножение читается справа налево). Результирующие координаты вершины должны быть присвоены переменной `gl_Position` в вертексном шейдере и **OpenGL** автоматически, сам, применит _**Деление Перспективы**_ и _**Отсечение**_.

- **А что потом?**
    Выхлоп вертексного шейдера требует, что бы координаты находились в Пространстве Отсечения, что мы сейчас и сделали, используя _Матрицу Трансформации_. После этого **OpenGL** делает _**Деление Перспективы**_ _**Координат**_ _**Отсечения**_, для дальнейшей трансформации их в _**NDC**_. Далее **OpenGL** использует параметры, взятые функцией `glViewPort` что бы смапить _**NDC**_ на реальные _**Экранные Координаты**_, которые буквально соотносятся с точками на мониторе (к примеру 800x600). Данный процесс называется **Преобразование Области Просмотра**.

### Дополнительная информация по данному параграфу

[[Трансформации в OpenGL]]

## Переходим в 3D

После того, как мы изучили основные Трансформации отвечающие за трансформациб из 3D в 2D, стоит наконец-то начать отрисовывать реальные 3D объекты!

Для начала нам надо создать матрицу Модели, в нее будет входить трансляция, сейлинг и/или вращения. На этом этапе мы хотим применить трансформацию ко всем Объектным Вершинам в _**Глобальном Координатном Пространстве**_.

Для начала трансформируем наш контейнер иак, что бы будто немного лежал на полу. Для это нам надо будет повернуть его вокруг оси $\textcolor{\#FF3333}{X}$﻿:

```C++
glm::mat4 model = glm::mat(1.0F);
model = glm::rotate(
		model,
		glm::radians(-55.0F),
		glm::vec3(1.0F, 0.0F, 0.0F)
);
```

Умножая все вершинные координаты на матрицу `model` мы перегоняем все вертексные координаты в _**Мировые Координаты**_. Таким образом, наш контейнер, слегка приподнятый над полом, представляет собой плоскость в глобальном мире.

Теперь нам надо создать Видовую Матрицу - мы хотим отойти немного назад от дефолтной сцены (потому что в Мировых Координатах мы стоим в $(0, 0, 0)$﻿). А что бы двигаться по сцене, нам, по факту, надо двигать сцену - тк в **OpenGL** камера всегда стоит на одном месте. Тк в OpenGL используется правосторонняя система координат, то, если нам надо сдвинуть камеру назад на (по оси $\textcolor{\#4287FF}{+Z}$﻿) то все объекты должны сдвигаться по оси $\textcolor{#4287FF}{-Z}$﻿.

Зная это _Видовая Матрица_ будет выглядеть так:

```C++
glm::mat4 view = glm::mat4(1.0F);
view = glm::translate(view, glm::vec3(0.0F, 0.0F, -3.0F));
```

  

И в последнюю очередь мы определим - матрицу Проекции. Тк визуально мы хотим наблюдать перспективу, используем функцию `glm::perspective`:

```C++
glm::mat4 projection;
projection = glm::perspective(
		glm::radians(45.0f), // FOV angle
		800.0f / 600.0f, 
		0.1f, 
		100.0f
);
```

А теперь эти три матрицы должны отправиться в шейдер:

```C++
#version 460 core

layout (location = 0) in vec3 aPosition;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTextureCoordinate;

out vec3 outColor;
out vec2 outTextureCoordinate;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main()
{
    // Warning: Not modelMatrix * viewMatrix * projectionMatrix, 
    //          but inverse order of operation
    gl_Position 
        = projectionMatrix 
        * viewMatrix 
        * modelMatrix 
        * vec4(aPosition.x, aPosition.y, aPosition.z, 1.0);
    
    outColor = aColor;
    outTextureCoordinate = aTextureCoordinate;
}
```

**OpenGL** хранит информацию о глубинах в буффере, называемом $\text{z-buffer}$﻿ (_depth buffer_), у управление именно этими данными дает нам рычаги, что бы выбирать когда отрисовывать пиксель на пикселе, а когда нет. Используя $\text{z-buffer}$﻿ мы можем настроить, такую вещь, как тестирование глубины(depth-testing)

### Z-buffer

Очень часто библиотеки ти па `Qt` или `GLFW` автоматически сами создают такой буфер за нас (например как цветовой буфер(color buffer) который хранит все цвета получившейся картинки). Глубины хранятся внутри каждого объекта (как компонента $\textcolor{\#4287FF}{z}$﻿) и в любой момент, когда фрагмент хочет выплюнуть какой-то цвет OpenGL сравнивает его значение глубины со значениями в $\text{z-buffer}$﻿. Если текущий фрагмент находится За другим фрагментом - он отвергается, иначе перезаписывается. Данный процесс и называется _**Тестирование Глубины**_, и делается оно автоматически **OpenGL**, пользователю не нужно следить за этим сравнением.

Но как обычно, если мы сто процентов хотим включить данное тестирование, для начала нам надо сказать об этом **OpenGL**:

```C++
glEnable(GL_DEPTH_TEST);
```

А так же, как и с цветами ранее - мы хотели бы очищать этот буффер на каждой итерации отрисовки, иначе информация там просто будет оставаться и мы будет получать артефакты:

```C++
glClear(
	GL_COLOR_BUFFER_BIT 
	|  GL_DEPTH_BUFFER_BIT
);
```

### Больше кубиков!

Для начала зададим позиции для наших объектов:

```C++
glm::vec3 cubePositions[] = {
    glm::vec3( 0.0f,  0.0f,  0.0f), 
    glm::vec3( 2.0f,  5.0f, -15.0f), 
    glm::vec3(-1.5f, -2.2f, -2.5f),  
    glm::vec3(-3.8f, -2.0f, -12.3f),  
    glm::vec3( 2.4f, -0.4f, -3.5f),  
    glm::vec3(-1.7f,  3.0f, -7.5f),  
    glm::vec3( 1.3f, -2.0f, -2.5f),  
    glm::vec3( 1.5f,  2.0f, -2.5f), 
    glm::vec3( 1.5f,  0.2f, -1.5f), 
    glm::vec3(-1.3f,  1.0f, -1.5f)  
};
```

А теперь просто для каждого объекта надо будет вызвать свой `glDrawArrays()`, но отсылая другую _Матрицу Модели_ в вертексный шейдер перед вызовом отрисовки:

```C++
glBindVertexArray(VAO);
for(unsigned int i = 0; i < 10; i++)
{
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::translate(model, cubePositions[i]);
    float angle = 20.0f * i; 
    model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
    ourShader.setMat4("model", model);

    glDrawArrays(GL_TRIANGLES, 0, 36);
}
```