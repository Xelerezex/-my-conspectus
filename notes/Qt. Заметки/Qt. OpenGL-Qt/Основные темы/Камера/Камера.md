---


---
---

Данная заметка, является переводом [вот этой](https://learnopengl.com/Getting-started/Camera) статьи.

---

В прошлой заметке рассматривались трансформации, проводимые над всеми Вершинами, в том числе такие как скейлинг, поворот, трансляция. Последнюю трансформацию мы как раз и рассмотрим подробнее - так как она есть основа, для создания _Камеры_.

**OpenGL**, сам по себе, не включает в себе такую концепцию, как _Камера_, но применяя знания из прошлой заметки - мы можем симулировать её, двигая **все** объекты (все вершины объектов), в обратном направления от смотрящего, создавая иллюзию движения _Камеры_.

## Пространство Камеры (Наблюдателя)

Когда мы говорим о _**Координатах Наблюдателя/Камеры**_, мы говорим о всех _**Вершинных Координатах**_, которые видны с позиции некой _Камеры_ (или _Наблюдателя_), которая находится в начале всех координат. _Видовая Матрица_ трансформирует все _**Мировые Координаты**_ в _**Координаты Наблюдателя**_, от которых напрямую зависит положение и направление _Камеры_.

Для того, что бы определить _Камеру_ в пространстве нужно 4 компонента:

1. Позиция в _**Мировых Координатах**_, относительно глобального центра координат.
2. Направление, куда _Камера_ смотрит.
3. Вектор, который смотрит направо, от направления взора _Камеры_.
4. Вектор, который смотрит вверх, от направления взора _Камеры_.

И по факту, эти 4 компоненты, описывают новую систему координат.

![[camera_axes.png]]

- Вся необходимая информация для описание систем координат:
    
    [[Уравнение Линии в 3-м измерении]]
    
    [[Уравнение Плоскости]]
    
    [[OpenGL Камера. Математическое Представление]]
    
### 1. Позиция Камеры в Мировых Координатах

Так как позиция находится в Мировых Координатах $(\textcolor{\#FF0000}{0}, \textcolor{\#01FF00}{0}, \textcolor{\#0000FF}{3})$﻿, задать её до банальности просто:

```C++
glm::vec3 cameraPos = glm::vec3(0.0F, 0.0F, 3.0F);
```

### 2. Направление обзора Камеры

Мы предполагаем, что камера смотрит в точку $(\textcolor{#FF0000}{0}, \textcolor{#01FF00}{0}, \textcolor{#0000FF}{0})$﻿ (Именно так и показано на рисунке выше). Для нахождения направления, мы вычтем из позиции Камеры значения вектора, куда камера Смотрит, так называемая целевая точка, и визуально нам это даст вектор, с начачлом в $(\textcolor{#FF0000}{0}, \textcolor{#01FF00}{0}, \textcolor{#0000FF}{3})$﻿ и с концом в $(\textcolor{#FF0000}{0}, \textcolor{#01FF00}{0}, \textcolor{#0000FF}{0})$﻿, после этого обязательно не забудем про нормализацию, тк нам нужно только направление вектора, по аналогии с [[OpenGL Камера. Математическое Представление]] И как раз-таки данное вачитание и подарит нам отричание по оси $\textcolor{#0000FF}{Z}$﻿ (не забываем, что у _Камеры_ своя система координат)

```C++
glm::vec3 cameraTarget = glm::vec3(0.0F, 0.0F, 0.0F);
glm::vec3 cameraRiverseDirection = glm::normalize(cameraPos - cameraTarget); 
// Camera now pointing
// reversely regarding it's real target 
```

### 3. Правая Ось Камеры

Следующий вектор, который нам надо задать это $\textcolor{#FF0000}{\text{правый}}$﻿ вектор, который представляет собой положительную ось $\textcolor{#FF0000}{X}$﻿ в _**Координатах Камеры**_. Для этого мы используем небольшой трюк, определив сначала $\textcolor{#01FF00}{\text{верхний}}$﻿ вектор, который смотрит строго вверх в _**Мировых Координатах**_. Потом мы применяем векторной произведение к $\textcolor{#01FF00}{\text{верхнему}}$﻿ вектору и вектору направления $\textcolor{#0000FF}{\text{вперед}}$﻿ из пункта 2. Так мы и получим наш $\textcolor{#FF0000}{\text{правый}}$﻿ вектор, тк результат векторного произведения можно интерпретировать как ортогональный вектор (причем так мы получили положительный $\textcolor{#FF0000}{\text{правый}}$﻿ вектор, если бы изменили поряд действий вышло бы так $\textcolor{#0000FF}{\text{передний}} \times \textcolor{#01FF00}{\text{верхний}} \ =\ - \textcolor{#FF0000}{\text{правый}}$﻿, а не так $\textcolor{#01FF00}{\text{верхний}} \times \textcolor{#0000FF}{\text{передний}} \ =\ \textcolor{#FF0000}{\text{правый}}$﻿).

```C++
glm::vec3 up = glm::vec3(0.0F, 1.0F, 0.0F); // Set vector Up by hands
glm::vec3 cameraRight = glm::normailze(glm::cross(up, cameraRiverseDirection));
```

### 4. Верхняя ось Камеры

Когда мы имеем два определенных вектора $\textcolor{\#FF0000}{\text{правый}}$﻿ и $\textcolor{\#0000FF}{\text{передний}}$﻿, $\textcolor{\#01FF00}{\text{верхний}}$﻿ вектор камеры (Не $\textcolor{#01FF00}{\text{верхний}}$﻿ вектор в Мировых Координатах, как это было в пункте 3), находится очень просто - берем векторное произведение: $\textcolor{#0000FF}{\text{передний}} \times \textcolor{#FF0000}{\text{правый}}\ =\ \textcolor{#01FF00}{\text{верхний}}​$﻿.

```C++
glm::vec3 cameraUp = glm::cross(cameraRiverseDirection, cameraRight);
```

При помощи данных манипуляций мы смогли создать все векторы, которые формируют Видовое/Камерное пространство. Более формально, в линейной алгебре, этот процесс называется [Процесс Грамма-Шмидта](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process) ([[TODO]] написать заметочку по этому процессу).

Зная про все эти вектора мы сможем составить теперь ключевую трансформацию $LookAt$﻿.

## Трансформация $LookAt$﻿

Великолепное свойство Матриц заключается в том, что когда мы задаем координатное пространство используя 3 перпендикулярных (или другими словами нелинейных) оси, мы можем сделать матрицу используя лишь эти 3 вектора и плюс вектор трансляции. И к суммарно получивше пространству можно привести абсолютно любой вектор, если умножить его на эту матрицу. Это и есть буквально ключевая идея матрицы $LookAt$﻿. И выглдядеть она будет так:

Более точное описание этой матрицы можно прочитать [[OpenGL Камера. Математическое Представление]] и [[Вектор $lookAt$ относительно оси]].
$$
LookAt \ = \ \begin{pmatrix} \textcolor{#FF0000}{R_{x}} && \textcolor{#FF0000}{R_{y}} && \textcolor{#FF0000}{R_{z}} && 0 \\ \textcolor{#01FF00}{U_{x}} && \textcolor{#01FF00}{U_{y}} && \textcolor{#01FF00}{U_{z}} && 0 \\ \textcolor{#0000FF}{D_{x}} && \textcolor{#0000FF}{D_{y}} && \textcolor{#0000FF}{D_{z}} && 0 \\ 0 && 0 && 0 && 1 \end{pmatrix} \begin{pmatrix} \textcolor{#FF0000}{1} && 0 && 0 && -P_{\textcolor{#FF0000}{x}} \\ 0 && \textcolor{#01FF00}{1} && 0 && -P_{\textcolor{#01FF00}{y}} \\ 0 && 0 && \textcolor{#0000FF}{1} && -P_{\textcolor{#0000FF}{z}} \\ 0 && 0 && 0 && 1 \end{pmatrix}
$$
Где $\textcolor{#FF0000}{R}$﻿ это $\textcolor{#FF0000}{\text{правый}}$﻿ вектор, $\textcolor{#01FF00}{U}$﻿ - это $\textcolor{#01FF00}{\text{верхний}}$﻿ вектор, а $\textcolor{#0000FF}{D}$﻿ - это вектор направления $\textcolor{#0000FF}{\text{вперед}}$﻿. И $P$﻿ - это нынешняя позиция _Камеры_. Левая матрица - матрица поворота, правая матрица - матрица трансляции. И обратим внимание. что первая матрица транспонирована, а вторая - отрицательна. Это происходит из-за того, что мы хотим вращать и передвигать мировые координаты в противоположной от движения Камеры направление.  
Используя эту матрицу  
$LookAt$﻿ как _**Видовую**_, мы успешно трансформируем все вертексы в _**Мировые Координаты**_.

```C++
glm::mat4 view;
view = glm::lookAt(
	glm::vec3(0.0F, 0.0F, 3.0F), // Camera position
	glm::vec3(0.0F, 0.0F, 0.0F), // Target position
	glm::vec3(0.0F, 1.0F, 0.0F)  // Up vector in world space
);
```

Перед тем, как с ноги залетать в ввод данных от пользователя, для начала просто в коде покрутим этой камерой:

```C++
// VIEW
constexpr float radius = 5.0F;
const float cameraX = glm::sin(m_pData->timerSecondsCount) * radius;
const float cameraZ = glm::cos(m_pData->timerSecondsCount) * radius;
auto view = glm::lookAt(
    glm::vec3(cameraX, 0.0F, cameraZ),
    glm::vec3(0.0F, 0.0F, 0.0F),
    glm::vec3(0.0F, 1.0F, 0.0F)
); 
if (!m_pData->pProgramHandler->setFloatMatrixUniform(
        QStringLiteral("viewMatrix"), 
        glm::value_ptr(view)
    )
)
{
    return opengl_utils::locals::PrintLine<void>(__FILE__, __LINE__);
}
```

## Прогуляемся вокруг

Теперь зададим 3 переменные, которые нам будут нужны для управления матрицей:

```C++

glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);
```

И матрица $LookAt$﻿ превращается в:

```C++
view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
```

Направление, теперь это - нынящняя позиция + вектор направления, который мы определили ранее. Это действие дает гарантию, что как бы мы не двигались - камера будет продолжать смотреть на целевую точку.

Теперь внесем код для обработки позиции камеры при помощи клавиш:

```C++
// Хождение Камерой
if (pEvent->key() == Qt::Key_W)
{
    m_pData->cameraPos += cameraSpeed * m_pData->cameraFront;
}
else if (pEvent->key() == Qt::Key_S)
{
    m_pData->cameraPos -= cameraSpeed * m_pData->cameraFront;
}
else if (pEvent->key() == Qt::Key_A)
{
    m_pData->cameraPos -= glm::normalize(
        glm::cross(m_pData->cameraFront, m_pData->cameraUp)
    ) * cameraSpeed;
}
else if (pEvent->key() == Qt::Key_D)
{
    m_pData->cameraPos += glm::normalize(
        glm::cross(m_pData->cameraFront, m_pData->cameraUp)
    ) * cameraSpeed;
}
```

Теперь когда мы зажимаем одну из кнопок $WASD$﻿ камера будет перемещаться каким-то образом.

Так же обратим внимание, что мы нормализуем результирующий $\textcolor{#FF0000}{\text{правый}}$﻿ вектор. Если бы мы этого не делали - то векторное произведение возвращало бы разные значения в зависимости от переменной `cameraFront`. Мы бы перемещались гораздо медленнее, либо же очень быстро в зависимости от ориентации камеры, а не от заданной скорости.

Но сейчас скорость вышла , по факту, системо-зависимой, а мы бы хотели сделать ее более универсальной.

## Скорость передвижения Камеры

На данный момент в прошлой части мы использовали константную скорость для всех передвижений камеры - но такой подход не учитывает систему, на которой будет работать приложение. Так как у конечных пользователей могут быть разные машины, у кого-то тактовая частота будет высокой, у кого-то она будет низкой - тогда в первом случае пользователь получит и скорость и обработку ивентов гораздо быстрее, чем второй пользователь. ==Поэтому константная скорость - системо-зависимая==.

Поэтому графические приложения и игры обычно используют концепцию `deltatime`. Это переменная, которая хранит в себе время, которое было при рендере последнего фрейма. Потом мы умножаем все скорости на эту переменную - и в результате, когда мы имеем большее значение по `deltaTime`, это значит, что рендеринг фрейма занял больше времени и скорость для следующего фрейма должна быть выше, для баланса. И тогда нам без разницы - машинка пользователя слабая или сильная - каждый получит примерно равный экспириенс работы с программой.

Для высчитывания `deltaTime` нужно хранить две глобальные переменные:

```C++
float deltaTime = 0.0f;	// Time between current frame and last frame
float lastFrame = 0.0f; // Time of last frame
```

На каждый фрейм мы получаем новое значение `deltaTime`:

```C++
float currentFrame = timerSecondsCount;
deltaTime = currentFrame - lastFrame;
lastFrame = currentFrame;  
```

И теперь скорость _Камеры_ можно представить как:

```C++
float cameraSpeed = 2.5f * deltaTime;
```

Благодаря этому - у нас получается более гладкое скольжение _Камеры_.

## Осмотреться по сторонам

Используя в своих перемещениях только клавиатуру может быть утомительно и пользователь не сможет дойти до некоторых нужных ему объектов. Поэтому к нам, как инструмент перемещения - добавляется еще и мышь.

Что бы осмотреться по сторонам - нам следует изменить переменную `cameraFront`, относительно значений приходящих с мыши.

### Углы Эйлера

Углы Эйлера - это три значения, которые представляют собой поворот по 3м осям в 3Д (Они были определены Эйлером где-то в 1700х годах). Эти углы для упрощения называют следующим образом: Тангаж(Pitch) - Рыскание(Yaw) - Крен(Roll):

![[camera_pitch_yaw_roll.png]]

- **Тангаж** - представляет как мы будем смотреть вверх/вниз.
- **Рыскание** - представление величины того, как мы будем ссмотреть влево/вправо.
- **Крен** - представляет насколько сильно было откланение от изначальной позиции.

По факту для нашей камеры - нам достаточно Тангажа и Рыскания, Крен - мы не будем разбирать. Если задать значения Тангажа и РЫскания, то мы без проблем сможем представить их как 3х мерный вектор направления.

Вспомним немного тригонометрии:

![[basic_trigonometry.svg]]

Более подробно можно посмотреть [[Заметки по тригонометрии]].

Если мы определим, что гипотенуза - единичный отрезок, то по правилу $soh\ cah\ toa$﻿ мы получим, что прилегающая сторона: $\frac{cos\ \textcolor{#FF0000}{x}}{\textcolor{#A585FF}{h}}$﻿ и противополжная сторона $\frac{sin\ \textcolor{#01FF00}{y}}{\textcolor{#A585FF}{h}}$﻿. Эти формулы дают нам основные инструменты для получения длины основных сторон по $\textcolor{#FF0000}{x}$﻿ и по $\textcolor{#01FF00}{y}$﻿, основываясь на данном угле.

Теперь просто представим, что мы смотрим на нашу _Камеру_ строго сверху и разберем угол **Рыскания**.

![[yaw_camera_angle.svg]]

На коде данная история будет выглядеть так:

```C++
glm::vec3 direction;
direction.x = cos(glm::radians(yaw));
direction.z = sin(glm::radians(yaw));
```

Теперь посмотрим как в это соотношение вписывается угол **Тангажа**:

![[pitch_camera_angle.svg]]

Где $\textcolor{#FF0000}{X}/\textcolor{#0000FF}{Z}$﻿ - говорит о том, что данное соотношение применяется и по $\textcolor{#FF0000}{X}$﻿ и по $\textcolor{#0000FF}{Z}$﻿. И соответсвенно изменение по оси $\textcolor{#01FF00}{Y}$﻿ можно рпдеставить функцией $sin\ \textcolor{#01FF00}{pitch}$﻿, и на коде это выглядит так:

```C++
direction.y = sin(glm::radians(pitch));
```

Как показано на картинке выше - мы видим, что сторона $\textcolor{#FF0000}{X}/\textcolor{#0000FF}{Z}$﻿ также находится в зависимости ль угла $\textcolor{#01FF00}{pitch}$﻿, а значит нам надо домножить на это значение ось $\textcolor{#FF0000}{X}$﻿ и $\textcolor{#0000FF}{Z}$﻿.

```C++
glm::vec3 direction;
direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
direction.y = sin(glm::radians(pitch));
direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
```

Данная формула дает нам 3-х мерный вектор, который мы можем использовать для того, что бы осмотреться вокруг.  
Мы настроили координаты  _Сцены_ таким образом, чтобы все было расположено в направлении отрицательной оси $\textcolor{#0000FF}{Z}$﻿. Однако, если мы посмотрим на треугольник отклонения $\textcolor{#FF0000}{X}$﻿ и $\textcolor{#0000FF}{Z}$﻿, мы увидим, что при $\theta = 0$﻿, вектор направления _Камеры_ будет направлен в сторону положительной оси $\textcolor{#FF0000}{X}$﻿. Чтобы убедиться, что камера по умолчанию направлена в сторону отрицательной оси $\textcolor{#0000FF}{Z}$﻿, мы можем задать отклонение по умолчанию на $90^{\circ}$﻿ по часовой стрелке. Положительные углы поворачиваются против часовой стрелки, поэтому мы устанавливаем значение отклонения по умолчанию равным:

```C++
yaw = -90.0f;
```

### Ввод с мыши

Ввод с мыши, когда она двигается по горизонтали влияет на угол $\textcolor{\#FF0000}{yaw}$﻿, а по вертикали на - $\textcolor{#01FF00}{pitch}$﻿. Идея тут заключается в следующем - хранить позицию мыши с последнего фрейма и высчитывать, как сильно изменилось значение за 1 фрейм - чем сильнее изменение, тем больше должен быть фактический сдвиг _Камеры_.

Перед тем как обработать мышь для _Камеры_ полетного стиля, нам следует предпринять несколько шагов, перед тем как высчитать вектор поворота:

1. Высчитать смещение мыши относительно прошлого фрейма.
2. Добавить это смещение к значению $\textcolor{#FF0000}{yaw}$﻿ и $\textcolor{#01FF00}{pitch}$﻿.
3. Добавить несколько ограничений на минимум и максимум для значения $\textcolor{#01FF00}{pitch}$﻿.
4. Высчитать вектор направления.

Инициализационные значения должны быть - середина монитора (или виджета) где идет отображение:

```C++
float lastX = 400F
float lastY = 300F;
```

Потом в колбэке для мышки мы высчитаем смещение из пункта 1 и 2.

```C++
float xOffset = xPos - lastX;
float yOffset = lastY - yPos; // reversed since y-coordinates range from bottom to top
lastX = xPos;
lastY = yPos;

const float sensitivity = 0.1;
xOffset *= sensitivity;
yOffset *= sensitivity;
```

Если забыть умножить смещение на `sensitivity` то мышка может слишком быстро двигать камеру.  
Далее мы прибавляем отклонение по оси  
$\textcolor{#FF0000}{X}$﻿ и $\textcolor{#01FF00}{Y}$﻿ к углам $\textcolor{#FF0000}{yaw}$﻿ и $\textcolor{#01FF00}{pitch}$﻿.

```C++
yaw   += xOffset;
pitch += yOffset;  
```

Далее нам надо навесить ограничения на значения углов, что бы пользователь не получил $\text{Gymbal Lock}$﻿ и мог нормально смотреть и вверх и вниз, но не выше 90 градусов. Для того, чтобы у камеры был полный обзор на 360 градусов - надо использовать не углы Эйлера, а кватернионы.

```C++
if (pitch > 89.0f)
{
	pitch =  89.0f;
}
if (pitch < -89.0f)
{
	pitch = -89.0f;
}
```

Но при этом мы не задали ограничений на угол $\textcolor{#FF0000}{yaw}$﻿ - тк в горизонтальном вращении мы не хотим ограничивать пользователя.

И последний этап - создаем вектор направления для нашей матрицы $LookAt$﻿:

```C++
glm::vec3 direction;
direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
direction.y = sin(glm::radians(pitch));
direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
cameraFront = glm::normalize(direction);
```

Так же что бы избежать первичного сильного рывка мыши - наложим ограничение, на первое перемещение:

```C++
if (firstMouse) // initially set to true
{
    lastX = xpos;
    lastY = ypos;
    firstMouse = false;
}
```

### Приближение/Отдаление колесиком

Так же обычно камера имеет функцию приближения и отдаления к предметам. В прошлой заметке мы довольно [[Математическа стоящая за Ортографической и Перспективной Проекцией]] поговорили про то, что угол $\text{Field of View}$﻿ или $fov$﻿ буквально определяет наш угол обзора на сцене. Когда $fov$﻿ становится меньше, проекция сцены становится меньше. Эта уменьшенная сцена проецируется на тот же самый _**NDC**_, куда проецировалась бы сцена и без изменений, данная трансформация как раз и дает нам иллюзию увеличения и уменьшения всей сцены.

```C++
fov -= (float)yOffset;
if (fov < 1.0f)
{
	fov = 1.0f;
}
if (fov > 45.0f)
{
	fov = 45.0f; 
}
```

При скролинге `yOffset` сообщает нам “величину” вертикального скролинга. При обработке ивента скролинга мыши - мы будем изменять глобальную переменную `fov`. Так как `45` это дефолтное значение для угла $fov$﻿ оставим ему диапазон работы от `1.0` до `45.0`.

Потом надо будет просто подставить это значение в _**Матрицу Проекции**_:

```C++
projection = glm::perspective(
	glm::radians(fov), 
	800.0f / 600.0f, 
	0.1f, 
	100.0f
);
```