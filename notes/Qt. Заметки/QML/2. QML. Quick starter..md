
---
#### Внешние ресурсы
1. [Книга по QML от Qt](https://www.qt.io/product/qt6/qml-book/preface-preface)
2. [Ссылка на главу в книге](https://www.qt.io/product/qt6/qml-book/ch04-qmlstart-quick-start
---

Классический подход при разработке с платформой **Qt** - это написание нагруженного десктопа, с огромной возможностью кастомизации и тд.
Настольные компьютеры ативно развиваются и десктоп приложения все еще нужны, но очень часто происходит замещение - мобильные устройства занимают все больший и больший кусок рынка. Разработка UI для мобильных же приложений сильно отличается от десктопной истории - они более упрощены, нежели настольные. Так же важная часть юзер-экспириенса включает в себя Анимации, мобильный пользовательский интерфейс должен быть живым и плавным. И вот тут традиционный подход **Qt** с Виджетами - начинает буксовать. 

---

Существует старый, как мир конфликт в разработке софта. Юзер интерфейсы слишком быстро развиваются, этот процесс происходит быстрее, чем в том же бэкенде. И очень часто заказчик хочет быстро сменить интерфейс. Причем иногда это координальные изменения. И с такими agile проектами - требуются agile подходы (весь agile - раковая опухоль).
Тут-то как раз Qt Quick и предстает во всей красе - он позволяет декларативно описывать интерфейс в виде HTML-подобного кода. Так выходит отдать UI на откуп дизайнеров, а бэк идет отдельно и так же пишется на плюсах.

---
В целом, эта заметка дает полное представление о возможностях __QML__, декларативном языке програмирования, используемом в **Qt6**. Здесь мы рассмотрим синтаксис **QML**, который выстраивается в дерево элементов, а так же пройдемся по основным уже готовым элементам. 

---
## QML Syntax
### Syntax
**QML** - это декларативный язык, используемый для описания того, как объекты относятся друг к другу.
**QtQuick** - это фреймворк, построеный на интерпретации **QML**, он создает интерфейс пользователя, и отвечает за отрисовку и взаимодействие компонентов **UI**.
В целом подход программирования применяемы в **QtQuick** - это создавать небольшие элементы, а под объединять их в компоненты побольше. Так же в **QML** можно вставить _JavaScript_ - код для расширения возможностей. Хоть на первый взгляд и может показаться, что паттерн работы с фреймворком такой же как и написание _HTML_ файла с _JavaScript_ вставками, но все же архитектура **QML** и **QtQuick** написана так, что бы описывать именно _UI_, не текстовые документы.

В своей простейшей форме **QtQuick** позволяет создавать иерархию элементов. Элементы чайлдов всегда наследуют координатную систему от родителей, и пересчет `x, y`  идет относительно пэрента.
> **QtQuick** основан на **QML**. Язык **QML** знает только об элементах, свойствах, сигналах и привязках. **QtQuick** - это фреймворк, построенный на **QML**. Используя свойства по умолчанию, иерархия элементов **QtQuick** может быть построена элегантным образом.

---
А теперь напишем самостоятельно небольшой пример:
![[scene.webp]]
Код
```js
import QtQuick

// Корренной айтем - прямоугольник
Rectangle
{
	// Говорим о том, что это коренной элемент:
	id: root

	// свойства айтема, задаются так: <name> : <value>
	width: 120
	height: 240

	// свойство цвета:
	color: "#4A4A4A"

	// Объявляем вложенный айтем (ребенок рута):
	Image
	{
		id: triangle

		// Ссылка на родителя:
		x: (parent.width - width) / 2
		y: 40

		source: 'assets/triangle_red.png'
	}

	// Ещё один вложенный айтем
	Text
	{
		// У элемента нет своего имени

		// Ссылка по айдишнику на другого чайлда:
		y: triangle.y + triangle.height + 20

		// Ссылка на рута:
		width: root.width
	
		// Проперти цвета:
		color: 'white'
		horizontalAlignment: Text.AlignHCenter
		text: 'Triangle'
	}
}
```

-  Выражение `import` добавляет новый модуль. В **Qt6** jпционально можно явно задать версию модуля `<major>.<minor>`, тк в **Qt5** это надо было делать явно. Если не добавить версию, просто будет выбираться самая новая.
- Коментарии пишутся в C стиле - `//` или `/* */`.
- Абсолютно любой **QML** файл должен иметь только один рутовый элемент, прямо как в *HTML*.
- Описание элемента ведется в скобках, сразу после определения имени.
- Один элемент может иметь доступ к другому элементу, используя его уникальный `id`.
  Хорошей практикой считается явно задавать `id: root` для рутового объекта в файле, что бы не придумывать ему имя лишний раз. 
- Елемент могут быть *вложенными*, это значит что у них есть какой-то родитель. Из чайлда до родителя можно достучаться через ключевое слово `parent`.
---
### Properties
