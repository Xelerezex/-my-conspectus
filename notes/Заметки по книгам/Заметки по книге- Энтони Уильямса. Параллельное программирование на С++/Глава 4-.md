---

В этой главе:

1. Ожидание события.
2. Ожидание однократного события с будущими результатами.
3. Ожидание с ограничением по времени.
4. Использование синхронизации операций для упрощения программы.

---

В прошлой главе было рассмотрено, как можно защитить разделяемые данные между потоками. Но иногда требуется не только защищать данные, но и _синхронизировать действия_.

К примеру: Одному потоку, что бы продолжить работу, нужно дождаться завершения другого потока.

А в общем случая задача будет выглядеть так: поток должен дождаться какого-то события или истинности какого-то условия.

---

## Ожидание события или иного условия.

Самая частая ситуация, когда потоку нужно ждать, когда выполнится какое-то условие в другом потоке.

Напишем наивную модель этой проблемы, через флаг.

```C++
bool flag;
std::mutex m;

void wait_for_flag()
{
		std::unique_lock<std::mutex> lock(m);   // Захватываем мьютекс
		
		while (!flag)
		{
				lock.unlock();                      // Отпускаем мьютекс и спим 100 мс
				std::this_thread::sleep_for(std::chrono::milliseconds(100));
				lock.lock();                        // Снова захватываем мьютекс
		}	
}
```

Предполагается, что мьютекс здесь глобальный, и он общий для нескольких потоков.

Такая реализация неплоха тем, что когда поток спит - не расходуется процессорное время.

Но тут тоже есть узкие места, к примеру, невозможно правильно выбрать сколько нужно будет спать потоку: поспит слишком мало - все было в пустую (пустые дополнительные проверки), если поспит слишком много - может упустить момент (ненужная задержка).

Самый простой механизм, для решения установленной выше, задачи - использование _условных переменных_. Концептуально, _условная переменная_ ассоциирована с каким-то событием или условием, причем один или несколько потоков могут ждать, когда это условие окажется выполненным.

---

### Ожидание условия с помощью условных переменных:

В стандартной библиотеке C++ существует две реализации условных переменных:

1. _std::condition_variable_ - данный класс работает только с _std::mutex_.
2. _std::condition_variable_any_- данный класс работает с любым “мьютексноподобным” классом, отсюда и суффикс __any_. Так как этот класс более общий - использование его может быть дороже в плане памяти и ресурсов системы.

```C++
std::mutex mut;
std::queue<data_chunk> data_queue;                      // [1]
std::condition_variable data_cond;

void data_preparation_thread()
{
    while (more_data_to_prepare())
    {
        const data_chunk data = prepare_data();
        std::lock_guard<std::mutex> lock(mut);
        data_queue.push(data);                           // [2]
        data_cond.notify_one();                          // [3]
    }
}

void data_processing_thread()
{
    while(true)
    {
        std::unique_lock<std::mutex> lock(mut);          // [4]
        data_cond.wait(
            lock,
            [] { return !data_queue.empty(); }           // [5]
        );
        data_chunk data = data_queue.front();
        data_queue.pop();
        lock.unlock();                                   // [6]
        process(data);
        if (is_last_chunk(data))
        {
            break;
        }
    }
}
```

1. Очередь, которая служит для передачи данных между двумя потоками.
2. Здесь данные записываются в общую очередь.
3. Функция _notify_one()_ нужна, что бы известить ожидающий поток (если такой существует), что данные в общей очереди. Данная функция находится в “генерирующем потоке”.
4. Данная функция находится в “принимающем потоке”. Здесь захватывается мьютекс, для того, что бы можно было обработать данные в новом потоке.
5. В “принимающем потоке” происходит вызов функции _wait()_, которая будет ждать уведомления от условной переменной, что бы начать исполнять какую-то логику. В функции _wait()_ два аргумента - первый это мьютекс, а второй - это условие остановки.
6. Здесь мьютекс освобождается, так как мы помним правило, что держать мьютекс дольше, чем требуется - не стоит.

Работает _wait()_ следующим образом - если условие в лямбде возвращает _false_ - она отпускает мьютекс и просто ждет _true_ в условии. Потом в другом потоке происходит _notify_one()_ - спящий поток пробуждается, захватывает мьютекс и еще раз проверяет условие на всякий случай. Если условие выполнено - управление возвращается, а если же оно не выполнено - мьютекс захватывается обратно и поток снова засыпает. Собственно поэтому мы используем _std::unique_lock_, а не _std::lock_guard_.

---

### Потокобезопасная очередь на базе условных переменных:

Для начала рассмотрим интерфейс классического класса _std::queue_ библиотеки STL. И если не обращать внимания на конструирование, присваивание или обмен, то остаются три группы операций:

1. Опрос состояния очереди, в целом: _emty()_, _size()_.
2. Опрос элементов очереди: _front()_, _back()_.
3. Модификация очереди: _push()_, _pop()_, _emplace()_.

Тут, ровно так же к и в стеке ранее, при обмене данных между потоками в очереди будет происходить гонка.

Здесь так же надо будет объединить _pop()_ и _top()_ в одну функцию.

Так же стоит учесть один нюанс, очередь может использоваться для передачи данных между потоками, поэтому поток-получатель часто будет ожидать поступления данных. Поэтому включим два варианта _pop()_:

1. _try_pop()_ - попытается извлечь значение из очереди, но сразу возвратит управление (с указанием ошибки), если в очереди ничего не было.
2. _wait_and_pop()_ - не будет возвращать управление, пока не дождется своих данных.

Интерфейс очереди будет выглядеть следующим образом:

```C++
\#include <memory>

template <typename T>
class threadsafe_queue
{
public:
		treadsafe_queue();
		treadsafe_queue(const treadsafe_queue&);
		treadsafe_queue& operator=(const treadsafe_queue&) = delete;

		void push(T new_value);

		bool try_pop(T& value);                 // [1]
		std::shared_ptr<T> try_pop();           // [2]

		void wait_and_pop(T& value);
		std::shared_ptr<T> wait_and_pop();

		bool empty() const;
};
```

1. Первый вариант _try_pop()_ сохраняет извлеченное значение в переданной по ссылке переменной, а возвращаемое значение использует для индикации ошибки: _true_ - если значение получено, _false_ - в противном случае.
2. Во втором варианте возвращаемые данные - это данные извлеченные из очереди.

Полная реализация потокобезопасной очереди

```C++
template <typename T>
class threadsafe_queue
{
public:
        threadsafe_queue()
        {
        }

        threadsafe_queue(const threadsafe_queue& other)
        {
            std::lock_guard<std::mutex> lock(other.internal_mutex);
            data_queue = other.data_queue;
        }

        threadsafe_queue& operator=(const threadsafe_queue&) = delete;

        void push(T new_value)
        {
            std::lock_guard<std::mutex> lock(internal_mutex);
            data_queue.push(new_value);
            data_cond.notify_one();
        }
        
        bool try_pop(T& value)
        {
            std::lock_guard<std::mutex> lock(internal_mutex);
            if (data_queue.empty())
            {
                return false;
            }
            value = data_queue.front();
            data_queue.pop();
            return true;
        }

        std::shared_ptr<T> try_pop()
        {
            std::lock_guard<std::mutex> lock(internal_mutex);
            if (data_queue.empty())
            {
                return std::shared_ptr<T>{};
            }
            std::shared_ptr<T> result(std::make_shared<T>(data_queue.front()));
            data_queue.pop();
            return result;
        }

        void wait_and_pop(T& value)
        {
            std::unique_lock<std::mutex> lock(internal_mutex);
            data_cond.wait(lock, [this] { return !data_queue.empty(); });
            value = data_queue.front();
            data_queue.pop();
        }

        std::shared_ptr<T> wait_and_pop()
        {
            std::unique_lock<std::mutex> lock(internal_mutex);
            data_cond.wait(lock, [this]{ return !data_queue.empty(); });
            std::shared_ptr<T> result(std::make_shared<T>(data_queue.front()));
            data_queue.pop();
            return result;
        }

        bool empty() const
        {
            std::lock_guard<std::mutex> lock(internal_mutex);
            return data_queue.empty();
        }

private:
        mutable std::mutex internal_mutex;
        std::queue<T> data_queue;
        std::condition_variable data_cond;
};
```

Стоит помнить такую вещь, про функцию _notify_one()_, что когда эту условную переменную ждут несколько потоков после вызова нотификации - не ясно какой именно поток будет продолжать работу. Так же есть функция _notify_all()_ - она будет извещать все потоки, которые ждут ее.

---

## Ожидание одноразовых событий с помощью механизма будущих результатов.

Есть случаи, когда дождаться данных от другого потока надо только единожды (а не при каждом исполнении какого-то условия, как с условными переменными). В особенности относится к условию - доступности каких-то данных. Для таких случаев используются - _будущие результаты_ (_future_).

Для таких будущих результатов существует два шаблона:

1. _std::future<>_ - уникальный будущий результат. Один экземляр может ссылаться только на одно событие.
2. _std::shared_future<>_ - разделяемые будущие результаты. Несколько экземпляров могут ссылать на одно событие.

Эти классы устроены по образцу _std::unique_ptr_ и _std::shared_ptr_.

Если ассоциированных данных нет, то стоит использовать _std::future<void>_ и _std::shared_future<void>_ шаблоны.

---

### Возврат значения из фоновой задачи.

Классическая ситуация - начать какое-то тяжелое вычисление, от которого не сильно зависит критическая работа программы (выходных данных можно и подождать и это не критично).

Для фоновой _асинхронной задачи_, можно использовать функцию _std::async_, которая вернет объект типа _std::future_, который будет хранить значение, появившееся после полной отработки задачи. Когда основной программе понадобится значения, хранящиеся в _std::future_ надо будет вызвать метод _get()_ - тогда поток приостановит свою работу, пока не получит значение.

```C++
\#include <future>
\#include <iostream>

int find_the_answer_to_ltuae();
void do_other_stuff();

int main()
{
		std::future<int> the_answer = std::async(find_the_answer_to_ltuae);
		do_other_stuff();
		std::cout << "Answer: " << the_answer.get() << std::endl;
}
```

В std::async можно передавать аргументы ровно так же, как и в std::thread, все правила работают аналогично.

```C++
\#include <string>
\#include <future>

struct X
{
    void foo (int, const std::string&) {}
    std::string bar (const std::string&) {}
};

X x;
auto f1 = std::async(&X::foo, &x, 42, "hello");            // [1]
auto f2 = std::async(&X::bar, &x, "hello");                // [2]

struct Y
{
    double operator()(double) {}
};

Y y;
auto f3 = std::async(Y(), 3.141);                          // [3]
auto f4 = std::async(std::ref(y), 2.718);                  // [4]

X baz(X&) {}
auto f6 = std::async(baz, std::ref(x));                    // [5]

class move_only
{
public:
    move_only() {}
    move_only(move_only&&) {}
    move_only(const move_only&) = delete;
    move_only& operator=(move_only&&) {}
    move_only& operator=(const move_only&) = delete;

    void operator()() {}
};

auto f5 = std::async(move_only{});                         // [6]
```

1. Вызывается _p→foo(42, “hello”)_, где _p_ это _&x_.
2. Вызывается _tmpx.bar(”goodbye”)_, где _tmpx_ - копия _x_.
3. Вызывается _tmpy(3.141)_, где _tmpy_ создается из _Y_ перемещающим конструктором.
4. Вызывается _y(2.718)_.
5. Вызывается _baz(x)_.
6. Вызывается _tmp()_, где _tmp_ конструируется с помощью _std::move(move_only())_.

Так же стоит помнить, что первый параметр функции std::async - это тип отработки этой функции:

- _std::launch::async_ - выполнять функцию в новом потоке.
- _std::launch::deferred_ - выполнять при вызове _wait()_, _get()_ (данные функции вызываются от возвращаемого _std::async_ объекта _std::future_).

---

### Ассоциирование задачи с будущим результатом:

Шаблон класса _std::packaged_task<>_ связывает будущий результат с функцией или объектом, допускающим вызов.

При вызове объекта типа _std::packaged_task<>_, ассоциированная с ним функция или допускающий вызов объект вызывается и делает _будующий результат_ **готовым**, сохраняя возвращенное значение в виде ассоциированных данных.

Параметром для шаблона является сигнатура функции.

Опрределение частичной специализации шаблона _std::packaged_task<>_ будет выглядеть следующим образом:

```C++
\#include <string>
\#include <vector>
\#include <future>

class packaged_task<std::string(std::vector<char>*, int)>// Тип возвращаемого 
{                                                        // значения - std::string
public:                                                  // определяет тип future
		template<typename Callable>
		explicit packaged_task(Callable&& f);

		std::future<std::string> get_future();
		void operator() (std::vector<char>*, int);
};
```

Следовательно _std::packaged_task_ - допускающий вызов объект, и, значит его без каких-либо проблем можно обернуть объектом _std::function_, после этого передать в _std::thread_ в качестве функции потока.

---

### Передача задач между потоками:

Во многих каркасах пользовательского итерфейса требуется, чтобы интерфейс обновлялся только в специально выделенных потоках. Если какому-то другому потоку потребуется обновить интерфейс, то он должен послать сообщение одному из таких выделенных потоков, что бы тот выполнил операцию.

Другими словами, _std::packaged_task_, это смесь объекта _std::future_, который вернется после отработки функции и этой самой функции.

Выполнение кода в потоке пользовательского интерфейса с применением _std::packaged_task_:

```C++
std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

void gui_thread()                                       // [1]
{
    while(!gui_shutdown_message_received())             // [2]
    {
        get_and_process_gui_message();                  // [3]
        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lk(m);
            if(tasks.empty())                           // [4]
						{
                continue;
            }
						task=std::move(tasks.front());              // [5]
            tasks.pop_front();
        }
        task();                                         // [6]
    }
}

std::thread gui_bg_thread(gui_thread);

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);                 // [7]
    std::future<void> res = task.get_future();          // [8]
    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));                   // [9]
    return res;                                         // [10]
}
```

1. Поток пользовательского интерфейса.
2. Место, где должно быть получено сообщение о завершении работы.
3. Проверка на каждой итерации - пришло ли сообщение от _GUI_ (события мыши, или новые задачи в очереди).
4. Если новых задач не завезли - возвращаемся в начало цикла.
5. Если новые задачи появились - извлекаем задачу из очереди под защитой мьютекса.
6. На этом этапе мьютекс отпустится, и задача исполнится. Как только она будет готова - так же будет готов и ассоциированный с ней будущий результат.
7. Здесь начинается перемешение задачи в очередь. Создается новая упакованная задача.
8. Получается результат отработки этой задачи при помощи функции _get_future()_.
9. Задача перемещается в глобальную очередь.
10. Задача переместилась в пункте [9] до того как стал доступен _будущий результат_.

То есть ключевая идея в шаблоне _std::packaged_task_ состоит в том, что есть некая задача, которая может быть представлена как функция (она так же принимает какие-то входные аргументы) и после отработки этой функции, сразу можно получить объект типа _std::future_.

---

### Использование std::promise:

Шаблоне _std::packaged_task_ используется, когда задачу можно выразить в виде простой функции, которая отдает нам результат отработки.

Но если вдруг результат должен прийти из нескольких мест или же не выйдет задать задачу как простую функцию, нужно использовать шаблон - `_std::promise_`.