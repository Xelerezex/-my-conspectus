---

В этой главе:

- Проблемы разделения данных между потоками.
- Защита данных с помощью мьютексов.
- Альтернативные средства защиты разделяемых данных.

---

## Проблема разделения данных между потоками.

Если потоки разделяют какие-то совместные данные, то необходимы правила, регулирующие какой поток в какой момент к каким данным может обращаться и как сообщить об изменениях другим потокам, использующим те же данные.

Если разделяемые данные только читаются, то обычно никаких сложностей не возникает, поскольку любой поток может читать данные независимо от того, читают ли их в то же самое время другие потоки или нет.

---

_Инвариант_ - утверждение о структуре данных, которое всегда должно быть истинно. Другими словами - инвариант - набор условий, при которых объект имеет смысл.

Пример: “значение этой переменной равно числу элементов в списке”, то есть количество элементов в списке может меняться, но при этом неизменно то, что переменная хранит именно количество элементов, так как это имеет смысл для структуры.

Введя понятие инварианта, при параллельном программировании стоит понимать, что самые частые ошибки с разделенными данными происходят именно тогда, когда в процессе обновления инвариант нарушается.

---

Сформулируем репрезентативный пример инварианта.

Он будет, в нашем случая звучать так:

```C++
Есть двусвязный список, в котором каждый узел содержит два указателя, 
один указатель на следующий узел, второй указатель на предыдуший узел.

Это есть инвариант двусвязного списка.

Так же можно более формально определить этот инвариант:
Если "указатель на следующий" в узле А указывает на узел В,
то "указатель на предыдуший" в узле В указывает на узел А.
```

_Задача:_ Нам надо удалить элемент в центре двусвязного списка.

Шаги, которые нам надо предпринять, для удаления элемента посредине:

1. Нужно найти элемент, который мы хотим удалить. Назовем этот элемент _N_.
    
    ![[invariant-linked-list-a.png]]
    
    Рисунок 1. Схематичное изображение связного списка.
    
2. Изменить “указатель на следующий” в узле, который идет перед _N_, так, что бы он указывал на узел, следующий за _N_.
    
    ![[invariant-linked-list-b.png]]
    
    Рисунок 2. Удаление указателя указывающего на удаляемый элемент, из предыдущего узла.
    
3. Изменить “указатель на предыдущий” в узле, следующем за _N_, так чтобы он указывал на узел, предшествующий _N_.
    
    ![[invariant-linked-list-c.png]]
    
    Рисунок 3. Удаление указателя указывающего на удаляемый элемент, из последующего узла.
    
4. Удалить узел _N_.
    
    ![[invariant-linked-list-d.png]]
    
    Рисунок 4. Удаление нужного элемента.
    

На шаге 2 и 3, нарушается, наш, определенный выше, инвариант. Но на шаге 4 инвариант восстанавливается. То есть в этом, конкретном, случае нарушение инварианта необходимо, но оно обратимо.

Простейшая проблема, которая может возникнуть при обращении к такому двусвязному списку из нескольких потоков - необратимое нарушение инварианта.

К примеру, когда один поток читает такой список, а второй поток удаляет элемент N, вполне может произойти, что-то типа читающий поток увидит список, из которого узел удален лишь частично, или просто они будут производить операции одновременно и произойдет повреждение структуры данных и приложение упадет. Может быть, что угодно, но в любом случае - инвариант нарушается необратимо.

Причины ошибки такого плана называются: _состоянием гонки_.

---

## Способы устранения состояний гонки.

### 1. Первый способ:

Заключается в том, что бы снабдить структуру данных некими защитными механизмами, которые гарантируют, что только поток, выполняющий модификацию может видеть промежуточные модификации, в которых инварианты нарушены. С точки зрения всех остальных потоков, обращающихся к этой же структуре данных, модификация либо еще не началась, либо уже завершилась.

### 2. Второй способ:

Изменить дизайн структуры данных и ее инварианты, так что бы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Это также называют программирование без блокировок (способ lock-free programming). Это довольно сложный для реализации способ, нужно многое учитывать: модель памяти, какие потоки будут видеть данные и так далее.

### 3. Третий способ

Рассматривать изменение структуры данных как транзакцию, то похожим образом, как обрабатываются транзакциями изменения в базах данных. Требуемая последовательность изменений и чтений данных сохраняется в журнале транзакций, а затем атомарно фиксируется. Если транзакция невозможна, так как сейчас происходит модификация другим потоком - транзакция перезапускается. Это решение называется программной транзакционной памятью (Software Transactional Memory - STM), в настоящее время в этой области ведутся активные исследования. Но поддержки в C++ пока нет.

---

## Защита разделяемых данных с помощью мьютекса.

_Мьютекс_ (Mutual Exclusion) - примитив синхронизации, который помечает участок кода, к которому потенциально может обратиться несколько потоков, и разрешает выполнять этот участок кода только одному потоку в данную единицу времени.

Библиотека _Thread Library_ гарантирует, что если один поток уже захватил некоторый мьютекс, то все остальные потоки, пытающиеся захватить тот же мьютекс, будут вынуждены ждать, пока самый быстрый (первый поток) не отпустит его.

Для конструирования объекта мьютекса, нужно сконструировать объект типа _std::mutex_. Для захвата мьютекса служит метод _lock()_, а для освобождения - _unlock()_.

Но вызов метода _unlock()_ любит теряться и забываться программистами, поэтому лучше всего использовать RAII-обертку _std::lock_guard_.

```C++
\#include <list>
\#include <mutex>
\#include <algorithm>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);      // [1]
    some_list.push_back(new_value);
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);       // [2]
    return std::find(some_list.begin(), some_list.end(), value_to_find) 
					 != some_list.end();
}
```

[1] и [2] являются, по сути, взаимоисключающими - так как, если один поток будет вызывать _add_to_list_, а второй _list_contains_ то сами тела функций будут исполнятся только одно исполнение в одну единицу времени, и никогда одновременно. То есть _list_contains_ никогда не увидит _add_to_list_ в промежуточном состояние (то есть с нарушенным временно инвариантом).

- Замечание!
    
    Стоит заметить, что std::mutex может защитить какие-то скрытые, например инкапсулированные данные, внутри класса. В какой-то отдельно взятой функции операции над данными защищенные мьютексом будут в безопасности от использования двумя потоками одновременно. **Но если вернуть где-то указатель** на эти данные то мьютекс уже не будет гарантировать никакой безопасности, так как по указателю можно будет вертеть этими данными как захочется.
    

### Структурирование кода для защиты разделяемых данных.

Не достаточно просто воткнуть в коде _std::lock_guard_ в каждую функцию-член: один единственный отбившийся указатель или ссылка сводит всю защиту на нет.

Не достаточно просто отслеживать - возвращаем ли мы ссылку или указатель из какого-то метода на защищенные данные. Надо еще следить за тем, что бы такие данные не передавались во **входные** параметры какого-то метода.

```C++
class some_data
{
    int a;
    std::string b;
public:
    void do_something()
    {
    }
};

class data_wrapper
{
private:
    some_data m_data;
    std::mutex m_mutex;

public:
    template<typename Function>
    void process_data(Function func)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        func(m_data);                                // [1]
    }
};

some_data* unprotected;

void malicious_function(some_data& protected_data)
{
    unprotected = &protected_data;
}

data_wrapper x;

void foo()
{
    x.process_data(malicious_function);             // [2]
    unprotected->do_something();                    // [3]
}
```

1. Здесь мы передаем защищенные данные пользовательской функции.
2. Передаем вредоносную функцию.
3. Доступ к защищенным данным в обход защиты.

Итог в этом примере следующий: очень важно быть аккуратным с тем, что передает пользователь в наши функции.

И очень хорошо помнить правило, при защите данных мьютексами:

**Не передавайте указатели и ссылки на защищенные данные за пределы области видимости блокировки никаким способом, будь то возврат из функции, сохранение в видимой извне памяти или передача в виде аргумента пользовательской функции.**

---

## Выявление состояний гонки, внутренне присущим интерфейсам.

Рассмотри структуру данных для реализации стека:

```C++
template<typename T, typename Container = std::deque<T>>
class stack
{
public:
		explicit stack(const Container&);                              // [1]
		explicit stack(Container&& = Container());                     // [2]
		template <class Alloc> explicit stack(const Alloc&);           // [3]
		template <class Alloc> stack(const Container&, const Alloc&);  // [4]
		template <class Alloc> stack(Container&&, const Alloc&);       // [5]
		template <class Alloc> stack(stack&&, const Alloc&);           // [6]
		bool empty() const;                                            // [7]
		size_t size() const;                                           // [8]
		T& top();                                                      // [9]
		T const& top() const;                                          // [10]
		void push(T const&);                                           // [11]
		void push(T&&);                                                // [12]
		void pop();                                                    // [13]
		void swap(stack&&);                                            // [14]
};
```

Не считая конструкторов [1 - 6] и функции _swap()_ [14], имеется еще пять операций со стеком:

1. _push()_ [11 - 12] - заталкивает в стек новый элемент.
2. _pop()_ [13] - выталкивает элемент из стека.
3. _top()_ [9 - 10] - возвращает элемент, находящийся на вершине стека.
4. _empty()_ [7] - проверяет пуст ли стек.
5. _size()_ [8] - возвращает размер стека.

### Описание первой проблемы:

Если даже изменить функцию _top()_, так что бы она возвращала не ссылку на элемент стека, а копию. То интерфейс все еще уязвим для гонки. И проблема даже не в реализации на основе мьютексов, она присуща самому интерфейсу. **На результаты возвращаемые** **_empty()_****,** **_size()_** **нельзя полагаться**. В момент вызова одним потоком они может быть и будут правильные, но в этот же момент может идти запись в стек, и возвращаемое значение уже неликвидно.

Следующий пример, это классическое взаимодействие со стеком.

```C++
stack<int> s;
if (!s.empty())
{
		int const value = s.top();
		s.pop();
		do_something(value);
}
```

В однопоточном коде - такая проверка перед вызовом _top()_ прямая необходимость, т.к. стек, при вызове _top()_ и пустом контейнере может выкинуть UB.

А вот уже в многопоточной программе - один поток делает эту проверку, ровно как другой, в это же время вызывает _pop()_, так и получается состояние гонки - либо проверка пройдет, либо нет, никто не знает.

Причем использование внутреннего мьютекса не особо поможет, это проблема именно дизайна интерфейса.

### Описание второй проблемы:

Еще одна потенциальная гонка возникает между вызовами _top()_ и _pop()._

Представим следующую ситуацию: есть два потока, которые ссылаются на объект _s_ типа _stack_, а в самом контейнере стека находится два элемента.

Далее предполагаем, что стек защищен внутренним мьютексом, значит в каждый момент времени лишь один поток может исполнять любой метод.

Выглядеть это будет так:

![[two-threads-stack.png]]

Работа стека при двух потоках, когда один внутренний мьютекс (аналог примера кода выше, но для многопоточности).

Проблема здесь в том, что между двумя обращениями к _top()_ никто не может модифицировать стек, так что оба потока увидят одно и то же значение. Так же между двумя обращениями к _pop()_, нет обращения к _top()_, значит одно из двух хранившихся в стеке значений никто даже не прочитает, оно будет отброшено, а другое наоборот - обработано дважды.

### Варианты решения проблем и написание потокобезопасного стека.

**Вариант 1. Передавать ссылку:**

Передать функции _pop()_ ссылку на переменную, в которую она должна переместить вытолкнутое из стека значение:

```C++
std::vector<int> result;
some_stack.pop(result);
```

В этом способе есть недостаток, программа должна до обращения к _pop()_ должна создать объект такого же типа как и у _some_stack_, что бы передать его как аргумент, и для некоторых типов это может быть очень дорого в плане времени и потребления ресурсов.

**Вариант 2. Потребовать наличия копирующего конструктора, не возбуждающего исключений, или перемещающего конструктора:**

Проблема с безопасностью относительно исключений в pop(), которая возвращает значения, проявляется тогда, когда исключения могут возникать в процессе возврата значения.

Отсюда вырисовывается следующее решение: Наложить на потокобезопасный стек ограничение - в нем можно хранить только типы, поддерживающие возврат по значению без возбуждения исключений.

Тут сразу есть минус, что этот вариант слишком ограничивающий. Хотя и на этапе компиляции можно узнать существует ли у типа копирующий или перемещающий конструктор:

```C++
std::is_nothrow_copy_constructible
std::is_nothrow_move_constructible
```

**Вариант 3. Возвращать указатель на вытолкнутый элемент:**

Можно возвращать не копию вытолкнутого элемента по значению, а указатель на него. Достоинство этого метода в том, что копирование указателей не вызывает исключений.

А недостаток, в том, что надо искать средства управления выделенной памятью объекта. Для супер легких типов, к примеру _int_, выделение динамической памяти будет затратнее копирования.

**Вариант 4. Просто реализовать сразу и первый, и второй, и третий вариант:**

Просто сразу реализовать все возможные варианты.

### Пример потокобезопасного стека.

```C++
\#include <exception>
\#include <stack>
\#include <mutex>
\#include <memory>

struct empty_stack : std::exception
{
        const char* what() const throw()
        {
                return "empty stack";
        }
};

template <typename T>
class threadsafe_stack
{
private:
    std::stack<T> data;
    mutable std::mutex m;

public:
    threadsafe_stack()
    {}
    threadsafe_stack(const threadsafe_stack& other)
    {
        std::lock_guard<std::mutex> lock(other.m);
        data = other.data;
    }
    threadsafe_stack& operator=(const threadsafe_stack&) = delete;

    void push(T new_value)
    {
        std::lock_guard<std::mutex> lock(m);
        data.push(new_value);
    }

    std::shared_ptr<T> pop()
    {
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
        {
            throw empty_stack();
        }
        const std::shared_ptr<T> res(std::make_shared<T>(data.top()));
        data.pop();
        return res;
    }

    void pop(T& value)
    {
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
        {
            throw empty_stack();
        }
        value = data.top();
        data.pop();
    }

    bool empty() const
    {
        std::lock_guard<std::mutex> lock(m);
        return data.empty();
    }
};

int main()
{
    threadsafe_stack<int> si;
    si.push(5);
    si.pop();
    if(!si.empty())
    {
        int x;
        si.pop(x);
    }
}
```

Эта реализация даже допускает копирование - так как в конструкторе мы располагаем мьютекс. Отметим, что само копирование происходит в теле функции, а не в списке инициализации. Поэтому вариант с мьютексом и работает.

Проблемы с производительностью так же могут возникнуть из-за очень большой или очень малой гранулярности блокировки - крайнее проявление это один глобальный мьютекс для всего, чем шире область применения одного мьютекса - тем больше код скатывается в обычный однопоточный вариант по производительности. Важно разбивать программу на разные мьютексы.

---

## Взаимоблокировка: проблема и решение.

Взаимоблокировка - это когда, два потока для выполнения некоторой операции должны захватить два мьютекса, но случилось так, что каждый поток захватил только один мьютекс и ждет другого. И в итоге каждый поток ждет другого, что бы он освободил мьютекс.

Общая рекомендация как избавиться от взаимоблокировок - соблюдать четкую последовательность в захвате мьютексов.

Пример:

```C++
class X
{
private:
    some_big_object some_detail;
    mutable std::mutex m;

public:
    X(some_big_object const& sd)
        : some_detail(sd)
    {}

    friend void swap (X& lhs, X& rhs);
};

void swap (X& lhs, X& rhs)
{
    if (&lhs == &rhs) return;                                    // [1]

    std::lock(lhs.m, rhs.m);                                     // [2]

    std::lock_guard<std::mutex> lock_a(lhs.m, std::adopt_lock);  // [3]
    std::lock_guard<std::mutex> lock_b(rhs.m, std::adopt_lock);  // [4]

    swap(lhs.some_detail, rhs.some_detail);
}

int swapper()
{
    X first(some_big_object{17});
    X second(some_big_object{38});

    std::thread thread_one(swap, std::ref(second), std::ref(first));
    std::thread second_two(swap, std::ref(first),  std::ref(second));
}
```

- ADL это:
    
    [[notes/interview-questions-shared/questions/C++. Что такое Name Lookup/C++. Что такое ADL|C++. Что такое ADL]]
    

В коде ⬆️ , концептуально, происходит следующая вещь.

1. Создается поток _one_ в нем вызывается мьютекс _second.m_ (действие 1), затем вызывается мьютекс _first.m_ (действие 2).
2. Потом создается поток _two_, в нем вызывается мьютекс _first.m_ (действие 3), затем мьютекс _second.m_ (действие 4).

Таким образом нарушается порядок захвата мьютексов. Потому что в потоке one происходит действие 1, потом происходит действие 2. В это же время в потоке two после действия 1, действие 4 не может произойти, потому что мьютекс _second.m_ уже захвачен, и второй поток ждет, когда первый отпустит этот мьютекс (и по аналогии с действиями 2 и 3) то и происходит дедлок.

Теперь немного опишем формально код из примера:

1. Проверка, что бы были разные объекты. Потому что при захвате одного и того же мьютекса (например _second.m_) дважды подряд - приведет к неопределенному поведению.
2. _std::lock_ - функция из стандартной библиотеки, созданная для предотвращения дедлоков, и возможности захвата сразу нескольких мьютексов.
3. В этом пункте, мы отдаем владение мьютексом объекту _std::lock_guard_ (для того, что бы при выходе из области видимости или исключении точно вызвался _unlock()_), но так как мьютекс уже захвачен единожды в этом коде функцией _std::lock_, мы передаем параметр _std::adopt_lock_, который говорит объекту _std::lock_guard_, что передаваемый в конструктор мьютекс захватывать больше не нужно. Нужно только забрать владение им.
4. Ровно то же самое, что и в пункте 3.

- **Замечание по поводу std::lock!**
    
    Если в _std::lock(first_mutex, second_mutex); first_mutex_ - нормально захватился, без исключений, а при захвате second_mutex произошло исключени - захват _first_mutex_ будет анулирован и первый мьютекс будет отпущен.
    
    Но хоть _std::lock_ и помогает от взаимных блокировок, если мьютексы захвачены порознь, и не через функцию _std::lock_ - спасет только порядок их захвата.
    

Взаимоблокировка так же может выйти, в случае, когда один поток может ждать завершения другого. То есть, блокировка при вызове _join()_.

---

### Дополнительные советы по устранению взаимных блокировок.

Советы по устранению потенциальных взаимных блокировок:

1. ==**Избегайте вложенных блокировок:**==
    
    Тут идея проста - не захватывайте второй мьютекс, если уже какой-то мьютекс был захвачен. Если же ну прям очень захотелось захватить сразу два или более мьютексов - делайте это атомарно, при помощи _std::lock_.
    
2. **==Старайтесь не вызывать пользовательский код, когда удерживаете мьютекс:==**
    
    Код, написанный пользователем потенциально внутри себя может захватывать какой-то мьютекс, и мы не можем знать - делает ли он это, или нет. Соответственно, отсюда совет: при вызове пользовательского кода, предварительно освободите захваченный мьютекс. Просто захватив самостоятельно мьютекс из нашего кода, и мьютекс из пользовательского - без проблем может произойти взаимоблокировка. (Но этот вариант не всегда будет работать, просто хорошо бы знать про него).
    
3. ==**Захватывайте мьютексы в фиксированном порядке:**==
    
    Если без захвата нескольких мьютексов никак не обойтись (как с пользовательским кодом), и захватить их с помощью одной операции, типа _std::lock_ не выходит, то нужно - захватить их во всех потоках в одном и том же порядке. Идея в том, что бы четко определить порядок вызова мьютексов, и строго следовать ему в каждом потоке.
    
4. ==**Пользуйтесь иерархией блокировок:**==
    
    Ключевая идея в том, что бы разбить все приложение на “слои” и выявить все мьютексы, которые могут быть захвачены в каждом слое. Программе будет отказано в захвате мьютекса, если вдруг она уже захватила его в этом слое. Для проверки во времени выполнения, надо приписать каждому мьютексу номер слоя и вести их учет.
    
    Нужно это для того, что бы программа в один момент времени удерживала, только один мьютекс, одного слоя и не больше.
    
    И так как, иерархический мьютекс не описан в стандартной библиотеке _STL_, на практике он будет вызываться по средствам _std::lock_guard<>()_, а для этого надо определить внутри класса три функции: _lock()_, _unlock()_, _try_lock()_.
    
    - **Замечание!**
        
        Мы пока не видели на примере как работает _try_lock()_, но в ней нет ничего хитрого - при её вызове, если мьютекс уже захвачен, вернется значение _false_, и соответственно, если мьютекс свободен - он захватится и вернет _true_.
        
    
    ```C++
    class hierarchical_mutex
    {
    public:
        explicit hierarchical_mutex(unsigned long value)
            : hierarchy_value{value}
            , previous_hierarchy_value{0}
        {}
    
        void lock()
        {
            check_for_hierarchy_violation();
            internal_mutex.lock();                                       // [4]
            update_hierarchy_value();                                    // [5]
    
        }
    
        void unlock()
        {
            this_thread_hierarchy_value = previous_hierarchy_value;      // [6]
            internal_mutex.unlock();
        }
    
        bool try_lock()
        {
            check_for_hierarchy_violation();
            if (!internal_mutex.try_lock())                              // [7]
            {
                return false;
            }
            update_hierarchy_value();
            return true;
        }
    
    private:
        void check_for_hierarchy_violation()
        {
            if (this_thread_hierarchy_value <= hierarchy_value)           // [2]
            {
                throw std::logic_error("mutex hierarchy violated");
            }
        }
    
        void update_hierarchy_value()
        {
            previous_hierarchy_value    = this_thread_hierarchy_value;    // [3]
            this_thread_hierarchy_value = hierarchy_value;
        }
    
    private:
        std::mutex internal_mutex;
        const unsigned long hierarchy_value;
        unsigned previous_hierarchy_value;
        static thread_local unsigned long this_thread_hierarchy_value;    // [1]
    };
    
    thread_local unsigned long hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);                                                               // [8]
    ```
    
    - **Сноска: Поточно-локальная переменная:**
        
        Поточно-локальные переменные имеют тип _thread_local_ и у них имеется отдельный экземпляр в каждом потоке программы. Говорят, что они имеют потоковое время жизни (thread storage duration). Создается только после того, как создан поток, в которой находится эта переменная.
        
        ```C++
        thread_local int x; // Поточно-локальная переменная в области видимости
        										// пространства имен
        class X
        {
        		static thread_local std::string s; // Поточно-локальная статическая 
        };                                     // переменная-член класса
        static thread_local std::string X::s; // Необходимо обязательно определение
                                              // X::s
        void foo()
        {
        		thread_local std::vector<int> v;  // Поточно-локальная лоакльная 
        }                                     // переменная
        ```
        
        Состояние этой переменной не зависит от состояния этой переменной в другом потоке.
        
    
    1. Для грамотного предоставления уровня иерархий в текущем потоке используется поточно-локальная переменная типа _thread_local_.
    2. Так как _this_thread_hierarchy_value_ имеет значение _ULONG_MAX_ (а они по дефолту самое большое), проверка при конструировании первого мьютекса проходит.
    3. Сохраняем предыдуший уровень иерархии только, когда удерживаем _internal_mutex_.
    4. Тут происходит обычное захватывание внутреннего мьютекса.
    5. Когда мьютекс успешно захвачен - можно изменять внутреннее значение уровня иерархии. Теперь если захватить другой мьютекс _hierarchical_mutex_ то предыдуший уровень иерархии сохранится, и проверка пройдет, только если новый уровень меньше прошлого.
    6. Тут сохраняем предыдушее значение иерархии. Сделано для того, что б можно было захватить мьютекс большей иерархии, после того как осуществили _unlock()_ для текущего мьютекса.
    7. _try_lock_ работает ровнго так же как и в _std::mutex_.
    8. Поточно-локальная переменная типа _unsigned long_, инициализуется максимально возможным для типа значением, при помощи макроса.
    
    Вообще, хоть и не всегда имеет смысл реализовывать класс иерархической блокировки. Но мысленно отделять работу мьютексов от работы логики приложений - это полезное мысленное упражнение.
    
5. ==**Применение данных рекомендаций не ограничевается блокировками:**==
    
    По хорошему, стоит помнить вышеприведенные правила, для всех конструкций синхронизации. К примеру, если мы планируем ждать завершения потока, имеет смысл сделать иерархию потоков и так далее.
    

---

### Гибкая блокировка с помощью std::unique_lock:

_std::unique_lock_ более гибок, чем _std::lock_guard_, потому что ему не обязательно владеть мьютексом, который он захватывает. Во второй аргумент конструктора объекта _std::unique_lock_ можно положить не только _std::adopt_lock_, но и такой аргумент как _std::defer_lock_ - который говорит, что в момент конструирования мьютекс не должен захватываться. Захвать его можно будет позже, вызвав метод _lock()_.

Стоит учитывать, что _std::unique_lock_ потребляет больше памяти и выполняется чуть дольше, чем _std::lock_guard_.

Пример использования (перепишем немного пример со swap):

```C++
class X
{
private:
    some_big_object some_detail;
    mutable std::mutex m;

public:
    X(some_big_object const& sd)
        : some_detail(sd)
    {}

    friend void swap (X& lhs, X& rhs);
};

void swap (X& lhs, X& rhs)
{
    if (&lhs == &rhs)
    {
        return;
    }

    std::unique_lock<std::mutex> lock_a(lhs.m, std::defer_lock);  // [1]
    std::unique_lock<std::mutex> lock_b(rhs.m, std::defer_lock);
    std::lock(lock_a, lock_b);                                    // [3]

    swap(lhs.some_detail, rhs.some_detail);
}
```

1. Мьютексы остаются не захваченные.
2. А вот в функции std::lock() - мьютексы уже захватываются.

Когда в _std::unique_lock_ тем или иным образом вызывается метод _lock()_ - в самом объекте _std::unique_lock_ поднимается флаг, что сейчас мьютекс залочен, и владение им отошло объекту.

---

### Передача владения мьютексом между контекстами:

Из-за того, что _std::unique_lock_ не владеет ассоциированными мьютексами, то можно передавать владение от одного объекта другому, при помощи перемещения.

Оно из самых частых применений - какая-то функция захватывает мьютекс, а потом владение передается из этой функции, при её вызове.

```C++
std::unique_lock<std::mutex> get_lock()
{
		extern std::mutex some_mutex;
		std::unique_lock<std::mutex> lk(some_mutex);
		prepare_data();
		return lk;
}

void process_data()
{
		std::unique_lock<std::mutex> lk(get_lock());
		do_something();
}
```

---

### Выбор правильной гранулярности блокировки:

_Гранулярность блокировок_ - объем данных, защищаемых блокировкой.

Мелкогранулярные блокировки - защищают мало данных. Крупногранулярные блокировки - защищают сразу много данных.

Важные правила работы с мьютексами:

1. Старайтесь захватывать мьютекс непосредственно перед доступом к разделяемым данным.
2. Старайтесь производить обработку данных не находясь под защитой мьютекса.

Вот тут как раз очень хорошо помогает объект _std::unique_lock_ - потому что всегда можно вызвать метод _unlock()_ для ассоциированного мьютекса, если вдруг программе не нужен доступ к разделяемым данным. А если доступ понадобился - вызываем _lock()._

```C++
void get_and_process_data()
{
		std::unique_lock<std::mutex> my_lock(the_mutex);       // Мьютекс лочится 
		some_class data_to_process = get_next_data_chunk();    // Работа с
                                                           // разделяемыми данными
		my_lock.unlock();                                      // Отпускаем мьютекс
		result_type result = process(data_to_process);         // Производим тяжелую
																													 // обработку
		my_lock.lock();                                        // Опять лочим мьютекс
		write_result(data_to_process, result);                 // Записываем новые 
                                                           // обработанные данные
																												   // под защитой мьютекса
}
```

Что бы не замедлять программу просто держа один мьютекс на всех операциях, лучше использовать мелкогранулярные блокировки - блокирую разделяемые данные только при записи/чтении.

---

## Другие средства защиты разделяемых данных.

Мьютексы - самый общий механизм, защиты разделяемых данных, но есть и другие механизмы, которые хорошо работают именно в специальных случаях.

Один такой крайний, но частый случай, это когда разделяемые данные нуждаются в защите от одновременного доступа только во время инициализации, а потом уже синхронизация не требуется.

Для таких ситуаций, даже предусмотрен отдельный механизм в C++.

---

### Защита разделяемых данных во время инициализации:

Предположим, что есть очень большой разделяемый ресурс, база данных, огромное количество памяти или еще что-то. В таких случаях обычно пользуются отложенной инициализацией, что бы не выделять на конструирование этого ресурса время просто так. И в каждой программе, перед отложенной инициализацией надо проверить, не захвачен ли уже ресурс.

Однако наивный подход из листинга ниже, может привести к ненужной сериализации потоков, использующих этот ресурс. Так как каждый поток должен ждать освобождения мьютекса, что бы проверить был ли ресурс инициализирован.

```C++
std::shared_ptr<some_resource> resource_ptr;
std::mutex resource_mutex;                    // В этой точке все потоки 
																							// сериализуются (часто излишне)

void foo()
{
		std::unique_lock<std::mutex> lk(resource_mutex);
		if (!resource_ptr)                         // Обратим внимание, что мьютекс
		{                                          // лочится перед проверкой
				resource_ptr.reset(new some_resource); // В защите нуждается только
		}                                          // инициализация
		lk.unlock();
		resource_ptr->do_something();
}
```

Отсюда в голову сразу идет простоя идея обойти лишнюю сериализацию. Включить еще одну проверку перед захватом мьютекса. И это супер распространенная ошибка.

Есть даже такой анти-паттерн _блокировка с двойной проверкой_ (_Double-Checked Locking_).

```C++
void undefine_behaviour_with_double_checked_locking()
{
		if (!resource_ptr)                                   // [1]
		{
				std::lock_guard<std::mutex> lk(resource_mutex);
				if (!resource_ptr)                               // [2]
				{                                          
						resource_ptr.reset(new some_resource);       // [3]
				}                                          
		}
		resource_ptr->do_something();                        // [4]
}
```

1. Здесь начинается состояние гонки, так как происходит чтение без защиты мьютекса и это все не синхронизированно с записью в другой поток. Возникает гонка, которая будет угрожать не указателю, а именно объекту, на который он указывает. Если один поток видит, что указатель инициализирован другим потоком, он может не увидеть вновь созданного объекта _some_resource_.
2. Здесь происходит вторая проверка, но уже под защитой
3. Происходит инициализация, под защитой мьютекса.
4. И исходя из пункта [1] _do_something();_ может примениться не к тому объекту.

Гонки такого рода называются - _гонкой за данными_. И они относятся к категории _неопределенного поведения_.

Ситуация с применением метода не к тому объекту была настолько воспринята серьезно комитетом по стандартизации C++. Что был добавлен флаг _std::once_flag_ и шаблон функции _std::call_once_.

Поэтому имеет смысл переписать пример кода выше следующим образом:

```C++
std::shared_ptr<some_resource> resource_ptr;
std::once_flag resource_flag;

void init_resource()
{
    resource_ptr.reset(new some_resource);
}

void foo()
{
    std::call_once(resource_flag, init_resource); // Инициализация произойдет 
    resource_ptr->do_something();                 // только один раз
}
```

Даже если код, приведенный выше, запустить в пяти потоках одновременно, функция _init_resource_, отработает ровно один раз. И тогда метод _do_something()_ применится к одному объекту но уже 5 раз, а не как в _блокировке с двойной проверкой_: два раза к одну объекту применился, три раза к другому, к примеру.

Выше мы описали проблему и предложили ее решение. Теперь небольшой пример использования:

```C++
class X
{
public:
    X(const connection_info &connection_details_)
        : connection_details{connection_details_}
    {}

    void send_data(const data_packet &data)                              // [1]
    {
        std::call_once(connection_init_flag, &X::open_connection, this); // [2]
        connection.send_data(data);
    }

    data_packet receive_data()                                           // [3]
    {
        std::call_once(connection_init_flag, &X::open_connection, this); // [2]
        return connection.receive_data();
    }

private:
    void open_connection()
    {
        connection = connection_manager.open(connection_details);
    }

private:
    connection_info   connection_details;
    connection_handle connection;
    std::once_flag    connection_init_flag;
};
```

1. Здесь производится инициализация, если вдруг к этому методу обращаются в первый раз (из всех возможных потоков).
2. Метод производит инициализацию.
3. Либо же здесь происходит первичная инициализация, если такая не была произведена в пункте [1].

Так же стоит помнить, что начиная с 11-го стандарта _static_ стала потокобезопасной, поэтому:

```C++
class my_class;
my_class& get_my_class_instance()
{
		static my_class instance; // Гарантируется, точ инициализация потокобезопасна
		return instance;
}
```

В таком случае потоки будут конкурировать лишь за то, кто произведет инициализацию первым.

---

### Защита редко обновляемых структур данных:

Есть такие ситуации, когда к неким данным несколько потоков будут часто обращаться на чтение, но очень редко будут что-то менять. Использовать _std::mutex_ - слишком пессимистично, потому что он будет блокировать даже доступ на чтение, и читать данные можно будет только одним поток за раз.

В подобных ситуациях нам необходим новый вид мьютекса, который появился с 17-м стандартом _std::shared_mutex_, данный мьютекс ещё называют мьютексом _чтения-записи_ (_reader-writer mutex_). Он допускает монопольный доступ со стороны “потока-писателя”, и параллельный доступ со стороны “потоков-читателей”.

Идея разделения на “чтение”, “запись” следующая - там где нужен монопольный доступ к данным используем _std::lock_guard<std::shared_mutex>_ или _std::unique_lock<std::shared_mutex>_ (назовем это _монопольной_ блокировкой). А там, где будет происходить только чтение стоит использовать _std::shared_lock<std::shared_mutex>_ (назовем это _разделяемой_ блокировкой).

Работает это так: если какой-то поток захватил разделяемую блокировку, то любой поток, который попытается захватить мнопольную блокировку, будет приостановлен до тех пор, пока все прочие потоки не освободят свои блокировки. И наоборот, если какой-то поток владеет монопольной блокировкой, то никакой другой не сможет получить не разделяемую, ни монопольную блокировку.

```C++
class dns_cache
{
public:
    dns_entry find_entry(const std::string &domain)
    {
        std::shared_lock<std::shared_mutex> lock(entry_mutex);  // [1]
        const std::map<std::string, dns_entry>::const_iterator it = entries.find(domain);
        return (it == entries.end()) ? dns_entry{} : it->second;
    }

    void update_or_add_entry(const std::string &domain, const dns_entry &dns_details)
    {
        std::lock_guard<std::shared_mutex> lock(entry_mutex);   // [2]
        entries[domain] = dns_details;
    }

private:
    std::map<std::string, dns_entry> entries;
    std::shared_mutex                entry_mutex;
};
```

1. Здесь происходит разделяемый доступ к данным для чтения. Следовательно функцию _find_entry_ можно вызвать из нескольких потоков.
2. Здесь же происходит монопольный доступ, а значит блокируются все потоки не только при доступе в _update_or_add_entry_, но и при доступе к _find_entry_.

---

### Рекурсивная блокировка:

Повторный захват _std::mutex_ - приводит к неопределенному поведению, однако существуют ситуации, когда надо захватить мьютекс повторно, при этом не освобождая его.

В стандарте для таких целей существует _std::recursive_mutex_, работает он аналогично _std::mutex_, но с одним отличием: один и тот же поток может многократно захватывать данный мьютекс. Но перед тем, как этот мьютекс сможет захватить другой поток нужно вызвать _unlock()_ ровно столько же раз, сколько был вызван _lock()_.

Лучше всего отслеживать это через конструкции _std::lock_guard<std::recursive_mutex>_ и _std::unique_lock<std::recursive_mutex>_

Обычно, рекурсивные мьютексы не рекомендуется использовать: лучше перепроектировать программу.