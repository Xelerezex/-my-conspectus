---

В этой главе:

- Что понимается под параллелизмом и многопоточностью.
- Зачем использовать параллелизм и многопоточность в своих приложениях.
- Замечания об истории поддержки параллелизма в C++.
- Структура простой многопоточной программы в C++.

---

## В двух словах про: А что такое параллелизм?

Параллелизм - одновременное выполнение двух или более операций. Система выполняет несколько независимых операций параллельно, а не последовательно. Истинный параллелизм (не переключение между задачами) можно реализовать либо на нескольких независимых ядрах, либо когда несколько процессоров.

  

![[parallels-types.png]]

Стоит обратить внимание на то, что в одноядерном компьютере будет тратится какое-то минимальное время на переключение между задачами. Маленькие полосочки называются: _контекстное переключение_**.**

Забавный факт, что хоть и истинный параллелизм осуществляется в много-процессорных/ядерных системах, так же он может происходить и в процессорах, которые способны выполнять несколько потоков на одном ядре. То есть реальным существенным фактором, определения параллельна ли система является - количество _аппаратных потоков_.

![[two-core-four-tasks.png]]

Поэтому более приближенная к реальности будет такая картинка ⬆️. Когда несколько потоков что-то выполняют, а задач гораздо больше чем ядер (В этом конкретном случаем 4 задачи, 2 ядра).

---

## Подходы к организации параллелизма.

Два основных подхода, которые неплохо отображают суть, это:

- Существует _два процесса_, и в каждом процессе по _одному потоку_. Из плюсов: удобно работать, никто никому не мешает. Из минусов: затруднено общение между потоками, повышаются расходы ресурсов.
- Существует _один процесс_ и в нем находятся _два потока_. Из плюсов: быстрое и удобное общение между потоками, снижаются расходы ресурсов. Из минусов: могут возникнуть проблемы с общим доступом к ресурсам.

### Параллелизм за счет нескольких процессов:

Первый способ распараллелить приложение - разбить его на несколько однопоточных процессов:

![[1-thread-n-process.png]]

Один поток, несколько процессов.

Как пример: Запустить браузер и редактор одновременно.

Затем эти процессы могут применять стандартные инструменты для межпроцессной коммуникации, типа:

- Сигналы.
- Сокеты.
- Файлы.
- Конвейеры.

Плюсы такого подхода: из-за надежной защиты процессов со стороны операционной системы, а так же высокоуровневым механизмам коммуникации написание **безопасного** кода гораздо проще. Так же процессы можно запускать на разных машинах, объединенных сетью.

Недостатки в таком подходе: сложность связи между процессами, иногда даже медлительности. Неустранимые накладные расходы на запуск нескольких процессов со стороны операционной системы.

### Параллелизм за счет нескольких потоков:

Второй способ распараллелить приложение - разбить его на несколько потоков внутри одного процесса.

![[n-thread-1-process.png]]

Несколько потоков, один процесс.

Потоки можно считать “_облегченной версией процесса_” - каждый поток работает независимо от всех остальных, и все потоки могут выполнять разные последовательности команд.

Плюсы такого подхода: Низкие накладные расходы на запуск потоков внутри процесса, так же в плюсы можно записать удобство коммуникации, одно адресное пространство позволяет напрямую обращаться к объектам.

Недостатки в таком подходе: Общее адресное пространство является так же и проблемой здесь, так как, если два потока будут обращаться к одному и тому же элементу одновременно, то может быть непонятно что. И именно на плечи программиста взваливается ответственность за согласованность обращение к одним и тем же элементам разными потоками.

---

## Зачем нужен параллелизм?

Основных причины, зачастую, всего две (и в итоге, обычно, все остальные причины к ним и сводятся):

- Разделение обязанностей.
- Производительность.

### Применение параллелизма для разделения обязанностей:

Разделение обязанностей в программе это всегда хорошо, группировка взаимосвязанных, и разделение несвязных частей кода делает программу:

- Проще для понимания.
- Проще для тестирования.
- Из двух пунктов выше, следует, что и ошибок она будет содержать меньше.

В данном случае количество потоков не зависит от количества имеющихся процессорных ядер, потому что программа разбивается на потоки только ради чистоты дизайна.

### Применение параллелизма для повышения производительности:

Существует два основных способа распараллелить задачу для повышения её производительности:

- _Распараллеливание по задачам_ - разбить задачу на части и запустить их параллельно.
- _Распараллелить по данным_ - это когда каждый поток выполняет одну и туже операцию, но с разными данными.

### Почему параллелизм может быть вреден.

Каждому потоку необходим свой стек, отсюда дополнительные расходы для ОС, можно так же исчерпать память, или адресное пространство при слишком большом количестве потоков.

Не стоит создавать больше потоков, чем есть ядер на аппаратной системе, над которой ведется работа

---

## Простая параллельная программа.

```C++
\#include <iostream>
\#include <thread>                            // <- Все нужные объявления 
																					   //    для работы с многопоточностью
                                             //    (Функции и классы для 
                                             //     управления потоками)
void hello()                                 // <- Функция которая будет работать 
{                                            //    во втором потоке
		std::cout << "Hello, parallel world,\n";
}

int main()
{
		std::thread t(hello);                     // <- Запуск нового потока
		t.join();                                 // <- Функция ждет завершения 
}                                             //    потока t
```