
---

Объектно ориентированный подход идеален для простых ситуаций, когда нужно отобразить маленький объем данных.

Проблема следующая: Есть очень много данных, их надо как-то отобразить в 5-ти виджетах. Просто загонять эти данные через методы типа

```C++
.append(someElement);
```

было бы прям очень грустно. Возникает сразу огромное количество дублирования, и дополнительные затраты на синхронизацию данных в этих 5-ти виджетах.

Qt предоставляет технологию, которая называется - “_Интервью_” или “_Модель-Представление_”. Стоит ещё не забывать, что “_Модель-Представление_” в Qt это не прямая реализация шаблона MVC, и использует лишь основные идеи.

Основные идеи “_Модель-Представление_” в Qt:

- Отделение Данных от их Представления.
- Возможность показа данных в нескольких представлениях без дублирования.
- Возможность внесения изменений с минимумом временных затрат. Пример такой: Доступ к данным осуществляется через интерфейс, а виджет отображения сменился, если интерфейс доступа к данным не поменялся, то сильно код менять нет нужды.
- Код становится удобнее. Так как теперь есть две независимые сущности: “Модель”, “Представление”, при изменении одной из сущности - вторую эти изменения могут не коснуться (зависит от заданной логикик пользователя).
- Удобство тестирования кода. Как только интерфейс чтения задан, можно написать один тест, который может быть использован для любой модели, реализующий этот интерфейс.
- Упрощение интеграции баз данных. Так как в Qt используется похожая модель для работы с Базами Данных, легко заменить какой-нибудь лист на полноценное БД.

![[model-view.png]]

Все части технологии “Модель-представление” могут взаимодействовать в соответствии с направлениями стрелок.

Основные составляющие технологии “Модель-Представление”:

- _Модель_ - отвечает за управление данными и предоставляет интерфейс для чтения и записи данных.
- _Представление_ - отвечает за представление данных пользователю и за их расположение.
- _Выделение элемента_ - специальная модель, отвечающая за централизованное использование выделений элементов.
- _Делегат_ - отвечает за рисование каждого элемента в отдельности, а также за его редактирование.

_Пометка про наследование._

---
### Модель

Модель - оболочка вокруг исходных данных, предоставляющая стандартный интерфейс для доступа к ним. Из-за того, что доступ к данным есть только через интерфейс, это значит, что модели можно разрабатывать отдельно друг от друга, потом лишь заменяя их.

В _Qt_ все модели базируются на классе _QAbstractItemModel._

Древо наследования будет следующим:

![[QAbstarctItemModule-Three.png]]

Древо наследование Моделей в Qt.

Описание основных классов:

- _QAbstractItemModel_ - это обобщенная таблица, за каждой ячейкой которой может быть закреплена еще одна таблица.
- _QAbstractListModel_ - одномерный список.
- _QAbstractTableModel_ - двумерная таблица.
- _QStandardItemModel_ - позволяет сохранять данные напрямую в модель, это противоречит принципам “_Модель-Представление_”, поэтому стоит использовать только с маленькими объемами данных.
- _QStringListModel_ - так же одномерный список, но заточенный исключительно под работу со строками.
- _QAbstractProxyModel_ - нужна для извлечения данных из таблицы, проведения каких-то манипуляций над данными и возврат в качестве новой модели. Можно смело применять для сортировок и фильтраций данных, для этого даже есть класс наследник _QSortFilterProxyModel._
- _QFileSystemModel - представляет собой готовый класс иерархии файловой системы._

![[model-interface-view.png]]

Как модель общается с представлением

Данные, которые предоставляет модель, могут использоваться и отображаться разными представлениями. Так же Модель знает о основных свойствах Представления, типа индекса, положения в таблице и так далее.

---
### Представление

![[view-inheritance.png]]

Иерархия наследования в Представлении.

- `QAbstactScrollArea`- _один из базовых классов для всех представлений, который позволяет использовать прокрутку по виджету._
- `QAbstractItemView`- _так же один из важных базовых классов, дает всем наследникам возможность установки моделей в представление и другие основные методы. За частую, все классы View унаследованы от него._

Как мы можем видеть из иерархии наследования - многие виджеты наследуются от _*View,_ это говорит о том, что Виджет - это как бы готовая и Модель и Представление в одном флаконе.

---
### Выделение элемента

Выделение - часть механизма представления, которая может задаваться посредствам метода _QAbstractItemView::setSelectionModel()._ Данный механизм позволяет централизованно выбрать один механизм Выделения для нескольких Представлений.

![[selection.png]]

---
### Делегат
Делегат - механизм представления, нужный для отрисовки элемента Модели и его редактирования пользователем. Другими словами: для стандартных Представлений списков и таблиц, отображение элементов выполняется по средствам так называемого _делегирования._

Для создания какой-то сложной отрисовки или нетривиального редактирования, стоит создавать своих Делегатов при помощи наследования от класса `QAbstractItemDelegate`.

![[delegate-inheritance.png]]

Иерархия наследования для Делегатов.