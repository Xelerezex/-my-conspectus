_Неполное имя_ (_Unqualified name_) - такое имя, которое не имеет слева от себя, оператора ::.

“Неполный поиск имени” сначала ищет в локальной области, если ничего не находит - переходит в глобальную (не заходя в область видимости конкретных классов или в пространства имен), если и там ничего нет - выкидывается ошибка. Ищется до тех пор, пока не найдется одного соответствующего имени, потом поиск сразу же остановится.

- _**Замечание!**_
    
    Если “поиск неполного имени” применяется к имени, которое стоит слева оператора ::, то он игнорирует объявления функций, переменных, и счетчиков, короче игнорирует все не определения новых типов.
    

## “Unqualified name lookup” - с разными сущностями:

### Глобальная область (файловая область):

В глобальной области видимости, имена ищутся следующим образом:

```C++
int n = 1;     // Объявление n
int x = n + 1; // Ok: "Поиск неполного имени" идет сверху-вниз по коду и поэтому
               // находит переменную n

int z = y - 1; // Error: Объявление y будет не найдено
int y = 2;
```

### Объявления внутри пространства имен:

Для объявлений имен, используемых в пространстве имен определенным пользователем, работает следующее правило:

1. Сначала имя ищется в пространстве имен [1], где и произошел вызов поиска.
2. Потом происходит поиск в пространстве имен [2], куда вложено пространство имен [1].
3. Это повторяется N раз, в зависимости от количества вложенности.
4. И потом “неполный поиск” ищет объявление в глобальном пространстве имен.

```C++
int n = 1;    // Объявление

namespace N
{
		int m = 2;

		namespace Y
		{
				int x = n; // Ok: Сначала поиск ищет n локально в namespace Y, не находит
                   //     Потом поиск ищет в namespace N, не находит 
									 //     Потом поиск ищет в глобальном namespace, и там находит 
                   //     переменную.
				int y = m; // Ok: m - находится по такому же принципу, только раньше
				int z = k; // Error: k - будет не найдено
		}

		int k = 3;
}
```

### Определение вне их области видимости:

Для имен, которые являются членами какой-то области видимости, но используются вне ее, используются правила, как описано выше в пункте “Объявления внутри пространства имен:”.

```C++
namespace X
{
		extern int x; // объявление, не определение
		int n = 1;    // Находится первым по счету
};

int n = 2;        // Находится вторым по счету
int X::x = n;     // Находит сначала "неполным поиском" X
                  // "Полным поиском" находится x
                  // И так же "неполным поиском" находится n, но уже в 
                  // namespace X. И X::x = 1
```

### Определение функций, не являющихся методами:

Для имени, которое находится внутри определение функции, либо внутри тела, либо как часть дефолтного аргумента, блок кода, в котором данное имя используется, сначала обыскивается и только потом используется данное имя. Таким же образом обыскиваются все блоки, пока не дойдет до основного блока тела функции. Потом обыскиваются пространства имен, вплоть до глобального, по тому принципы, как описано в пункте: “Объявления внутри пространства имен:”

```C++
namespace A
{
		namespace N
		{
				void f();
				int i = 3;      // Найдется третьим по счету
		}

    int i = 4;          // Найдется четвертым по счету
}
 
int i = 5;              // Найдется пятым по счету

void A::N::F()
{
		int i = 2;           // Найдется вторым по счету

		while (true)
		{
				int i = 1;       // Найдется первым по счету
				std::cout << i;  // Используется здесь, поиск стартует отсюда по областям
		}
}

// int i;                // Не найдется
namespace A
{
    namespace N
    {
        // int i;        // Не найдется
    }
}
```

### Определение класса:

Для имени, которое используется где-либо в определении класса, используются следующие правила:

1. Сначала используется “поиск полного имени” в теле класса, где имя используется, ровно до точки его использования.
2. Потом имя ищется в теле базового класса(так же рекурсивного входя в тела базового класса, для этого базового класса), пока объявление не будет найдено.
3. Если имя, которое ищется - это класс вложенный, то объявление ищется сначала во включающем классе, а потом в базовом классе включающего класса.
4. Если имя, которое ищется - это локальный класс, или вложенный локально класс, то обыскивается область в которую класс вложен, до точки определения.
5. Если имя, которое ищется - это класс, принадлежащий какому-то пространству имен. Или оно включено в класс, который является членом какого-то пространства имен. Или же если оно - локальный класс внутри функции, которая член какого-то пространства имен. то тогда будет обыскиваться область пространства имен, до тех пор, пока не найдется определение этого имени и поиск продолжится до конца пространства этого имени, вплоть до глобального (но не включая глобальное).

```C++
namespace M
{
		// const int i = 2;                   // Никогда не будет найдена
		
		class B
		{
		    // static const int i = 3;        // Будет найдена третья по счету
    };                                    // (но не пройдет access check)
}

// const int i = 5;                       // Будет найдена пятое по счету

namespace N
{
		// const int i = 4;                   // Будет найдена третья по счету

		class Y : public M::B
		{
				// static const int i = 2;        // Будет найдена вторая по счету
				class X
				{
						// static const int i = 1;    // Будет найдена первая по счету
						int a[i];                     // Использование i, начинается поиск
						// static const int i = 1;    // Никогда не будет найдена
				};

        // static const int i = 2;        // Никогда не будет найдена
		}

    // const int i = 4;                   // Никогда не будет найдена

}
// const int i = 5;                       // Никогда не будет найдена
```

### Вложенные классовые имена:

Для имени класса или шаблона класса, используемого в определении этого класса или шаблона или производного от него, поиск по “неполному поиску” имени находит класс, который определяется, как если бы имя было введено объявлением члена (с открытым доступом к члену).

### Определения методов:

Для имени, используемого внутри функций члена класса, либо как аргумент по умолчанию метода этого члена, или же как лист инициализации - области поиска такие же, как и в определении класса, за исключением того, что рассматривается вся область класса, а не только часть, предшествующая объявление, в котором используется это имя.

```C++
class B
{
		// int i;                 // Будет найдено третье по счету	
};

namespace M
{
		// int i;                 // Будет найдено пятое по счету
		
    namespace N
    {
		    // int i;             // Будет найдено четвертое по счету				

				class X : public B
				{
		        // int i;         // Будет найдено второе по счету
						void f();
		        // int i;         // Так же будет найдено второе по счету
        };
		    // int i;             // Будет найдено четвертое по счету
		}
}

// int i;                     // Будет найдено второе по счету

void M::N::X::f()
{
		// int i;                 // Будет найдено первое по счету
		i = 16;                   // Использование имени
    // int i;                 // Никогда не будет найдено 
}

namespace M
{
		namespace N
		{
				// int i;             // Никогда не будет найдено
		}
}
```

  

  

- [ ] [Дополнить ответ с сппреф](https://en.cppreference.com/w/cpp/language/unqualified_lookup#Member%20function%20definition) https://en.cppreference.com/w/cpp/language/unqualified_lookup