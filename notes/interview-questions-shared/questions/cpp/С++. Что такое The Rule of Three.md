## Введение:

В первую очередь стоит сказать, что C++ рассматривает все переменные, заданные пользователем при помощи _value semantics_ (семантика передачи по значению). Эта семантика подразумевает, что в различных контекстах использования переменных, они будут копироваться.

На этом моменте стоит остановиться и разобраться, что имеется в виду, под “копированием объекта”.

Введем небольшой пример, от которого в дальнейшем будем отталкиваться:

```C++
class person
{
public:

	person (const std::string& name, int age)
		: name(name)
		, age(age)
	{
	}

private:

	std::string name;
	int age;
	
};

int main()
{
	person a("Bjarne Stroustrup", 60);
	person b(a);                        // Важный момент, куда надо обратить
    b = a;                              // внимание на этих 2 строках
}
```

## Особые методы:

Вернемся к вопросу: “Так что же значит скопировать объект $person$﻿”?

В функции `main`﻿ показано два сценария копирования объекта. Рассмотрим их по порядку.

В первом случае `person b(a);`﻿ происходит инициализация нового объекта и вызывается _конструктор копирования_, его задача заключается в том, что бы создать новый объект, основываясь на свойствах уже существующего.

Во втором случае `b = a;`﻿ копирование осуществляется, по средствам, _оператора присваивания_, чья работа может быть чуть более сложной, потому что объект `b`﻿ уже создан и имеет определенные свойства.

Стоит дать определения таким понятиям, как _оператор присваивания_ и _конструктор копирования_. Эти методы относятся к особым методам класса, которые даже без явного объявления в коде, будут реализованы компилятором (это правило так же относится к деструкторам).

Так же, за частую, _копирование объектов_ - значит, что скопированы будут поля и подклассы объекта.

### Неявные определения:

Неявно определенные методы для класса $person$﻿ будут выглядеть следующем образом:

```C++
// 1. Конструктор копирования
person(const person& other)
    : name(other.name)
    , age(other,age)
{
}

// 2. оператор присваивания-копирования
person& operator= (const person& other)
{
		name = other.name;
    age  = other.age;
    return *this;
}

// 3. Деструктор
~person()
{
}
```

Как и говорилось ранее - _полное копирование объекта_ подразумевает копирование всех его полей. Так же деструктор будет пустой, потому что мы не имеем в классе полей, которые созданы динамически и за чье удаление отвечаем именно мы.

После вызова деструктора **~**$person()$﻿ сначала удалится объект класса $person$﻿ а потом вызовутся деструкторы всех полей этого класса. Пример:

```C++
#include <iostream>

class C
{

public:

    ~C() { std::cout << "Third deleted" << std::endl; }
    
private:

};

class B
{

public:

    ~B() { std::cout << "Second deleted" << std::endl; }
    
private:

};

class A
{
public:

    A() : c( C{} ), b( B{} ) {}
    ~A() { std::cout << "Firstly deleted" << std::endl; }
    
private:

    C c;
    B b;
    
};

int main()
{
    A a;
}
```

На выходе получим:

```C++
Firstly deleted
Second deleted
Third deleted
```

## Управление ресурсом:

Так в каких же случаях, стоит задавать эти _особые методы_ явно?

_Особые методы_, зачастую, задаются явно, когда класс ответственен за _управление ресурсом._ Имеется ввиду, что в конструкторе выделяется некий ресурс (либо передается в конструктор), и в деструкторе идет высвобождение этого ресурса.

```C++
class person
{
public:

    // В данном случаем конструктор выделяет ресурс при помощи оператора new[]
	person(const char* the_name, int the_age)
	{
		name = new char[strlen(the_name) + 1];
		strcpy(name, the_name);
        age = the_age;
    }
		
	// А здесь деструктор полностью освобождает, выделенный конструктором, ресурс
	~person()
    {
		delete[] name;
    }
    
private:
	char* name;
    int   age;
    
};
```

В этом классе есть выделенная динамически память и указатели, а значит самая критичная ошибка, которую мы можем совершить при копирование объекта такого типа, это вызвать $name = other.name;$﻿ в таком случает просто будут перезаписаны указатели. Адреса внутри переменных поменяется, и все, данные без проблем могут утечь. Ведь важная часть _управления ресурсом_ это _освобождение этого ресурса_, а оно может не произойти.

### Явное определение:

В примере кода выше, мы увидели как выделяется ресурс внутри конструктора (то есть при создании нового объекта). Но, что бы, к примеру поместить объекты класса $person$﻿ в контейнер типа $std::vector$﻿ нам надо будет скопировать этот объект. А для копирования, нужно будет явно определить _конструктор копирования_ и _оператор присваивания_.

Продолжим дополнять наш пример с классом $person$﻿, где есть поле с динамически выделенной памятью:

```C++
class person
{

public:

	person(const char* the_name, int the_age)
	{
		name = new char[strlen(the_name) + 1];
		strcpy(name, the_name);
        age = the_age;
    }
		
	// 1. Определяем конструктор копирования:
    person (const person& other)
    {
		name = new char[strlen(other.name) + 1];
		strcpy(name, other.name);
        age = other.age;
	}
		
	// 2. Опредеяем оператор присваивания
    person& operator= (const person& other)
	{
		// Очень важная проверка при копировании, что бы объекты не
        // были идентичными, иначе опять могут быть проблемы с памятью 
        // выделенной динамически
        if (this != &other)
		{
			delete[] name;
			// И стоит обратить внимание, что после того, как мы очистили 
			// динамически выделенную память под имя этого класса, мы нарушили его                 
			// инвариант, и если на этом этапе следующая строка выкинет исключени
			// е, то мы можем получить неликвидный объект.
			name = new char[strlen(other.name) + 1];
			strcpy(name, other.name);
			age = other.age;
		}
		return *this;
    }

	~person()
    {
		delete[] name;
    }
    
private:

	char* name;
    int   age;
    
};
```

Получается, что копирование - это довольно опасная операция, где может быть очень много подводных камней. Вот некоторые их них:

1. Нужно удалить прошлое состояние переменной $name$﻿ для предотвращения утечки памяти.
2. Так же мы должны проверять, что нигде не используется простое копирование указателей типа `x = x;`﻿, а именно новое выделение динамической памяти через $new$﻿, так как может произойти проблема, когда два разных объекта указывают на одну и ту же, динамически выделенную, память - а значит, при вызове `delete[] name;`﻿ будет угроза двойного удаления.
3. И как написано в комментарии к коду, есть потенциальная угроза исключений.

### Безопасность относительно исключений:

К сожалению, в операторе присваивания, в примере выше - будут огромные проблемы с нарушением инварианта объекта, если операция `new char[...]`﻿ вызовет исключение.

Один из возможных вариантов решения этой проблемы - ввести локальную переменную и изменить порядок операций:

```C++
// 2. Опредеяем оператор присваивания
person& operator= (const person& other)
{
	// Так же в таком случае можно избавиться от проверки на равенство объектов,
    // потому что, нет такой ситуации при которой вышло бы, что два разных объекта
    // указывают на одну и ту же память. (Хотя если вдруг выделять нужно слишком
    // много памяти через new, и в оператор присваивания закинут такой же объект,
    // нет смысла перевыделять еще памяти, проще сделать одну проверку указателей)
	char* local_name = new char[strlen(other.name) + 1];
	// Если выражение выше выкидывает исключение - то этот объект, не нарушает
	// свой ивариант и просто остается в нетронутом положении.
	strcpy(local_name, other.name);
	delete[] name;
	name = local_name;
	age = other.age;

	return *this;
}
```

Так же в этом случае можно применить идиому copy-and-swap.

[[C++. Что такое copy-and-swap идиома|C++. Что такое copy-and-swap идиома]]

## Не копируемые ресурсы:

Некоторые ресурсы по своей сути не должны быть копируемыми, к примеру, файловые дескрипторы или мьютексы. Что бы объявить объект не копируемым, можно:

Объявить оператор присваивания и конструктор копирования приватными.

```C++
private:

    person(const person& other);
    person& operator=(const person& other);
```

Или же можно явно удалить оператор присваивания и конструктор копирования.

```C++
person(const person& that) = delete;
person& operator=(const person& that) = delete;
```

Или при использовании библиотеки $boost$﻿ можно отнаследоваться от класса $boost::noncopyable$﻿.

## Правило Трех:

Иногда приходится реализовывать классы, которые управляют ресурсами. В таких случаях лучше помнить _Правило Трех_:

```C++
Если нужно явно определить только один из особых методов: деструктор, оператор 
присваивания или конструктор копирования.
То нужно явно определять все три особых метода.
```

(К сожалению, это правило не поддерживается стандартом или компиляторами, но оно все еще полезно как напоминание по разработке)

## Правило Пяти:

Появилось, когда к власти в C++ пришел одиннадцатый стандарт, и в язык была внедрена _move_-семантика. Правило стало звучать так:

```C++
Если нужно явно определить только один из особых методов: деструктор, оператор 
присваивания, оператор перемещения или конструктор копирования, конструктор 
перемещения.
То нужно явно определять все пятерку особых методов.
```

Как это примерно выглядит на коде:

```C++
class person
{
    std::string name;
    int age;

public:
	// Конструктор
    person(const std::string& name, int age);
	// 1/5: Конструктор Копирования    
    person(const person &) = default;
	// 4/5: Конструктор Перемещения                 
    person(person &&) noexcept = default;  
	// 2/5: Оператор Присваивания         
    person& operator=(const person &) = default; 
    // 5/5: Оператор Перемещения
    person& operator=(person &&) noexcept = default;
	// 3/5: Деструктор 
    ~person() noexcept = default;                    
};
```

## Правило Нуля:

```C++
Стоит определять либо 0 (если ничего не определено, можно писать пустой класс), 
либо 3 (если определене хотя один из методов из правила трех), либо 5 (если 
определен хотя бы один метод перемещения, то стоит определять все) особых методов.
```

## Sources:

1. [Stack OverFlow. What is The Rule of Three?](https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three)[**.**](https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three)