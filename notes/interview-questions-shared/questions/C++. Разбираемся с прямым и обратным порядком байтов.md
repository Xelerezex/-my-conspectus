
---

### Ресурсы:

1. [Прямой и обратный порядок байт](https://habr.com/ru/articles/233245/).

---

## Храним числа как данные:

Основные форматы хранения:

- _Бит_ - минимальная единица информации, хранит всего либо 1, либо 0.
- _Байт_ - последовательность из 8 бит. Крайний левый бит является самым старшим, идет под индексом 7 и является наибольшим. Крайний правый бит является самым младшим идет под индексом 0 и является наименьшим.

Данные соглашения можно использовать в качестве строительного блока для обмена данными. Если сохранять и читать только по одному байту за раз, то этот подход будет работ на абсолютно любом компьютере.

Концепция байта одинакова на всех машинах, понятие “байт 0” так же одинакова на всех машинах. Компьютеры так же понимают порядок в котором им посылаются байты, им понятно, какой байт прислан первым, какой вторым, какой пятым.

Проблемы начинаются, когда надо передать что-то больше чем байт. Например целочисленное значение из 4 байт. Или число с плавающей точкой.

### Пример с байтом:

Рассмотрим просто последовательность, состоящую из 4 байт:

|Имя байта|$W$|$X$|$Y$|$Z$|
|---|---|---|---|---|
|Позиция|0|1|2|3|
|Значение (hex)|`0x12`|`0x34`|`0x56`|`0x78`|

### Понимаем указатели:

Указатель представляет собой переменную, хранящую число, которое является адресом в памяти. И только от программистов зависит, как будет интерпретироваться число, лежащее по этому адресу.

Когда происходит каст указаетлей к конкретному типу (`char*`, `int *`), именно это действие и говорит компьютеру как интерпретировать данные по этому адресу.

```C++
void *p = 0; // p - указатель на неизвестный тип данных.

char *c;     // c - указатель на одно байтовое представление числа. 
```

Мы не можем получить данные из `p` (разыменовать его), так как не знает что за данные там хранятся, цифра, буква, начало строки.

Но если мы напишем каст:

```C++
c = (char *)p;
```

То это говорит компьютеру, что `p` указывает на то же место, и данные по этому адресу нужно интерпретировать как один символ (1 байт).

В этом случае `c` будет указывать на память по адресу 0, или на байт $W$﻿.

И если мы выведем `c` то получим значение, хранящиеся $W$﻿ и равное шестнадцатеричному 0x12.

### **Так в чем же проблема?**

Все проблемы начинаются, когда компьютер пытается считать несколько байт.

И встает главный вопрос - если мы считываем многобайтовые данные, то где находится старший байт?

- Машины с порядком хранянения от старшего к младшему (прямой порядок) хранят старший байт первым (если смотреть слева направо). Как набор байтов, младший адрес будет хранить старший байт.
- Машины с порядком хранения от младшего к старшему (обратный порядок) хранят младший байт первым (если смотреть слева направо). Как набор байтов, младший адрес будет хранить младший байт.

На английском языке порядок хранения байт от старшего к младшему называется - _Big-Endian_.

И от младшего к старшему - _Little-Endian_.

**Пример:**

Пспомним про, опредленнную выше, последовательность 4 байт ($WXYZ$﻿_)._ И имеем 2 машины с одинаковыми типами порядка записи байтов. То есть, ячейка памяти 0 соответствует $W$﻿, ячейка 1 соответствует $X$﻿ и т. д.

Мы можем создать такое соглашение, помня, что понятие “байт” является машинно-независимым. А это значит, что память можно обойти по одному байту за раз и установить необходимые значения.

```C++
c = 0;     // указывает на позицию 0 (не будет работать на реальной машине!)
*c = 0x12; // устанавливаем значение W
c = 1;     // указывает на позицию 1
*c = 0x34; // устанавливаем значение X
...        // то же повторяем для Y и Z
```

### Интерпретация данных:

Теперь рассмотрим многобайтовые данные, а конкретно: `short int` на C++, это 2-х байтовое число (16 бит), которое может иметь значение от 0 до 65535 (если оно беззнаковое).

```C++
short *s; // указатель на short int (2 байта)
s = 0;    // теперь s указывает на нулевой адрес
```

Указатель `s` это указатель на данные типа `short int` и сейчас он указывает на позицию `0` , а она соотвествует $W$﻿. Что произойдет, когда мы считаем значение по указаетлю `s`?

- Машина с прямым порядком хранения: `short int` состоит из двух байт, значит считаем их так, позиция `_s_` это адрес `0` или $W$﻿ = `0х12`.
    
    Тогда позиция `s+1` это адрес `1` или $X$﻿ = `0x34`.
    
    Тогда суммарное значение будет выглядеть так: $256 * байт\ 0 + байт\ 1 = 256 * W + X$﻿ или же `0х1234`.
    
- Машина с обратным порядком хранения байт будет интерпретировать `short int` так:
    
    `short int` состоит из двух байт, значит считаем их так, позиция `_s_` это адрес `0` или $W$﻿ = `0х12`.
    
    Тогда позиция `s+1` это адрес `1` или $X$﻿ = `0x34`.
    
    Но вот суммарное значение будет высчитываться: $байт\ 0 + 256 * байт\ 1 = 256 * X + W$﻿, что равно `0x3412`
    

Обратим внимание, что обе машины начали считать с позиции s и читали память последовательно. Нет путаницы в том, что значит позиция 0 или позиция 1. Так же нет путаницы в том, что являет собой тип `short int`.

Проблема, в двух словах: **_Абсолютно одинаковые данные дают в результате два совершенно разных числа_**.

### Проблема NUXI:

Проблему с порядком байт иногда называют **NUXI** ←→ **UNIX**. Cлово **UNIX**, сохраненное на машинах с порядком хранения от старшего к младшему, будет отображаться как **NUXI** на машинах с порядком от младшего к старшему.

Допустим, что мы собираемся сохранить 4 байта (`U`, `N`, `I`, и `X`) как два `short int`: `UN` и `IX`.

Напишем примерный код, как бы это выглядело:

```C++
short *s; // Указатель для установки значения переменной типа short
s = 0х0;  // Указаетель указывает на блок памяти с адресом 0х0
*s = UN;  // Устанавливаем первое значение по адресу 0х0: U * 256 + N
s = 0х2;  // Теперь указатель указывает на блок памяти с адресом 0x2
*s = IX;  // Устанавливаем второе значение по адресу 0х20: I * 256 + X
```

Этот код не является спицифичным для какой-то машины. Если мы сохраним значение `UN` на любой машине и считаем его обратно, то получим тоже `UN`. Вопрос порядка следования байт не будет нас волновать, если мы сохраянем значение на одной машине, то должны получить это же значение при считывании.

Однако если пройтись по памяти по одному байту за раз (используя трюк с `char*`), то порядок байт может различаться.

- На машине с прямым порядком хранения байт:
    
    ```C++
    Byte:     U N I X
    Location: 0 1 2 3
    ```
    
- На машине с обратным порядком хранения байт:
    
    ```C++
    Byte:     N U X I
    Location: 0 1 2 3
    ```
    

Рассмотренный нами сценарий называется проблемой “**NUXI**”, потому что последовательность “**UNIX**” интерпретируется как “NUXI” на машинах с различным порядком хранения байтов. Опять же, эта проблема возникает только при обмене данными — каждая машина имеет внутреннюю совместимость.

### Решение 1: Использовать общий формат.

Самый простой подход состоит в том, что бы перед обменом между двумя машинами договорится об одном формате передачи данных.

Чаще всего в сети используют прямой подход, или от старшего к младшему.

Для конвертации данных в соответсвии с сетевым порядком хранения байтов, машины вызывают функцию `hton()` или _host-to-network_. На машинах с прямым порядком хранения эта функция не делает ничего, но вот с обратным порядком - данные будут переконвертированы.

Но важно использовать функцию `hton()` перед отсылкой данных, даже если приходится работать на машине с порядком хранения от старшего к младшему. Это гарантирует переносимость программы и на другие машины, которые могут иметь другую последовательность байт.

Точно так же существуют функция `ntoh()` или _network-to-host_, которая используется для чтения данных из сети. Её стоит использовать для уверенности в правильной интерпретации данных из сети.

Так же надо обладать знаниями про принимаемый тип данных:

```C++
htons() - "Host to Network Short"
htonl() - "Host to Network Long"
ntohs() - "Network to Host Short"
ntohl() - "Network to Host Long"
```

Эти функции имеют критическое значение при выполнеии низкоуровневых сетевых операций, таких как проверка контрольной суммы IP-пакетов.

### Решение 2: Использовать маркера последовательности байтов (Byte Order Mark - BOM):

Этот подход подразумевает использование некого магического числа, например `0xFEFF`, перед каждым куском данных.

Если мы считываем магическое число и его значение `0xFEFF`, значит данные в том же формате, что и на нашей машине и все хорошо.

Если же мы прочитали первое число и оно равно `0xFFFE`, то это значит, что данные записаны в отличном от нашей машины формате - и нужна конвертация.

В принципе **BOM** не обязательно должен быть числом, он может быть и последовательностью байт, такая пометка будет называться маркером последовательности байтов, потому что показывает в каком порядке данные были сохранены.

Из минусов, такой формат добавляет накладные расходы, так при передаче всего двух байт, придется еще передавать один, а в худшем случае, и больше, данных **BOM**. Так же можно банально забыть вставить этот **BOM header** в свои данные.

_Unicode_ например использует **BOM**, когда сохраняет многобайтные данные (некоторые кодировки _Unicode_ могут иметь по 2, 3 и даже 4 байта на символ).

XML же напротив позволяет избежать этой путаницы, сохраняя данные, по умолчанию, в _UTF-8_, который сохраняет информацию _Unicode_ по одному байту за раз. Это круто, потому что вспоминая все сказанное выше, проблема хранения не имеет значения для единичных байт.