---

## Вопрос первый.

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    std::cout << (25u - 52) << std::endl;
    return EXIT_SUCCESS;
}
```

_Вопрос:_

Корректен ли данный код? Что произойдет при переполнении?

При операции над одним знаковым числом, и над одним беззнаковым число, результат будет приведен к беззнаковому виду.

_Является ли корректным переполнение беззнакового числа?_

Да, оно полностью корректно, так как это полностью определенное поведение. Если мы перполняемся со стороны нуля, то это значит, что на выходе будет огромное число (верхний предел используемого беззнакового типа) минус число, на которое идет переполнение. А если идет верхнее переполнение, то результат просто обращается в ноль.

Но при этом стоит помнить, что переполнение знакового числа, это всегда **UB**.

Но если делать приведение к `long long`:

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    std::cout << (25u - 52ll) << std::endl;
    return EXIT_SUCCESS;
}
```

И вывод будет:

```C++
-27
```

Потому что приводится всегда к большему типу, либо к числу с плавающий точкой.

---

## Вопрос второй.

Расскажите про порядок инициализации, в следующем коде:

```C++
\#include <iostream>

struct Data
{
    explicit Data(const std::string type)
        : m_type{type}
    {
        std::cout << "Data: " << m_type << std::endl;
    }

    ~Data()
    {
        std::cout << "~Data: " << m_type << std::endl;
    }

private:
    std::string m_type;
};

Data global_data{"global"}; // (1)
static Data global_static_data{"global static"}; // (2)

void func()
{
    static Data global_static_data{"local static"}; // (3.1)
}

int main(int argc, char** argv)
{
    std::cout << "main" << std::endl;

    func(); // (3)
    func();
    func();

    Data local_data_1{"local 1"}; // (4)
    Data local_data_2{"local 2"}; // (5)

    std::cout << "main" << std::endl;
    return EXIT_SUCCESS;
}
```

Сначала будут создаваться глобальные переменные. И только потом все, что находится в `main()`. Глобальные переменные создаются до входа в `main()` и разрушаются после выхода из `main()`.

_Дополнение:_

Их порядок был бы не определен, если бы переменные находились в разных юнитах трансляции.

---

## Вопрос третий.

Что выведет следующий код:

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    int array[8] = {1, 1, 1, 1, 1, 1, 1, 1};

    int8_t* pointer = (int8_t*) array;
    pointer += 3;

    std::cout << (int)*pointer << std::endl;
    return EXIT_SUCCESS;
} 
```

```C++
0
```

Посмотрим, как наш `array` мы чаще всего рисуем у себя в голове:

![[array-in-memory.svg]]

Первые два элемента массива.

Но точно ли так в реальности представляется наше значение в единицу?

Есть такая концепция, как порядок байтов (_Endianness_). И картинка выше отображает порядок байт типа _Little Endian_.

Но на многих системах процессоры поддерживают именно второй тип порядка, это _Big Endian_ (от старшего к младшему).

И соответсвенно картина будет выглядеть так:

![[array-in-memory-big-endian.svg]]

И именно при таком порядке, наш указатель `pointer += 3;` будет указывать на ноль. Но при этом, если сделать `pointer += 4;` , то выглядеть это будет так:

![[array-in-memory-big-endian-2.svg]]

  

И вывод нашего кода будет:

```C++
1
```

---

## Вопрос четвертый.

Сколько раз выведется значение в следующем коде:

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    for (uint8_t i = 0u; i < 260; ++i)
    {
        std::cout << (int)i << std::endl;
    }

    return EXIT_SUCCESS;
}
```

_Ответ_:

**Бесконечно будет выводиться данное значение.**

Потому что при переполнении беззнакового числа, оно просто приравнивается к нулю.

---

## Вопрос пятый.

Сколько раз выведется значение в следующем коде:

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    unsigned char count{128};
    for (unsigned char i = 0; i < (unsigned char)(count << 1); ++i)
    {
        std::cout << (int)i << std::endl;
    }

    return EXIT_SUCCESS;
}
```

_Ответ_:

**Ничего не выведется.**

В данной задаче стоит вспомнить про степени двойки и как они представляются в бинарном виде:

$0000\ 0001\ =\ 1$﻿

$0000\ 0010\ =\ 2$﻿

$0000\ 0100\ =\ 4$﻿

$0000\ 1000\ =\ 8$﻿

$\dots$﻿

$1000\ 0000\ =\ 128$﻿

А соответственно если у нас произойдет операция $1000\ 0000\ <<\ 1$﻿ то случится переполнение беззнакового числа, и на месте этой операции просто будет ноль.

_Дополнительный вопрос:_

А что выведет следующий код:

```C++
\#include <iostream>

int main(int argc, char** argv)
{
    unsigned char count{128};
    for (unsigned char i = 0; i < (count << 1); ++i)
    {
        std::cout << (int)i << std::endl;
    }

    return EXIT_SUCCESS;
}
```

_Ответ_:

**Будет бесконечный цикл, потому что число привелось к int.**

---

## Вопрос шестой.

_Вопрос:_

Будет ли что-то происходить в циклах `while`?.

```C++
\#include <iostream>

int buffer_full; // Уточнение: Глобальные переменные всегда инициалиализируются
                 //            нулями. Только в локальных может быть 
                 //            какой-то мусор.

int read_stream()
{
    int count{0};
    while (!buffer_full)
    {
        count++;
    }

    return count;
}

volatile int buffer_full_volatile;
int read_stream_volatile()
{
    int count = 0;

    while (!buffer_full_volatile)
    {
        count++;
    }

    return count;
}

int main(int argc, char** argv)
{
    return EXIT_SUCCESS;
}
```

В первом цикле `while (!buffer_full)` аргумент `!buffer_full` , так как переменная глобальная не инициализированная - будет нулем, то и `!buffer_full == true` . Но так как дальше по коду `buffer_full` нигде не меняется, компилятор может использовать оптимизацию, и привести первый цикл к следующему виду: `while (false)`.

Но при этом переменная `buffer_full_volatile` помечена как `volatile` . Это дает гарантию, что компилятор не будет использовать на ней каких-то оптимизаций и на коде, который с ней работает, и оставит её не тронутой.

Часто такое нужно, когда переменная будет использоваться из другого потока, и что бы компилятор её не затер, используется `volatile`.

**Ничего общего с атомарностью,** `**volatile**` **не имеет.**

---

## Вопрос седьмой.

_Вопрос:_

Расскажите, в чем разница?.

```C++
int main(int argc, char** argv)
{
		int value{100};

		const int* const_int_ptr = &value;
		int const* int_const_ptr = &value;
		int* const int_ptr_const = &value;
	  const int* const const_int_ptr_const = &value;

    return EXIT_SUCCESS;
}
```

1. `const int*` - другими словами, указатель на константу.
    
    `*const_int_ptr = 200;` - Не отработает. Нельзя будет изменить значение по этому указателю.
    
    `const_int_ptr = nullptr;` - Отработает. Можно будет поменять место, куда указывает указатель.
    
2. `int const*` - тоже указатель на константу. Идентичен пункту **1.**
3. `int* const` - это уже константный указатель.
    
    `*int_ptr_const = 200;` - Отработает. Можно будет поменять значение по этому указателю.
    
    `int_ptr_const = nullptr;` - Не отработает. Нельзя поменять то, на что указывает данный указатель
    
4. `const int* const` - константный указатель на константу.
    
    `*int_ptr_const = 200;` - Не отработает. Нельзя будет поменять значение по этому указателю.
    
    `int_ptr_const = nullptr;` - Не отработает. Нельзя поменять то, на что указывает данный указатель
    

_Дополнительный вопрос:_

В чем разница между _ссылкой_ и _указателем_?

- Указатель может быть нулевым (`nullptr`), ссылка не может быть не инициализированной.
- Можно создать массив указателей, но нельзя создать массив ссылок.
- Арифметика указателей существует только для указателей. Для ссылок никаких арифметик нет.

---

## Вопрос восьмой.

_Вопрос:_

У нас есть следующий код, что в нем не так?

```C++
\#include <iostream>

void shared_library_method_1()
{
		std::cout << "shared_library_method_1" << std::endl;
}


extern "C" int* shared_library_method_2()
{
		std::cout << "shared_library_method_2" << std::endl;
		return new int{1'000}; 
}
```

_Условия:_

Данный код написан на `С++` и будет собран в переносимую библиотеку. С ним будут работать при помощи `C`.

- Если скомпилировать код выше без линковки, и просто вывести его в терминал, мы увидим, что для функции `shared_library_method_1()` компилятор добавил рандомных знаков в имя функции. Это называется _name mangling_ и нужно для правильной работы перегрузки.
    
    А так как чистый язык `C` не поддерживает _name mangling_, соответственно будет ошибка линковки при обращении к методу `shared_library_method_1()` .
    
    А вот при обращении к методу `shared_library_method_2()` будет все нормально, потому что явно задан `extern “C”`, который защищает от _name mangling_.
    
- Вторая ошибка в том, что чистый `C` не знает, что такое `new` . А значит упадет с ошибкой. Нужно будет писать выделение памяти через `malloc()`.

---

## Вопрос девятый.

_Вопрос:_

Для чего нужны `static` функции? Для чего нужны анонимные `namespace`?

```C++
\#include <iostream>

static void print_1()
{
		std::cout << "Hello from static function" << std::endl;
}

namespace
{

void print_1()
{
		std::cout << "Hello from anonymous namespace function function" << std::endl;
}
		
} // namespace

int main(int argc, char** argv)
{
		print_1();
		print_2();

    return EXIT_SUCCESS;
}
```

Функция, которую мы никак не помечаем, по дефолту, идет как `extern`. Это значит, что функция будет видна на уровне всех файлов в проекте.

Но если мы хотим оформить инкапсуляцию на уровне файлов (не выходить за пределы единицы трансляции), то функцию надо обозначить как `static`. Значит, извне нельзя вызвать эту функцию.

Это был старый способ, более подходящий для старого `C`.

В языке `C++` больше прижился подход анонимных `namespace` , так как к анонимному `namespace` будет применяться _name mangling_ от компилятора - доступен он будет только в своей же единице трансляции.