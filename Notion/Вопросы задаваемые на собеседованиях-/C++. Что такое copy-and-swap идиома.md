## Обзор проблемы:

Любой класс, который управляет ресурсом (любая обертка, или, к примеру, умный указатель) должен соблюдать [[С++. Что такое The Rule of Three]]или [[С++. Что такое The Rule of Three]]. В то время, когда цели и реализация _Конструктора Копирования_ или _Деструктора_ может быть понятна, то вот _Оператор Присваивания_ - такая сущность, где часто не интуитивно понятны подводные камни, и многие нюансы. Как правильно очистить объект в который производится копирование? Правильно ли произведено копирование? И так далее.

Поэтому была придумана идиома _copy-and-swap_. Довольно элегантное решение, помогающее в правильной реализации _Оператора Присваивания_, она предотвращает дублирование кода и предоставляет гарантию относительно исключений.

### Как это работает?

Концептуально, это выглядит следующим образом: создаем локальную копию объекта, который передан в _Оператор Присваивания_, локально сохраняем её. И потом эту локальную копию меняем местами с оригинальными данными, при помощи функции $swap$﻿_._ Локальная копия (которая после функции $swap$﻿ содержит старые данные, находившиеся в объекте) после выхода из области видимости _Оператора Присваивания_ просто уничтожаются.

Коротко говоря, базовый набор инструментов, нужный для реализации _copy-and-swap_ идиомы - это работающий _Оператор Присваивания_ и _Деструктор_ (оба метода это основа любой обертки), и соответственно функция $swap$﻿_._

$swap$﻿ - это не выкидывающая исключений функция, которая меняет местами два объекта класса. Обычно лучше всего использовать уже готовую $std::swap$﻿, но так как она использует _Оператор Присваивания_ и _Конструктор Копирования_ (которые мы и хотим реализовать для нашей обертки), то придется реализовывать свою функцию.

---

## Детальный разбор:

Посмотрим как это все работает на примере. Мы хотим создать обертку для динамического массива. Для начала мы сделали работющий обычный _Конструктор_, _Конструктор Копирования_ и _Деструктор_.

```C++
\#include <algorithm>

class wrapper
{
public:
    // Обычный конструктор 
    wrapper (size_t size = 0)
        : m_sSize{size}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
    }

    // Конструктор Копирования
    wrapper (const wrapper& other)
        : m_sSize{other.m_sSize}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
				// Обратим внимание, что функция std::copy() не выбрасывает исключений
        // так как, использованы примитивные типы данных. Если будут использованы
        // более сложные типы (к примеру, итераторы) - нужно дополнительное 
        // внимание к работе с ними.
        std::copy(other.m_pArray, other.m_pArray + m_sSize, m_pArray);
   }

    // Деструткор
    ~wrapper()
    {
        delete [] m_pArray;
    }

private:
    size_t m_sSize;
    int*   m_pArray;
};
```

Что бы полностью реализовать [[С++. Что такое The Rule of Three]] нам нужно еще добавить определение для _Оператора Присваивания_.

### Наивное, неправильное решение:

Добавим в наш пример класса $wrapper$﻿ метод $operator=(...);$﻿.

```C++
\#include <algorithm>

class wrapper
{
public:
    // Default constructor
    wrapper (size_t size = 0)
        : m_sSize{size}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
    }

    // Copy constructor
    wrapper (const wrapper& other)
        : m_sSize{other.m_sSize}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
        std::copy(other.m_pArray, other.m_pArray + m_sSize, m_pArray);
    }

    // Assignment operator (Wrong Part)
    wrapper& operator= (const wrapper& other)
    {
        if (this != &other)                                                 // [1]
        {
            // Delete all old data
            delete [] m_pArray;                                             // [2]
            m_pArray = nullptr;                                             // [2]

            m_sSize = other.m_sSize;                                        // [3]
            m_pArray = m_sSize ? new int[m_sSize] : nullptr;                // [3]
            std::copy(other.m_pArray, other.m_pArray + m_sSize, m_pArray);  // [3]
        }
        return *this;
    }

    // Destructor
    ~wrapper()
    {
        delete [] m_pArray;
    }

private:
    size_t m_sSize;
    int*   m_pArray;
};
```

Предположим, что мы закончили, [[С++. Что такое The Rule of Three]] соблюдено, но теперь наш код страдает от трех проблем:

1. Во-первых, это проверка на присваивание самому себе. Данная проверка служит двум назначениям: Первое - это простой способ для предотвращения запуска ненужного кода при присваивание самому себе, ведь если объект является так же объектом, зачем выделять память, затирать указатели и так далее. Но в реальном коде, чаще всего эта проверка засоряет код и замедляет. Второе - защита от бага, где будет удалена вся выделенная динамически память (потенциально, двойное удаление в деструкторе), хотя это просто была попытка скопировать объект.
2. Во-вторых, такой вариант реализации предоставляет только лишь основную гарантию относительно исключений. Если $new \ int[m\_sSize]$﻿ выдаст исключение, то $m\_sSize$﻿ останется старого размера, а динамические данные уже удалятся к этому времени. И для того, что бы гарантировать полную безопасность относительно исключений, нужно: 
    
    ```C++
    wrapper& operator=(const wrapper& other)
    {
        if (this != &other)                                            // [1]    
        {
            // Нужно сначала менять размер, и только потом удалять старые данные
            std::size_t newSize = other.m_sSize;
            // Так же стоит создать локальную переменную
            int* newArray = newSize ? new int[newSize]() : nullptr;         // [3]
            std::copy(other.m_pArray , other.m_pArray + newSize, newArray); // [3]
    
            // Удаляем старые данные
            delete [] mArray;
            m_sSize= newSize;
            m_pArray = newArray;
        }
    
        return *this;
    }
    ```
    
3. В-третьих, теперь наш код сильно разросся, что приводит к проблеме дублирования и грязи в коде.

Если считать, что версия из пункта два - законченная, то скорее всего где-то в дальнейшем коде нашего класс, это все будет дублироваться по нескольку раз. Все эти проверки и так далее.

Конкретно, в нашем, легком случае, это дублирование - всего несколько строк (хотя все равно не приятно), но работай наш $wrapper$﻿ с чем-то сложнее, чем указатель на массив, код усложнился бы насколько, что его было бы тяжело читать. А если еще и надо будет управлять не одним ресурсом, а к примеру, пятью - страшно представить что случится с этим оператором.

### Удачное решение задачи:

Как упоминалось ранее, идиома _copy-and-swap_ отлично справляется с проблемами, описанными в пунктах [1] - [3] выше. Но, единственное, чего на данном этапе реализации нашего класса $wrapper$﻿ - нам не хватает функции $swap$﻿. Поэтому, учитывая, что для реализации _Оператора Присваивания_ нам нужна отдельная функция, можно смело вводить наше собственное правило: “Правило Трех с Половиной”.

```C++
Каждый раз, когда класс управляет ресурсом надо пользоваться Правилом Трех,
и реализовывать для него функцию swap();
```

Функцию $swap$﻿ реализуем в нашем классе, следующим образом:

```C++
class wrapper
{
public:
		...
		friend void swap(wrapper& first, wrapper& second) // Не выкидывает исключения
		{
				// Включаем явно ADL
				using std::swap;
				
				// Меняем местам, все поля класса wrapper
				swap(first.m_sSize, second.m_sSize);
				swap(first.m_pArray, second.m_pArray);
		}
		...
};
```

Вот [[C++. Почему в copy-and-swap идиоме, swap - это friend функция]]на объяснение, почему же $swap$﻿ это $friend$﻿-функция.

Теперь у нас не только, в целом, появилась возможность производить $swap$﻿ для объектов типа $wrapper$﻿, но и не стоит забывать, что функция перестановки местами местами объектов - очень эффективная и экономная. По своей сути она просто переставляет указатели с объекта на объект, не аллоцируя никакой дополнительной памяти. В дополнению, к вышеописанному - код стало легко читать.

Что получилось в конечном итоге:

```C++
\#include <algorithm>

class wrapper
{
public:
    // Default constructor
    wrapper (size_t size = 0)
        : m_sSize{size}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
    }

    // Copy constructor
    wrapper (const wrapper& other)
        : m_sSize{other.m_sSize}
        , m_pArray{m_sSize ? new int[m_sSize]() : nullptr}
    {
        std::copy(other.m_pArray, other.m_pArray + m_sSize, m_pArray);
    }

    // Assignment operator
    wrapper& operator= (wrapper other)
    {
        swap(*this, other);

        return *this;
    }

    friend void swap(wrapper& first, wrapper& second) // Nothrow
    {
        // enable ADL (not necessary in our case, but good practice)
        using std::swap;

        // By swapping the members of two objects,
        // the two objects are effectively swapped
        swap(first.m_sSize, second.m_sSize);
        swap(first.m_pArray, second.m_pArray);
    }

    // Destructor
    ~wrapper()
    {
        delete [] m_pArray;
    }

private:
    size_t m_sSize;
    int*   m_pArray;
};
```

### Почему это работает?

В примере выше, есть одна недоработка, в оператор $operator=$﻿ класса $wrapper$﻿ передача аргумента идет по значению. Поэтому доработаем немного наш оператор:

```C++
wrapper& operator= (const wrapper& other)
{
		wrapper temporary(other);
		swap(*this, temporary);

		return *this;
}
```

Метод показанный выше, ограничивает нас от повторного использования кода, так как, используется код, написанный в _Конструкторе Копирования_. И как только копия готова - мы можем поменять местами объекты.

Так же такой вариант, дает нам полную защиту от изменений классового инварианта, потому что даже если и произойдет ошибка на строчке $wrapper \ temporary(other);$﻿ то до функции $swap $﻿ дело даже не дойдет, и не произойдет изменения $this$﻿.