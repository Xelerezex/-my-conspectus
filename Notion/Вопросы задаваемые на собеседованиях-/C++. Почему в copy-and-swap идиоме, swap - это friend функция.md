Существует несколько способов написать, казалось бы, такую простую функцию, как $swap$﻿. Рассмотрим, как пришли к версии с $friend$﻿.

---

Впервые увидев контейнер типа $std::vector<>$﻿, мы замечаем у него метод $swap$﻿.

```C++
class vector
{
		void swap(vector &) { /* Swapping members*/ }
}
```

Складывается впечатление, что и наши самописные классы тоже должны иметь такую функцию? Нет, не должны.

---

Что мы должны сделать, так это определить, какой же подход считается каноничным, и как наш класс будет работать в этом случае. И самый каноничный метод обмена объектами - это функция $std::swap$﻿.

Но для того, что бы работать с этой функцией, мы должны предоставить её реализацию.

```C++
namespace std
{
		template <>
    void swap (myClass&, myClass&)
		{
				/* swapping methods */
		}
}
```

Такой вариант, в принципе, будет работать, но проблема в том, что это слишком узкоспециализированный метод. И класс вектора - шаблонный.

```C++
namespace std
{
		template <typename T>
    void swap<T> (myClass<T>&, myClass<T>&) // Будет ошибка, нет частичной
		{                                       // специализации
				/* swapping methods */
		}
}
```

Вариант выше иногда будет работать, но он не очень хорош.

---

И хороший вариант так или иначе, нашелся!

Мы можем использовать $friend$﻿-функцию, и поиск через [[C++. Что такое ADL]].

```C++
namespace smth
{
		class myclass
		{
				friend void swap(myclass&, myclass&);
		}
}
```

Когда мы хотим поменять что-то местами, мы ассоциируем $std::swap$﻿ в нужном пространстве имен, и потом производим [[С++. Что такое Unqualified name lookup]] с ADL.

```C++
friend void swap(myclass&, myclass&)
{
		using std::swap;  // Позволяем использование функции из std, std::swap
		swap(x, y);       // Но здесь происходит магия ADL, и сначала будет искаться
                      // функция ::swap(myclass&, myclass&); - и сели она не будет 
										  // найдена - то уже вызовется std::swap.
}
```

---

Пока C++ не был стандартизирован, функция $friend$﻿ делала, то, что раньше называлось “friend name injection”. И функция вела себя так, будто была написана в одном пространстве имен с классом.

```C++
struct foo
{
    friend void bar()
    {
        // baz
    }
};

// Это было, считай, две одинаковые операции:

struct foo
{
    friend void bar();
};

void bar()
{
    // baz
}
```

В то же время, когда был придуман ADL - эта инъекция была **удалена**. Теперь $friend$﻿-функция может быть найдена только через ADL.

Отсюда идет некоторые нюансы. Если вызвать из функции $swap$﻿ следующее выражение $std::swap(x, y);$﻿ - наше переопределение никогда не будет найдено. Так как мы явно указываем, что искать надо в $std$﻿, и нигде иначе.