Текстуры испоользуются для того, что бы передать реалистисную картинку и при этом не создавать огрумное количество вертексов.

Для того, что бы намазать текстуру на треугольник из прошлого примера - надо будет задать текстурные координаты для каждой из вершин треугольника. Это нужно для правильного мапинга текстуры на треугольник.

Текстурные координаты имеют рендж от 0 до 1 и только оси **x** и **y**. Получениеи цвета, записанного в текстуре используя ее координаты - называется сэмплингом.

Отображение текстурных координат происходит с точки (0, 0) - которая располагается в левом нижнем углу

![[textures_coordinates.png]]

Намазка текстуры на треугольник

Исходя из этой информации, для того, что бы задать текстуру для треугольника, надо задать три Текстурные Координаты

```C++
float textureCoordinate[] = {
		0.0f, 0.0f, // lower-left corner
		1.0f, 0.0f, // lower-right corner
		0.5f, 1.0f  // top-center corner
};
```

Дальше алгоритм сам интерполирует все цвета с текстуры на треугольник, нам останется лишь сказать **OpenGL** какой вариант сэмплинга стоит использовать.

### Завертываение фигуры в Текстуру.

Обычно текстура мапится с (0, 0) на (1, 1), но что случится если мы зададим координаты вне этого рейнджа?

Дефолтная установка для OpenGL в таком случае будет - просто повторять картинку текстуры.

Но есть и другие варианты работы:

- `GL_REPEAT` - повторять изображение (ставится по дефолту).
- `GL_MIRRORED_REPEAT` - примерно тоже самое, что и **GL_REPEAT**, только изображения отзеркаливаются
- `GL_CLAMP_TO_EDGE` - самые верхние координаты текстуры размазываются на оставшееся пространство.
- `GL_CLAMP_TO_BORDER` - незадействованому пространству просто дается цвет задаваемый пользователем.

Выглядит это примерно так:

![[texture_wrapping.png]]

Каждая из описанных выше опций может быть засечена на каждую координатную ось:

(на **s**, **t** или **r** - если текстура в 3D, это полный эквивалент **x**, **y**, **z**) при помощи функции `glTexParameter*` :

```C++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

Параметры данной функции:

- `GL_TEXTURE_2D` - задаем тип текстуры 3D или 2D.
- `GL_TEXTURE_WRAP_S` - какую опцию мы хотим задать и для какой оси.
- `GL_MIRRORED_REPEAT` - как раз таки тип для размазывания структуры.

Если эе мы выберем опцию `GL_CLAMP_TO_BORDER`, то надо будет еще задать цвет, который будет отображаться не в текстуре:

```C++
float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);  
```

### Фильтрация текстур

Текстурные координаты не зависят от разрешения монитора и могут быть любым дабловым значением, поэтому OpenGL нужно сделать выбор с каким текстурным пикселем (или по другому текселем) смапить текстурные координаты. Данные вопрос встает довольно часто - когда слежует намазать текстуру небольшого разрешения на большой объект. Собственно таким мапингом и занимается механизм **Фильтрации Текстур**. В этом направлении ест ьмного опций, но мы рассмотрим только две основные:

- `GL_NEAREST`: (по другому - ближайщий сосед или точечная фильтрация) - дефолтный метод текстурной фильтрации в OpenGL. В этом случае OpenGL просто выбирает текстель чей центр ближе всех находится к текстурной координате. Ниже можно увидеть 4 пикселя и крест, который реперзентует собой текстурную координату. Левый верхний тесель имеет центр ближе всех расположенный к структурной координате, поэтому он и выбирается.
	
    ![[filter_gl_nearest.png]]

- `GL_LINEAR`: (по другому - (би)линейный фильтр) берет интерполируемое значение из соседствующий текстелей относительно текстурной координаты и апроксимирует цвет. Чем ближе центр текселя к текстурной координате, тем “больше” данного цвета будет в конечном результате.
    
    ![[filter_gl_linear.png]]
    

Пример того, как будет работать та или иная фильтрация:

![[texture_filtering.png]]

`GL_NEAREST` - дает более пиксельный вариант картинки.

`GL_LINEAR` - напротив дает более смазаный вариант.

Текстурные фильтры могут быть выставлены на Увеличение (magnifying) и Уменьшение (minifying) операций (скейлинг вверх или вниз). Поэтому к примеру можно использовать фильтрацию по ближайшему соседу вниз и линейную фильрацию по верхним значениям. Для этого служит следующая функция:

```C++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

### МипМапы

Представим, что у нас есть огромная комната с тысячами объектов, к каждому из которых - привязана текстура. Из-за того, что комната большая сложится такая ситуация, что будут объекты которые будут ближе к пользователю и те, которые будут дальше от него (при это мы предполагаем что текстура будет высокого разрешения). И у OpenGL наблюдается проблема с получением правильного значения цвета для фрагмента из текстуры с высоким разрешением, поскольку ему приходится выбирать цвет текстуры для фрагмента, который охватывает большую часть текстуры.

Из-за данной проблемы на маленьких объектах появляются артефакты и так же слишком большой перерасход памяти на намазывание текстур в высоких разрешениях на маленькие объекты.

Для решения как раз таки такого рода проблем и используется механизм **Пиксмапов**.

Пиксмапы, это, по факту, коллекции текстурных изображений где каждая поледующая текстура вдвое меньше в сравнении с предыдушей.

Ключевая идея такого механизма в том, что OpenGL, чем дальше будет объект от наблюдателя - тем меньше будет выбираться текстура из мипмапы на отрисовку. И тк объект далеко от наблюдателя - будет не заметно его зжавшееся разрешение.

Так же при таком подходе будет гораздо проще подобрать правильный тексели и для этого потребуется гораздо меньше памчти в кэше.

Визуально мипмапа выглядит так:

![[mipmaps.png]]

В ручную создавать коллекцию мипмапов - это тот еще геморой, к счатью в OpenGL существует под это готовая функция - `glGenerateMipmap`, которую слудеуте вызывать каждый раз сразу после загрузки новой текстуры.

При смене между уровнями мипмапам во время рендереинга OpenGL могут возникать всякие артифакты типа видимых острых углов бежду уровнями. Как и в обычном текстурном фильтеренге - можно без проблем фильтровать и переходы уровней мипмап при помощи `NEAREST` и `LINEAR`.

- `GL_NEAREST_MIPMAP_NEAREST` - Выбирает ближайщий мипмап, соотносящийся с размером пикселя и так же использует интерполяцию на ближайшего соседа для правильног осемплинга текстур.
- `GL_LINEAR_MIPMAP_NEAREST` - выбирает ближайший мипмап и сэмплирует его методом линейной интерполяции.
- `GL_NEAREST_MIPMAP_LINEAR` - Линейная интерполяция между двумя ближайшими мипмапами и сэмплирование текстур с помощью линейной интерполяции.

```C++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

### Генерация структуры

После того, как мы загрузили удобным образом картинку с текстурой - следует сгенерировать и саму текстуру.

Данный процесс как и принято в OpenGL работает на айдишниках.

```C++
unsigned int texture;
glGenTextures(1, &texture);
```

Число `1` - это количество структур, которые надо сгенерировать. И айдишник запоминается в лист типа `unsigned int`, в нашем же случае это будет лишь один элемент - `texture`.

Потом как и при работе с другими объектами - байндим только что созданный объект текстуры.

```C++
glBindTexture(GL_TEXTURE_2D, texture);
```

Теперь, когда текстура сбайнжена мы можем записать в нее, загруженные ранее данные. Это делается при помощи основного метода `glTexImage2D`.

```C++
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
glGenerateMipmap(GL_TEXTURE_2D);
```

- Первый аргумент - тип загружаемой текстуры. Тут он установлен как `GL_TEXTURE_2D`, поэтому текстуры, которые связаны `GL_TEXTURE_1D` или `GL_TEXTURE_3D` никак не будут затронуты.
- Второй аргумент - мипмапа, которую мы сами сгенерировали и хотим использовать. Но тк мы идем по пути генерации МипМапы при помощи OpenGL - ставим нуль.
- Третий аргумент - формат хранения текстуры. Тк наша загруженная картинка имеет только значения типа **RGB** - ставим значение `GL_RGB`.
- Четвертый аргумент - ширина текстуры.
- Пятый аргумент - высота текстуры.
- Шестой аргумент - граница, хз что это такое, какая-то легасятина. Должно быть нуль.
- Седьмой аргумент - формат исходного изображения.
- Восьмой аргумент - тип данных исходного изображения.
- Девятый аргумент - указатель на сами данные изображения

После того, как функция `glTexImage2D` была вызвана - картинка стала связанной с текстурой, но так как мы хотим еще импользовать мипмапы надо дернуть функцию `glGenerateMipmap`. Данна функция сгенерирует автоматическую мипмапу для любой текстуры, которая сейчас забайнджена.

Полная генерация текстуры выглядит так:

```C++
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
// set the texture wrapping/filtering options (on the currently bound texture object)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
// load and generate the texture
int width, height, nrChannels;
unsigned char *data = stbi_load("container.jpg", &width, &height, &nrChannels, 0);
if (data)
{
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
    std::cout << "Failed to load texture" << std::endl;
}
stbi_image_free(data);
glBindTexture(GL_TEXTURE_2D, 0);
```

### Нанесение текстур на фигуры

Мы будем использовать прямоугольник для нанесения текстуры на него. Для этого зададим следующие вертексы:

```C++
// General vertices
constexpr std::array vertices = {
    // positions          // colors           // texture coords
     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // top right
     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // bottom right
    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // bottom left
    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // top left 
};
// General indexes
constexpr std::array<unsigned int, 6> indices = {  
    0, 1, 3, // first triangle
    1, 2, 3  // second triangle
};
```

Тк мы добавили новый атрибут в общие вершины, следует уведомить OpenGL об этом изменении.

![[vertex_attribute_pointer_interleaved_textures.png]]

И теперь задание атрибутов будет выглядеть так:

```C++
// position attribute
glVertexAttribPointer(
		0, // Same as (location = 0) in Vertex Shader
		3, // Size of Vertex Attribute. Only 3 Vertices like in vec3
		GL_FLOAT, // Type of data in 
		GL_FALSE, // Should data be normalized
		8 * sizeof(float), // Stride 32
		nullptr // Offset
);
glEnableVertexAttribArray(0);
// color attribute
glVertexAttribPointer(
    1, // Same as (location = 1) in Vertex Shader
    3, // Size of Vertex Attribute. Only 3 Vertices like in vec3
    GL_FLOAT, // Type of data in 
    GL_FALSE, // Should data be normalized
    8 * sizeof(float), // Stride 32
    reinterpret_cast<void*>(3 * sizeof(float)) // Offset 12
);
glEnableVertexAttribArray(1);
// texture coord attribute
glVertexAttribPointer(
    2, // Same as (location = 2) in Vertex Shader
    2, // Size of Vertex Attribute. Only 2 Vertices like in vec2
    GL_FLOAT, // Type of data in 
    GL_FALSE, // Should data be normalized
    8 * sizeof(float), // Stride 32
    reinterpret_cast<void*>(6 * sizeof(float)) // Offset 24
);
glEnableVertexAttribArray(2);
```

Так же под новый, только что добавленный атрибут, следует изменить и вертексный шейдер:

```C++
\#version 460 core

layout (location = 0) in vec3 aPosition;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTextureCoordinate;

out vec3 outColor;
out vec2 outTextureCoordinate;

uniform float xShift;

void main()
{
    gl_Position = vec4(aPosition.x + xShift, aPosition.y, aPosition.z, 1.0);
    outColor = aColor;
    outTextureCoordinate = aTextureCoordinate;
}
```

Фрагментный шейдер должен получать на вход координаты текстуры через переменную `outTextureCoordinate`. И так же он должен иметь доступ к текстурному объекту. Для этого **GLSL** имеет встроеный тип `sampler`, поэтому мы можем добавить текстурный объект прямо в фрагментарный шейдер по средствам задания `uniform sampler2D`.

```C++
#version 460 core

in vec3 inputColor;
in vec2 TextureCoordinate;

out vec4 FragmentColor;

uniform sampler2D inputTexture;

void main()
{                                                             
    FragmentColor = texture(inputTexture, TextureCoordinate);
}
```

Для семлинга цвета текстуры - мы использовали встроеную в **OpenGL** функцию `texture()`.

И теперь просто останется в методе отрисовки сбайндить нашу текстуру:

```C++
glBindTexture(GL_TEXTURE_2D, texture);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```

### Текстурный блок:

Для того что бы пропихнуть больше одной текстуры в **OpenGL** - следует явно через `glUniform1` задать локацию (_location_) для той или иной структуры, и тогда можно будет положить несколько структур на одну вертексную фигуру в вертексном шейдере.

Локация текстуры так же известна как Текстурный Блок или Текстурный Юнит. Дефолтный текстурный юнит для любой текстуры - 0, он собственно и выставляется **OpenGL**.

А и также стоит помнить, что не все видел-драйвера присваивают этот ноль по дефолту.

Основная идея текстурного юнита - пропихнуть несколько текстур в фрагментарный шейдер (скорее всего до 16), для этого надо активировать текстурный юнит до того момента, как будет байндится текстура.

```C++
glActiveTexture(GL_TEXTURE0); // activate the texture unit first before binding texture
glBindTexture(GL_TEXTURE_2D, texture);
```

После активации текстурного юнита последующий вызов `glBindTexture` прибайндит текстуру к активированному на данный момент текстурному юниту.

Что бы фрагментарный шейдер смог забрать еще одну структуру - все равно придется изменить фрагментарный шейдер:

```C++
#version 460 core

in vec3 outColor;
in vec2 outTextureCoordinate;

out vec4 FragmentColor;

uniform sampler2D inputTextureContainer;
uniform sampler2D inputTextureSmile;

void main()
{                                                             
    FragmentColor = mix(
        texture(inputTextureContainer, outTextureCoordinate) * vec4(outColor, 1.0f),
        texture(inputTextureSmile, outTextureCoordinate),
        0.2
    );
}
```

Теперь конечный цвет, получаемый в вертексном шейдере, получается при помощи интерполяции одной структуры на другую по средствам встроенной функции `mix()` и значению `0.2` - которое означает, что возьмется 80 процентов от цвета первой текстуры и 20 процентов цвета от второй.

И теперь останется просто прогнать пайплайн, который мы делали ранее для загрузки и отрисовки 1-ой структуры (только на этот раз надо не забыть активайцию текстуры перед первичным байндингом).