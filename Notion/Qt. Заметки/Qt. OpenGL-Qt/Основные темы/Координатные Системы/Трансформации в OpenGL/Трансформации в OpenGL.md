---

Данная заметка - перевод [вот этой](http://www.songho.ca/opengl/gl_transform.html#overview) статьи.

---

Геометрические данные, такие как вертексные позиции и нормали векторов трансформируются посредством _Вертексных Операций_ и _Примитивных Асемблов_ в **[[Обзор пайплайна OpenGL]]** перед процессом растеризации**.**

![[vertex_transformations.svg]]

Пайплайн вертексных трансформаций в **OpenGL**.

---

## Объектные Координаты

Это локальная координатная система объектов и точка отсчета с базовой ориентацией перед тес как какая-то трансформация применена.

Изначально объекты в коде, как раз и задаются в этой системе координат (от $-1.0$﻿ до $1.0$﻿).

Для трансформации объекта следует применять функции _**OpenGL**_ в следующем порядке: `glRotatef()`, `glTranslatef()`, `glScalef()`.

## Координаты Наблюдателя

Все объекты трансформируются из _**Объектной Системы Координат**_ в _**Координаты Наблюдателя**_ при помощи _Матрицы Модели-Представления_. _Матрица Модели-Представления_ - это комбинация двух Матрицы: _Матрицы Модели_ и _Матрицы Представления_: $M_{view} \cdot M_{model}$﻿.

_Матрица Модели_ нужна для преобразования из _**Пространства Объектных Координат**_ в _**Мировые Координаты**_, а _Матрица Представления_ трансформирует из _**Мировых Координат**_ в _**Координаты Наблюдателя**_.

$\begin{pmatrix} $

Обратим внимание, что в спецификации OpenGL не существует отдельной матрицы (_вида, представляения_) для Камеры. Следовательно, для того что бы симулировать преобразование Камеры или Вида (вращения вокруг объектов и тд), сцена (3D объекты и свет) должны быть трансформированы с инвертированной _Матрицей Вида_.  
Другими словами, камера всегда находится в точке  
$(0, 0, 0)$﻿ и смотрит по оси $\textcolor{\#4287FF}{-Z}$﻿ в _**Координатах Наблюдателя**_ и никакие транфсформации не могут быть применимы к ней.

Нормальные вектора также трансформируются из _**Объектных Координат**_ в _**Координаты Наблюдателя**_ для дальнейших вычислений Света. Обратим внимание, что нормальные вектора трансформируются другим образом, нежели в случаяе с простыми Объектными Координатами (показано выше). Умножение происходит между транспонированной обратной матрицей и [[Трансформации Векторов Нормали]]

[[Трансформации Векторов Нормали]]

$\begin{pmatrix} $

## Координаты Отсечения

После всех преобразований выполненых в Координатах Наблюдателя - далее Вершинные Координаты будут умножаться на Матрицу Проекции - это трансформация переведет их в Координаты Отсечения. Эта Матрица Проекции определяет угол обзора (Учеченную Пирамиду), как вертексные данные проецируются на экран (ортографически или в перспективе). А причина по которой данные координаты называеются - координатами отсечения состоит в том, что все Вертексные данные на этом этапе сравниваются с $\pm w$﻿, и все чт оне попадает в этот диапазон - отсекается.

$\begin{pmatrix} $

## Нормализованные Координаты Устройства

Данные координаты получаются посредством _Перспективного Деления_ результатов прошлого шага пайплайна преобразований на $w$﻿. Диапазон значений сейчас для одной точки - от $-1.0$﻿ до $1.0$﻿.

$\begin{pmatrix} $

## Координаты Окна (Экранные Координаты)

Теперь, после прошлого шага пайплайна, следует сделать завершающую трансформацию и отобразить Вертексные Вершины, которые находятся в координатах _**NDC**_ на реальные пиксели Монитора. До этого Вертексные Вершины скалировались и транслировались так, что бы попасть на экран, что бы в дальнейшем проходя [[Обзор пайплайна OpenGL]] стать фрагментом. Функция `**glViewport()**` на этом этапе используется, что бы задать прямоугольник окна отрисовки, где конечная картинка будет отображаться. А так же функция `**glDepthRange()**` используется для определения параметра $\textcolor{\#4287FF}{Z}$﻿ величины в Координатах Окна.

Можно сказать, что координаты окна задаюся двумя функциями:

```C++
glViewport(x, y, w, h);
glDepthRange(n, f);
```

Так:

$\begin{pmatrix} $

Формула [[Трансформация Окна Просмотра]]обычно сводится к линейному отношению между _**NDC**_ и _**Координатами Окна**_.

$\begin{cases}$

[[Трансформация Окна Просмотра]]

---

## Матрицы Трансформаций

**OpenGL** использует матрицы 4х4 для всех своих трансформаций. При этом любая матрица хранится просто как одномерный список в последовательном порядке, как они стоят в столбцах (не в строках!). Матрицу придется транспонировать, если потребуется сконвертировать её к обычному строчному формату.

В самом **OpenGL** выделяется 4 типа матриц: `GL_MODELVIEW`, `GL_PROJECTION`, `GL_TEXTURE`, и **GL_COLOR**. МОжно поменять тип матрицы, используя функцию `glMatrixMode()`.

$\begin{pmatrix}$

### Матрица Модель-Представление

Данная матрица является комбинацией двух матриц: Матрицы Модели и Матрицы Представления.

Для того, что бы трансформировать Представление (Камеру), надо будет сдвинуть целую сцену при помощи обратной трансформации. Функция `gluLookAt()` как раз-таки и используется для задания трансформации Представления.

![[model_view_matrix.svg]]

4 Колонки матрицы Модель-Представление

Три элемента в самой правой колонке $(\textcolor{\#4D4D4D}{m_{12}}, \textcolor{#4D4D4D}{m_{13}}, \textcolor{#4D4D4D}{m_{14}}) $﻿ нужны для выполнения трансляции, посредствам функции `glTranslatef()`$.$﻿ Элемент $m_{15}$﻿ - это [[Гомогенные Координаты]], которая будет использоваться в дальнейшем для _**Проекционной Трансформации**_.

Три множества элементов: $(\textcolor{\#FF3333}{m_{0}}, \textcolor{#FF3333}{m_{1}}, \textcolor{#FF3333}{m_{2}}) $﻿, $(\textcolor{\#4D9900}{m_{4}}, \textcolor{#4D9900}{m_{5}}, \textcolor{#4D9900}{m_{6}}) $﻿, $(\textcolor{\#4287FF}{m_{8}}, \textcolor{#4287FF}{m_{9}}, \textcolor{#4287FF}{m_{10}}) $﻿ нужны здесь для Евклидова и аффинных преобразований, таких как поворот `glRotatef()` или же скалирование `glScalef()`.  
Стоит обратить внимание, что 3 этих множества, так же представляют собой ортогональные оси:  

- $(\textcolor{\#FF3333}{m_{0}}, \textcolor{#FF3333}{m_{1}}, \textcolor{#FF3333}{m_{2}}) $﻿ - это ось $\textcolor{#FF3333}{+X}$﻿, левый вектор, значения $(\textcolor{#FF3333}{1}, \textcolor{#FF3333}{0}, \textcolor{#FF3333}{0}) $﻿ по дефолту
- $(\textcolor{\#4D9900}{m_{4}}, \textcolor{#4D9900}{m_{5}}, \textcolor{#4D9900}{m_{6}}) $﻿ - это ось $\textcolor{#4D9900}{+Y}$﻿, левый вектор, значения $(\textcolor{#4D9900}{0}, \textcolor{#4D9900}{1}, \textcolor{#4D9900}{0}) $﻿ по дефолту
- $(\textcolor{\#4287FF}{m_{8}}, \textcolor{#4287FF}{m_{9}}, \textcolor{#4287FF}{m_{10}}) $﻿ - это ось $\textcolor{#4287FF}{+Z}$﻿, левый вектор, значения $(\textcolor{#4287FF}{0}, \textcolor{#4287FF}{0}, \textcolor{#4287FF}{1}) $﻿ по дефолту

Мы можем напрямую создать _матрицу Модель-Представление_ при момощи углов поворота и вектора $lookAt$﻿ без использования вшитых в OpenGL трансформационных функций.

Основная теоретическая справка, которую надо знать для этого:

[[Поворот на угол относительно осей]]

[[Вектор $lookAt$ относительно оси]]

[[Вращение вокруг произвольной Оси]]

[[Из Кватернионов к Матрице Вращения]]

Обратим внимание, что OpenGL исполняет матричное умножение в обратном порядке, если немколько трансформаций применяются к Вершине. К примеру, если Вершина трансформируется на $M_{A}$﻿ сначала, и потом трансформируется на $M_{B}$﻿ OpenGL представит это как $M_{B} \times M_{A}$﻿ и только потом умножит результат данного перемножения на вершину.

То есть последняя трансформация идет первой и первая трансформаци идет последней:

$v'\ =\ $

### Матрица проекции

Матрица проекции типа GL_PROJECTION используется для задания Усеченной Пирамиды. Данная Усеченная Пирамида, определяет, какие вершины войдут в конечный рендер, а какие будут отсечены, так же она определяет каким образом 3D сцена будет [[Математическа стоящая за Ортографической и Перспективной Проекцией]].

OpenGL сам предоставляет 2 функции для создания такой матрицы трансформаций. `glFrustum()` - что бы создать Проекцию Перспективы и функцию `glOrtho()` - для создания ортографической проекции. Обе функции предполагают, что им передадут 6 параметров, для задания Поверхности Отсечения: $\textcolor{\#ff3333}{left}, \textcolor{#ff3333}{right}, \textcolor{\#4D9900}{bottom}, \textcolor{#4D9900}{top}, \textcolor{\#4287FF}{near}, \textcolor{#4287FF}{far}$﻿:

![[perspective_frustum.svg]]

Вершины дальней ($\textcolor{\#4287FF}{far}$﻿) плоскости могут спокойно быть высчитаны через отношение подобных треугольников:

$\frac{\textcolor{\#4287FF}{far}}{\textcolor{#4287FF}{near}}$

Для ортографической проеции, данные соотношения будут равны $1$﻿, а значит значения$\textcolor{\#ff3333}{left}, \textcolor{#ff3333}{right}, \textcolor{\#4D9900}{bottom}, \textcolor{#4D9900}{top}$﻿ будут находится на одной плоскости.

![[orthographic_frustum.svg]]

### Текстурная Матрица

Текстурные координаты $(s, t, r, q)$﻿ умножаются на `GL_TEXTURE` матрицу перед любым текстурным наложением. По умолчанию, это идентификатор, поэтому текстура будет смаплена на объекты именно так, как мы зададим текстурные координаты. Модифицируя `GL_TEXTURE` можно добиться расширения/уменьшения, разворота или раздвижения структуры.

```C++
// rotate texture around X-axis
glMatrixMode(GL_TEXTURE);
glRotatef(angle, 1, 0, 0);
```

### Матрица Цвета

Цветовые компоненты (_r_, _g_, _b_, _a_) умножаются на матрицу типа `GL_COLOR`. Её можно использовать для преобразования цветового пространства и замены цветовых компонентов.  
  
`GL_COLOR` не очень часто используется и предполагает наличие расширения `**GL_ARB_imaging**`.