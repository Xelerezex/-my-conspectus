### Основные концепции.

В парадигме OpenGL все происходит в трехмерном пространстве, но мониторы могут показывать только 2D картинку, поэтому большая часть нагрузки приходится именно на трансформации всех 3D координат в 2D пиксели.

Трансформация всех 3D координат в 2D пиксели происходит по средствам **Пайплана OpenGL**.

Пайплайн может быть разбит на 2 основных концептуальных действия:

1. Трансформация всех 3D координат в 2D координаты.
2. Трансформация 2D координат в раскрашенные пиксели.

Данные 2 основных действия пайплайна можно также разбить на несколько шагов. Вся эта система называется Пайпланом только потому что - какждый шаг выдате какой-то аутпут после своего завершения и этот аутпут передается в следующий шаг. Все эти шаги узкоспециализированные (имеют только одну конкретную, представляющую их, функцию) и могут быть спокойно посчитаны в параллели. Каждое небольшое ядро GPU может исполнять небольшую програмку, описанную в шаге Пайплайна - такая программа называется **Шейдером**.

![[opengl-pipeline.png]]

Голубым цветом, на картинке выше, помечены этапы пайплайн, которые может конфигурировать программист, по средствам шейдеров.

### Первый шаг пайплайна

Самый первый инпут, который мы должны записать Пайплайн OpenGL - это 3D координаты, представляющие фигуру (в нашем случае Треугольник). Список с такими координатами называется - Вертексные (вершинные) Данные. Один Вертекс - это небольшая коллекция данных, что бы описать точку в 3D пространстве.

Что бы описать один Вертекс используются Вертексные Атрибуты, которые могут содержать буквально любые нужные нам данные, но для простоты пока будем считать, что это три координаты и цветовое значение.

Основной смысл Вертексного Шейдера трансформировать поступившие 3D координаты в другие 3D координаты, а так же Вертексные Шейдеры позволяют нам осуществлять некоторую базовую обработку Вертексных Атрибутов.

### Второй шаг пайплайна

Выхлоп Вертексного Шейдера опционально, но при этом часто передается Шейдер Геометрии.

Шейдер Геометрии принимает на вход колекцию Вершин, которые формируют примитив, и имеет возможность генерировать другие фигуры выдавая новую порцию вершин, формируя новые (либо просто другие) примитивы.

### Третий шаг пайплайна

Стадия Сборки Примитивов получает на вход АБСОЛЮТНО ВСЕ ВЕРШИНЫ (либо же GL_POINTS, если выбрано) от Вертексного, либо Геометрического Шейдера, образующие какую-то форму. Из переданных вершин на данном этабе OpenGL собирает некую форму.

### Четвертый шаг пайплайна

Собранная форма далее передается переходит в Этап Растеризации, где проиходит отображение примитивов формы на реальные пиксели.

### Четвертый с половиной шаг пайплайна

Перед тем как передать отображенные пиксели в Фрагментарный Шейдер - происходит этап Клиппинга (Отсечения). Отсекаются все фрагменты, что не попали на конечную сцену. Это повышает производительность.

### Пятый шаг пайплайна

**Фрагмент** в OpenGL - это буквально ВСЕ данные, которые нужны для отрисовки одного единственного пикселя.

Отсюда пошло и название пятого шага - Фрагментарный Шейдер.

Основная роль Фрагментарного Шейдера - посчитать финальный цвет пикселей, и зачастую на этом этапе происходят все самые продвинутые эффекты из OpenGL.

Обычно Фрагментарный Шейдер знает о 3D сцене, на которой будет отрисовывать графику и это помогает в просчете финального цвета пикселя (к примеру на это оказывает влияние свет, тени, цвет света и тд).

### Шестой шаг пайплайна

После того, как будут определены все соответствующие значения цвета - финальный объект будет отправлен на еще одну шаг. Это шаг Альфа Тестирования и Блендинга (Объединения).

Сцена проверяет на этом шаге соотетсвующую Глубину и Трафареты фрагментов и использует эту информацию что бы определить - проверяемые объекты находятся спереди или сзади других объектов и соответственно отрисовка задних объектов будет отброшена.

На этом этапе также проверяются альфа-значения (альфа-значения определяют свойство непрозрачности у объекта) и Блендятся соответсвующим образом.

И даже если цвет выходного пикселя был посчитан одним образом, конечный результат все равно сильно может отличаться от того, что было насчитано изначально, при рендеринге.

---

В новейшем OpenGL требуется объявить хотя бы Вертекс и Фрагментный Шейдер собственными руками, так как на GPU не задано ни одного дефолтного Вертекса/Фрагментного Шейдера.

---

## Вертексные коллекции

### NDC коориднаты

Для того, что бы мы могли задать одну вершину в OpenGL - нам надо указать ее координаты в специальных Нормализованных Координатах Устройства (_**NDC**_, Normalized Device Coordinates). Данные координаты это значения от -1 до 1 по _**x**_, _**y**_ или _**z**_ осям и все координаты, которые были заданы и не попали в ренж _**NDC**_ - будут просто отсечены Клиппингом.

![[opengl-ndc.png]]

Это представление того самого Треугольника, что мы пытаемся отрисовать в _**NDC**_ координатах. На этом рисунке проигнорирована _**z**_ ось, потому что как итог - нам нужен только 2D треугольник.

В отличии от классического компьютерного представления коориднатных сеток - типа точка (0, 0) находится в левом верхнем углу, а ось _**y**_ смотрит вниз, NDC подразумевает более математическое представление осей, где _**y**_ будет смотреть наверх, а точка (0, 0) - является пересечением осей _**x**_ и _**y**_.

В дальнейшем все вертексы, представленные в _**NDC**_ координатах будут трансфорированы в Координаты Пространсва Экрана через трансформацию видвого экрана (viewport transformation) посредствам данных переданных во `glViewport` о конечной сцене.

```C++
const std::array<float, 9> vertices = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};  
```

### Vertex Buffer Object

После того, как мы задали основные вершины с которыми будем работать, надо пройти следующие шаги:

1. Выделить память на _**GPU**_ под эти Вертексы.
2. Определить как _**OpenGL**_ будет интерпретировать, переданные нами, данные.
3. Задать способ пересылки данных внутрь _**GPU**_.

Для выделения памяти на GPU будем использовать так называемы _**Vertex Buffer Objects**_ (**_VBO_**). _**VBO**_ может хранить огромнейшее количество вершин в памяти _**GPU**_, и самым большим приимуществом использования такогих буфферных объектов будет возможность отсылать сразу огромнейшую пачку с данными на **_GPU_**, потому что пересылка данных с _**CPU**_ на _**GPU**_ - это очень медленная операция. В ранних версиях _**OpenGL**_ вертексы пересылались с _**CPU**_ на _**GPU**_ поодному или небольшими паками - и это очень тормозило работу, поэтому решили отсылать теперь одним большим буффером.

И как только данные доходят до _**GPU**_ у Вертексного Шейдера появляется возможность почти мгновенно достать эти данные из памяти.

Как и любой другой объект с которым можно взаимодействовать в _**OpenGL**_ - у _**VBO**_ имеется свой уникальный айди, который присваивается после генерации этого объектного буфера.

Генереция буффера предполагает только его первичную инициализацию, реальные данные в этот мометн не аллоцируются (Ну кроме разве что каких-то начальных данных о новом буффере).

Генерация буффера происходит следующим образом:

```C++
    constexpr int vboQuantity = 1;
    unsigned int idVbo = 0;
    functions->glGenBuffers(vboQuantity, &idVbo);
```

Так как OpenGL имеет огромное количество разных типоа буфферных объектов, для того что бы получить инпут для первого шага OpenGL пайплайна и передачи именно VBO в Вертексный Шейдер - нашему, только что созданному (по сути просто сырая память без типа), буферу следует присвоить тип `GL_ARRAY_BUFFER` .

```C++
glBindBuffer(GL_ARRAY_BUFFER, idVbo);
```

После того, как мы сгенерировали буфер и задали ему соответсвующий тип - нам остается только заполнить его данными:

```C++
glBufferData(
    GL_ARRAY_BUFFER,
    vertices.size(),
    vertices.data(),
    GL_STATIC_DRAW
);
```

`GL_STATIC_DRAW` - подразумевает, что данные нашего Треугольника при каждом вызове рендеринга не будут менятся, поэтому их сохраянют в память, до которой накладнее производить запись.  
  
`GL_DYNAMIC_DRAW` - же напротив предполагает, что данные будут меняться в буффере, поэтому их аллоцируют в месте, где быстрее происходит запись.

Начальные данные мы полностью подготовили, теперь стоит написать шейдеры, которые будут обрабатывать эти данные.

## Вертексные Шейдеры

Первым делом мы напишем основной минимальный код для Вертексного Шейдера.

```C++
\#version 460 core
layout (location = 0) in vec3 aPos;  // Атрибут данных Вертекса

void main()
{
		glPosition = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

Данная строчка кода `\#version 460 core` обозначает версию и основной режим работы для взаимодействия с OpenGL.

Далее мы объявляем все входные Вертексные Атрибуты в шейдере при помощи ключевого слова _**in**_. Тк сейчас нас интересует только позиционные данные, нам нужен только один вертексный атрибут.

Язык _**GLSL**_ имеет векторный тип данных с постфиксным числом от 1 до 4. Так как мы решили, что каждая наша вершина будет задана в 3D, мы выбираем тип `vec3` для входной переменной с именем `aPos`.

Так же мы явно задаем локацию входного атрибута через `layout (location = 0)`.

Для выставления аутпута Вертексного Шейдера мы должны присвоить позиционные данные в предопределенную в _**GLSL**_ переменную `gl_Position`, которая по факту имеет тип `vec4`.

В конце выполнения функии шейдера `main()`, что бы мы не выставили в переменную `gl_Position` - это и будет являтся аутпутом Вертексного Шейдера.

Тк наш Вертексный Атрибут имеет тип `vec3`, а не `vec4` мы кастим его подобным образом в аутпут `vec4(aPos.x, aPos.y, aPos.z, 1.0);`.

### Компиляция Вертексного Шейдера

```C++
const std::string vertexShaderSource{
    "\#version 460 core                                   \n"
    "                                                    \n"
    "layout (location = 0) in vec3 aPos;                 \n"
    "void main()                                         \n"
    "{                                                   \n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); \n"
    "}                                                   \n"
};
```

Для того, что бы OpenGL смог работать с посланным нами шейдером - он должен быть скомпилирован в момент рантайма программы.

Для этого нам необходимо создать объект вертексного шейдера.

```C++
const unsigned int vertexShaderId = functions->glCreateShader(
    GL_VERTEX_SHADER
);
```

Далее происходит компановка Шейдерных Сорсов с Шейдерных объектом, созданным ранее.

```C++
constexpr unsigned int vertexShaderSourcesCount = 1;
const char* pVertexShaderSource = vertexShaderSource.c_str();

functions->glShaderSource(
    vertexShaderId, 
    vertexShaderSourcesCount, 
    &pVertexShaderSource,
    nullptr
);
```

И далее компилируем эту сорсы

```C++
glCompileShader(vertexShaderId);
```

Так же, после компиляции нам сто процентов захочется узнать об ошибке:  
  

```C++
int success = 0;
functions->glGetShaderiv(vertexShaderId, GL_COMPILE_STATUS, &success);
if (0 == success)
{
    constexpr unsigned int logLength = 512;
    std::string infoLog;
    infoLog.resize(logLength);

    functions->glGetShaderInfoLog(
        vertexShaderId, 
        logLength, 
        nullptr, 
        infoLog.data()
    );
    // DEBUG:
    qDebug() << "COMPILATION_FAILED\n" << QString::fromStdString(infoLog);
}
```

## Фрагментарные Шейдеры

Задание Фрагментарного Шейдера - последний этап нужный для отрисовки первого треугольника. Для простоты будем просто полностью заливать треугольник оранжевым цветом.

Цвета в компьютерной графике чаще всего задаются через RGBA, то есть 4х размерный вектор, где r - red, g -green, b - blue, a - alpha (прозрачность/не прозрачтность).

```C++
#version 460 core
out vec4 FragColor;

void main()
{
		FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
```

В фрагментарном шейдере мы объявляем правило для выходных цветов по средствам ключевого слова _**out**_ с именем `FragColor`.

RКомпиляция данного шейдера происходит ровно так же, как и вертексного

```C++
const std::string fragmentShaderSource{
    "\#version 460 core                            \n"
    "                                             \n"
    "out vec4 FragColor;                          \n"
    "void main()                                  \n"
    "{                                            \n"
    "   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f); \n"
    "}                                            \n"
};

const unsigned int fragmentShaderId = functions->glCreateShader(
    GL_FRAGMENT_SHADER
);

constexpr unsigned int fragmentShaderSourcesCount = 1;
const char* pShaderShaderSource = fragmentShaderSource.c_str();

functions->glShaderSource(
    fragmentShaderId,
    fragmentShaderSourcesCount,
    &pShaderShaderSource,
    nullptr
);
```

На данном этапе оба шейдера скомпилированы, и нам остается только слинковать оба этих сорса в одну _Шейдерную Программу_.

### Шейдерная программа

Объект шейдерной программы - это слинкованный между собой набор шейдерных сорсов. После линковки стоит активировать программу, и она начнет вызываться при каждом запросе от системы на рендеринг.

При линковке шейдеров в один объект программы, аутпут одного шейдера линкуется в инпут другого шейдера, так и получается пайплайн. Как раз-таки на этом этапе и можно получить ошибки линковки, если аутпут одного шейдера не совпадает с инпутом другого.

Создание Программного Объекта:

```C++
const unsigned int shaderProgramId = functions->glCreateProgram();
if (0 == shaderProgramId)
{
    // DEBUG:
    qDebug() << "Error while creating Shader Object Program";
    return;
}
```

Теперь надо объеденить все разрозненные шейдеры по средствам линковки:

```C++
functions->glAttachShader(shaderProgramId, vertexShaderId);
functions->glAttachShader(shaderProgramId, fragmentShaderId);
functions->glLinkProgram(shaderProgramId);
functions->glGetShaderiv(shaderProgramId, GL_LINK_STATUS, &success);
if (0 == success)
{
constexpr unsigned int logLength = 512;
std::string infoLog;
infoLog.resize(logLength);

functions->glGetShaderInfoLog(
    shaderProgramId,
    logLength,
    nullptr,
    infoLog.data()
);

infoLog.erase(
    std::ranges::find(infoLog, '\0'), 
    infoLog.end()
);
// DEBUG:
qDebug() << "LINKING_FAILED\n" << QString::fromStdString(infoLog);
}
```

Теперь обязательно нужно активировать слинкованный объект программы:

```C++
functions->glUseProgram(
	  shaderProgramId
);
```

После активации программы - теперь любой шейдер и вызов рендеренга будет использовать именно этот программный объект.

Так же стоит не забывать, что имеет смысл почистить сорсы Шейдеров которые уже слинкованы:

```C++
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```

На данный момент мы выполнили следующие пункты для отрисовки нашей первой фигуры:

Мы посылаем реальные вертексные данные на GPU, ипроинстурктировали GPU как он должен обрабатывать вертексные данные при помощи Аетексного и Фрагментарного шейдера.

Мы реализовали два пункта до полной отрисовки фигуры, но осталось еще два:

OpenGL еще не знает как интерпритировать вертексные данные из его памяти, поступившие от нас. И второй пункт - он не знает как объеденить Вертексные Данные с Вертексными Атрибутами.

### Линковка вертексных атрибутов

Вертексный Шейдер позволяет нам определить любые входные данные в виде Вертексных Атрибутов - это дает в руки разработчика очень гибкий инструмент, но так же и подразумевает, что разработчику придется определять где и какие данные соотвествуют какому Вертекснему Атрибуту.

Другими словами нам сейчас предстоит задать то, как OpenGL будет интерпретировать поданные нами ранее данные.

Наш Вертексный Буфер с данным выглядит сейчас так:

![[vertex-attribute-data.png]]

- Сейчас наши данные хранятся как 32-битные (4 байта) числа с плавающей точкой.
- Каждая позиция задается 3 значениями.
- Между позициями в памяти нет никаких прослек и дополнительных данных.
- Первое значенение позиции - в самом начале буфера.

Зная, что наши исходные данные представлены описанным выше образом, постараемся навесить на них смысла для OpenGL.

```C++
functions->glVertexAttribPointer(
    0, // Same as (location = 0) in Vertex Shader
    3, // Size of Vertex Attribute. Only 3 Vertices 
    GL_FLOAT, // Type of data in 
    GL_FALSE, // Should data be normalized
    3 * sizeof(float), // Stride
    nullptr // Offset
);
```

Далее надо включить этот атрибут:

```C++
functions->glEnableVertexAttribArray(
    0 // Same as (location = 0) in Vertex Shader
);
```

Вот такой вот код:

```C++
// 0. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. then set the vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  
// 2. use our shader program when we want to render an object
glUseProgram(shaderProgram);
// 3. now draw the object 
someOpenGLFunctionThatDrawsOurTriangle();   
```

Нам надо будет вызывать каждый раз, когда мы хотим отрисовать какой-то объект. Вроде бы и ничего страшного, но теперь представим, что нам надо будет отрисовать 100 таких объектов - и уже кодовая база разраслась до неимоверности.

Биндить новые буфферные объекты и конфигурировать все вертексные аттрибуты для каждого из этих объектов - резко становится огромной ношей.

А что если бы существовал такой объект, где мы бы могли сразу хранить все шаги конфигурации и просто байндить каждый раз этот объект на востановление?

## Вертексный Массив Объектов

Вертексный Массив Объектов (vertex array object, VAO) - может быть сбинчен с вертексными аттрибутами равно также как и VBO, только каждый раз приего вызове он будет востанавливать изнутри прошлые конфигурации.

Приимущество тут в том, что при конфигурации Указателя на Вертексный Аттрибут - надо будет вызвать его только раз и именно в тот момент, когда мы хотим отрисовать объект, мы можем просто притянуть нужный VAO.

Благодаря такому механизму довольно легко переключаться между разными Вертексными Данными и их Конфигурациями по средствам VAO.

VAO хранит следующие вещи:

- Вызовы таких функций как `glEnableVertexAttribArray` или `glDisableVertexAttribArray`.
- Конфигурацию Вертексного Атрибута через `glVertexAttribPointer`.
- VBO проассоциированное с Вертексным Атрибутом по средствам функции `glVertexAttribPointer`.

![[vertex-array-objects.png]]

Механизм генерации VAO очень похож на VBO:

```C++
unsigned int vertexArrayObjectId;
constexpr int vertexArrayObjectCount = 1;
extra_func->glGenVertexArrays(
    vertexArrayObjectCount, 
    &vertexArrayObjectId
);
if (0 == vertexArrayObjectId)
{
    // DEBUG:
    qDebug() << "Error while Generating Vertex Array";
    return;
}
```

Далее, что бы начать пользоваться VAO надо его связать во внутренностях OpenGL, после этого сразу начать настройку VBO и указателя на атрибут и после этого стоит отвязать VAO. После таких хитрых действий забинженый ранее VAO сохранится в памяти и будет знать и о указатели на Атрибут и о Вертексном Буфере.

И в целом, лучше теперь после того, как мы открыли для себя VAO генерировать и настривать их в одном место с VBO.

Код общей настройки будет следующим:

```C++
/* ----------------- GENERATE AND CONFIGURE INPUT DATA ----------------- */
// General vertices with triangle
constexpr std::array<float, 9> vertices = {
    -0.5F, -0.5F, 0.0F, // 1st vertex
    0.5F, -0.5F, 0.0F, // 2st vertex
    0.0F,  0.5F, 0.0F  // 3st vertex
};

// Generating Vertex Array Object
unsigned int vertexArrayObjectId = 0;
constexpr int vertexArrayObjectCount = 1;
extra_func->glGenVertexArrays(
    vertexArrayObjectCount, 
    &vertexArrayObjectId
);
if (0 == vertexArrayObjectId)
{
    // DEBUG:
    qDebug() << "Error while Generating Vertex Array";
    return;
}
else
{
    // DEBUG:
    qDebug() << "Vertex Array Object ID:" << vertexArrayObjectId;
}

// Generating Vertex Buffer Object
constexpr int vertexBufferObjectCount = 1;
unsigned int vertexBufferObjectId = 0;
functions->glGenBuffers(
    vertexBufferObjectCount, 
    &vertexBufferObjectId
);
if (0 == vertexBufferObjectId)
{
    // DEBUG:
    qDebug() << "Error while Vertex Buffer Object";
    return;
}
else
{
    // DEBUG:
    qDebug() << "Vertex Buffer Object ID:" << vertexBufferObjectId;
}

// Bind VAO
extra_func->glBindVertexArray(vertexArrayObjectId);

// Set type to newly created buffer
functions->glBindBuffer(
    GL_ARRAY_BUFFER, 
    vertexBufferObjectId
);
// Allocates memory for data in Buffer
functions->glBufferData(
    GL_ARRAY_BUFFER,
    vertices.size() * sizeof(float), // TRY: sizeof(vertices.size())
    vertices.data(),
    GL_STATIC_DRAW
);

// Interpret Vertex Data for OpenGL
functions->glVertexAttribPointer(
    0, // Same as (location = 0) in Vertex Shader
    3, // Size of Vertex Attribute. Only 3 Vertices like in vec3
    GL_FLOAT, // Type of data in 
    GL_FALSE, // Should data be normalized
    3 * sizeof(float), // Stride
    nullptr // Offset
);
// Activate VAO right after VBO bind
functions->glEnableVertexAttribArray(
    0 // Same as (location = 0) in Vertex Shader
);

// Now we should unbind for other VAO, VBO doesn't access what we've done
constexpr int UNBIND = 0;
functions->glBindBuffer(GL_ARRAY_BUFFER, UNBIND);
extra_func->glBindVertexArray(UNBIND);
/* -------------------------------- *** -------------------------------- */
```

И на этом моменте мы наконец-то дошли до того, что можно будет отрисовывать объекты. Обычно вся это конфигурация происходит один раз, а потом просто при рендеринге вызывается нужный VAO для отрисовки той или иной фигуры вместе с нужным конфигурационным набором.

Отрисовка треугольника должна проходить припомощи следующего кода:

```C++
extra_func->glDeleteVertexArrays(vertexArrayObjectCount, &vertexArrayObjectId);
functions->glDeleteBuffers(vertexBufferObjectCount, &vertexBufferObjectId);
functions->glDeleteProgram(shaderProgramId);
```
