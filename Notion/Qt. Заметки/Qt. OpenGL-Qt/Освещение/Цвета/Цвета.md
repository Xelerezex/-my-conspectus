---

Данная заметка является переводом [вот этой статьи](https://learnopengl.com/Lighting/Colors).

---

В реальном мире у каждого объекта присутсвует свой собственный цвет, который может принимать абсолютно любые значения. В цифровом же мире - мы должны смапить бесконечность реального цвета на конечное значение байтов, помещающихся в памяти, а следовательно не все цвета-из-реального-мира могут быть отображены в цифровом виде.

Чаще всего используется политра **RGB**, где значения задаются от $0.0$﻿ до $1.0$﻿, к примеру кораловый цвет можно получить вот так:

```C++
glm::vec3 coral(1.0f, 0.5f, 0.31f);  
```

Цвет, который мы видим в реальной жизни, это не реальный цвет объекта, это цвет, который был отражен от объекта. Мы видим, получается, именно цвет, который объект отдает, так часть он абсорбирует в себе.

![[light_reflection.png]]

К примеру от солнца исходит белый свет, который делится на много разных цветов, а при отражении от какого-то объекта - отдаются лишь некоторые.

К примеру, белый свет отраженный от синего объектаю Объект, отражая свет обсорбирует все цвета, кроме синего, и именно из-за этого эфекта нам и покажется, что объект имеет синий цвет.

(Технически, это гораздо более сложный процесс, который нормально будет объяснен в главе про **PBR**).

Но основная идея тут все еще работает и в мире графики, поэтому когда мы определяем цвет источника света и свет объекта, который попадает под этот свет - мы хотим получим именно отражение одного от другого. Такого эффекта можно достичь математически, если умножить цвет источника света, на цвет объекта - это и будет отраженный цвет.

К примеру, как мы выше описывали синий объект:

```C++
glm::vec3 lightColor(1.0f, 1.0f, 1.0f);      // Белый свет
glm::vec3 objectColor(1.0f, 0.5f, 0.31f);    // Синий объект
glm::vec3 result = lightColor * objectColor; // = (1.0f, 0.5f, 0.31f);
```

Мы видим, что объект “Абсорбирует” большую часть цвета, например `1.0F * 0.5F == 0.5F` в зеленом цвете.

А как к примеру поведет себя конечный цвет, если сделать свет зеленым?

```C++
glm::vec3 lightColor(0.0f, 1.0f, 0.0f);      // Зеленый свет
glm::vec3 objectColor(1.0f, 0.5f, 0.31f);    // Синий объект
glm::vec3 result = lightColor * objectColor; // = (0.0f, 0.5f, 0.0f);
```

Как мы видим - у объекта теперь нет красного и синего цвета, и так же произошло частичное абсорбирование зеленого - получается отразилась только часть зеленого. Значит объект мы увидим темно-зеленого цвета.

Ну ради интереса сделаем свет темно-оливковым:

```C++
glm::vec3 lightColor(0.33f, 0.42f, 0.18f);   // Темно-оливковый свет
glm::vec3 objectColor(1.0f, 0.5f, 0.31f);    // Синий объект
glm::vec3 result = lightColor * objectColor; // = (0.33f, 0.21f, 0.06f);
```

## Сцена с освещением

В предыдущих главах мы реализовывали визуальные решения, похожие на реальный мир, посредствам задания им цвета, теперь же мы будем использовать другой подход - создавать как минимум один источник света на сцене.

Для самого базового примера - мы возьмем кубы из прошлых глав, а дадим одному просто цвет - а второй будет источником света.

Для этого - нам надо будет создать новый VAO - который будет хранить в себе источник света:

```C++
unsigned int lightVAO;
glGenVertexArrays(1, &lightVAO);
glBindVertexArray(lightVAO);
// we only need to bind to the VBO, the container's VBO's data already contains the data.
glBindBuffer(GL_ARRAY_BUFFER, VBO);
// set the vertex attribute 
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```

Теперь надо будет создать новую пару шейдеров для источника света, и фрагментарный щейдер в этой паре, будет выглядеть так:

```C++
\#version 330 core
out vec4 FragColor;
  
uniform vec3 objectColor;
uniform vec3 lightColor;

void main()
{
    FragColor = vec4(lightColor * objectColor, 1.0);
}
```

Фрагментарный шейдер принимает и цвет объекта и цвет света из юниформы:

```C++
lightingShader.use();
lightingShader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);
lightingShader.setVec3("lightColor",  1.0f, 1.0f, 1.0f);
```

Для того, что бы иметь один и тот же свет на сцене - лучше всего изолировать объект света и относящиеся к нему шейдеры в отдельную часть кода, так как мы совем не хотим, что бы какие-то вычисления затрагивали шейдера света.

Вертексный шейдер у куба света - будет буквально такой же, как и у всех остальных кубов (что бы работали трансформации связаные с Камерой), а вот в фрагментарном шейдере будет просто задана константа цвета для света:

```C++
\#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0); // set all 4 vector values to 1.0
}
```