---

### Ресурсы:

1. [Как выглядит память внутри объектов, при разных сценариях?](https://www.vishalchovatiya.com/memory-layout-of-cpp-object/)
2. [Как выглядят в памяти объекты из чистого С?](https://www.vishalchovatiya.com/how-c-program-stored-in-ram-memory/)

---

Мы рассмотрим представление в памяти разных объектов `C++`. И как различные спецификаторы хранилища и доступа влияют на этот объем памяти.

[[TODO-]] Добавить [статью](http://www.vishalchovatiya.com/how-c-program-convert-into-assembly/) про дизасембл программ.

---

## Краткий обзор содержания:

1. [[Вопросы задаваемые на собеседованиях- 2/С++. Как выглядит память внутри объектов, при разных сценариях|С++. Как выглядит память внутри объектов, при разных сценариях]]
2. [[Вопросы задаваемые на собеседованиях- 2/С++. Как выглядит память внутри объектов, при разных сценариях|С++. Как выглядит память внутри объектов, при разных сценариях]]
3. [[Вопросы задаваемые на собеседованиях- 2/С++. Как выглядит память внутри объектов, при разных сценариях|С++. Как выглядит память внутри объектов, при разных сценариях]]
4. [[Вопросы задаваемые на собеседованиях- 2/С++. Как выглядит память внутри объектов, при разных сценариях|С++. Как выглядит память внутри объектов, при разных сценариях]]
5. [[Вопросы задаваемые на собеседованиях- 2/С++. Как выглядит память внутри объектов, при разных сценариях|С++. Как выглядит память внутри объектов, при разных сценариях]]

---

## 1. Представление в памяти простых, неполиморфных объектов C++.

Начнем с примера обычного класса:

```C++
class X
{
    int     x;
    float   xx;

public:
    X() {}
    ~X() {}

    void printInt() {}
    void printFloat() {}
};
```

Представление в памяти:

```C++
      |                        |          
      |------------------------| <------ представление в памяти объекта класса X
      |        int X::x        |
      |------------------------|  сегмент стека
      |       float X::xx      |       |   
      |------------------------|       |
      |                        |      \|/
      |                        |    
      |                        |
------|------------------------|----------------
      |         X::X()         | 
      |------------------------|       |   
      |        X::~X()         |       |
      |------------------------|      \|/
      |      X::printInt()     |  текстовый сегмент
      |------------------------|
      |     X::printFloat()    |
      |------------------------|
      |                        |
```

Как мы видим - все поля класса хранятся в сегменте стековой памяти.

А все обычные методы, конструкторы, деструкторы и код, добавленный компилятором хранится, в так называемом, текстовом сегменте.

_Текстовый сегмент_ - хранит в себе запускаемые инструкции кода. К запускаемым инструкциям кода относятся все функции (типа `main()`), как определенные пользователем, так и системные. Текстовый сегмент обычно разделяемый, поэтому для запускаемых программ требуется только одна его копия. Так же он имеет расширение - только для чтения, что бы инструкции созданные пользователем или системой - не изменялись произвольно.

В дальнейшем все эти методы класса будут вызываться, и им будет передаваться указатель `this` на объект, чей метод вызывается.

---

## 2. Представление в памяти объектов с виртуальными функциями и со статическими полями.

Далее рассмотрим представление в памяти класса со следующей сигнатурой:

```C++
class X
{
    int         x;
    float       xx;
    static int  count;

public:
    X() {}
    virtual ~X() {}

    virtual void printAll() {}
    void printInt() {}
    void printFloat() {}
    static void printCount() {}
};
```

Выглядеть это будет так:

```C++
      |                        |          
      |------------------------| <------ представление в памяти объекта класса X
      |        int X::x        |
Стек  |------------------------|
  |   |       float X::xx      |              (находится в сегменте данных)     
  |   |------------------------|      |-------|--------------------------|
  |   |         X::_vptr       |------|       |       type_info X        |
 \|/  |------------------------|              |--------------------------|
      |           o            |              |    address of X::~X()    |
      |           o            |              |--------------------------|
      |           o            |              | address of X::printAll() |
      |                        |              |--------------------------|
      |                        |
------|------------------------|------------
      |  static int X::count   |      /|\
      |------------------------|       |
      |           o            |  сегмент данных           
      |           o            |       |
      |                        |      \|/
------|------------------------|------------
      |        X::X()          | 
      |------------------------|       |   
      |        X::~X()         |       |
      |------------------------|       | 
      |      X::printAll()     |      \|/ 
      |------------------------|  текстовый сегмент
      |      X::printInt()     |
      |------------------------|
      |     X::printFloat()    |
      |------------------------|
      | static X::printCount() |
      |------------------------|
      |                        |
```

Все не статические поля классов хранятся в сегменте стековой памяти, в том же порядке как они и были объявлены.

И наоборот, все статически объявленные поля перемещаются в сегмент данных. До которых можно достучаться через оператор `::`

_Сегмент данных_ - сегмент, который включает в себя хранилище для статических и глобальных данных. Существует два варианта хранения этих данных.

- _Сегмент проинициализованных данных_ - включает в себя статические и глобальные данные, которым присвоены ненулевые значения. Данный сегмент может быть как и только для чтения, так и запись-чтение.
    
    К примеру если определена переменная `int a = 69;` вне `int main()` (это значит, что она глобальная) - то она будет хранится в сегменте проинициализированных данных, в части на запись-чтение.
    
    А если у нас глобально определена `const int b = 42;` то она будет хранится в части только на запись.
    
- _Сегмент непроинициализованных данных_ - так же называется BBS (Block Started by Symbol), включает в себя все статические и глобальные данные, которые проинициализированы нулем, либо им явно не присвоено никакого значения.
    
    К примеру тут будут хранится переменные `int x;` или `static int y = 0;` .
    
    Так же, если переменная не проинициализована, то ее инициализацией займется программный загрузчик (в линуксе это `/lib/ld-linux.so.2`)
    

В статические методы не передается указатель `this` . Обращение к ним идет только через `::`.

При использовании ключевого слова `virtual` в методах или наследовании, компилятор создает указатель на [[Вопросы задаваемые на собеседованиях- 2/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]. Обычно, так как таблица виртуальных методов статическая, она так же создается в сегменте данных (но это может зависеть от компилятора).

В виртуальной таблице 1 элемент это всегда [`type_info`](https://cplusplus.com/reference/typeinfo/type_info/) , который хранит информацию о типе данных и о данном классе а так же граф DAG([Directed Acyclic Graph](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=9&cad=rja&uact=8&ved=2ahUKEwjO_sWYgPToAhU4yzgGHfyzAGkQFjAIegQIARAB&url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDirected_acyclic_graph&usg=AOvVaw1mxaV0fpCPG1RAZSFIC5oJ)) рассказывающий о других базовых классах, от которых идет наследование.

---

## 3. Представление в памяти наследуемых объектов.

Пример с наследованием:

```C++
class X
{
    int     x;
    string str;

public:
    X() {}
    virtual ~X() {}

    virtual void printAll() {}
};

class Y : public X
{
    int     y;

public:
    Y() {}
    ~Y() {}

    void printAll() {}
};
```

Преставление памяти будет выглядеть так:

```C++
      |                                 |          
      |---------------------------------| <------ Представление в памяти объекта 
      |          int X::x               |         класса Y.
стек  |---------------------------------|
  |   |             \ int string::len   |
  |   |string X::str -------------------|
  |   |             / char* string::str |         
 \|/  |---------------------------------|      |-----|--------------------------|
      |           X::_vptr              |------|     |       type_info Y        |
      |---------------------------------|            |--------------------------|
      |          int Y::y               |            |      адрес Y::~Y()       |
      |---------------------------------|            |--------------------------|
      |               o                 |            |    адрес Y::printAll()   |
      |               o                 |            |--------------------------|
      |               o                 |              
------|---------------------------------|--------
      |           X::X()                |       |
      |---------------------------------|       |   
      |           X::~X()               |       |
      |---------------------------------|       | 
      |         X::printAll()           |      \|/ 
      |---------------------------------|  текстовый сегмент
      |           Y::Y()                |
      |---------------------------------|
      |           Y::~Y()               |
      |---------------------------------|
      |         Y::printAll()           |
      |---------------------------------|
      |      string::string()           |
      |---------------------------------|
      |      string::~string()          |
      |---------------------------------|
      |      string::length()           |
      |---------------------------------|
      |               o                 |
      |               o                 |
      |               o                 |
      |                                 |
```

В модели представления памяти с наследованием: базовый класс и и классы-поля выступают в качестве подобъектов для наследника.

Виртуальная таблица со всеми переопределенными виртуальными функциями генерируется в конструкторе класса компилятором.

---

## 4. Представление в памяти объектов с множественным наследованием и виртуальными функциями.

Перейдем к множественному наследованию:

```C++
class X
{
public:
    int     x;
    
    virtual ~X() {}
    virtual void printX() {}
};

class Y
{
public:
    int     y;
    
    virtual ~Y() {}
    virtual void printY() {}
};

class Z : public X, public Y
{
public:
    int     z;
    
    ~Z() {}
    void printX() {}
    void printY() {}
    void printZ() {}
};
```

Преставление памяти будет выглядеть так:

```C++
      |                              |          
      |------------------------------| <---- Представление в памяти объекта 
стек  |          int X::x            |       класса Z 
  |   |------------------------------|              |---------------------|      
  |   |          X:: _vptr           |------------->|     type_info Z     |
  |   |------------------------------|              |---------------------|
 \|/  |          int Y::y            |              |    адрес Z::~Z()    |
      |------------------------------|              |---------------------|
      |          Y:: _vptr           |------|       |   адрес Z::printX() |
      |------------------------------|      |       |---------------------|
      |          int Z::z            |      |       |------GUARD_AREA-----|    
      |------------------------------|      |       |---------------------|
      |              o               |      |------>|     type_info Z     |
      |              o               |              |---------------------|
      |              o               |              |    адрес Z::~Z()    |
      |                              |              |---------------------|
------|------------------------------|---------     |   адрес Z::printY() |
      |           X::~X()            |       |      |---------------------|  
      |------------------------------|       |          
      |          X::printX()         |       |        
      |------------------------------|       |         
      |           Y::~Y()            |      \|/        
      |------------------------------|  текстовый сегмент
      |          Y::printY()         |                
      |------------------------------|                
      |           Z::~Z()            |                
      |------------------------------|                
      |          Z::printX()         |                
      |------------------------------|                
      |          Z::printY()         |                
      |------------------------------|                
      |          Z::printZ()         |                
      |------------------------------|                
      |               o              |                
      |               o              |                
      |                              |
```

При множественном наследовании будет создано `N - 1` виртуальных таблиц, по количеству классов (`X`, `Y`, `Z`).

Если вызывать методы класса `Z` через указатель на базовый класс, выйдет что-то такое:

```C++
Y *y_ptr = new Z;
y_ptr->printY(); // OK
y_ptr->printZ(); // Not OK, потому что в виртуальной таблице нет такого метода
```

В коде выше, `y_ptr` будет указывать на подобъект `Y` (находящийся внутри `Z`), а не на полный объект класса `Z`.

В результате код `y_ptr->printY();` развернется в следующую строку:

```C++
(*y_ptr->_vtbl[ 2 ])( y_ptr )
```

Как аргумент функции передается указатель `y_ptr` из-за неявного указателя `this` на этом месте.

---

## 5. Представление в памяти объектов с виртуальным наследованием.

В конце поговорим про представление в памяти иерархии с виртуальным наследованием.

```C++
class X { int x; };
class Y : public virtual X   { int y; };
class Z : public virtual X   { int z; };
class A : public Y, public Z { int a; };
```

Преставление памяти будет выглядеть так:

```C++
                  |                |          
подобъект ------> |----------------| <------ Представление в памяти объекта
класса Y          |   Y::y         |         класса A
                  |----------------|            |------------------| 
                  |   Y::_vptr_Y   |-----|      |    offset of X   | // offset(20) starts from Y 
подобъект ------> |----------------|      |---> |------------------|     
класса Z          |   Z::z         |            |       .....      |     
                  |----------------|            |------------------|  
                  |   Z::_vptr_Z   |-----|       
                  |----------------|      |        
 подобъект A  --> |   A::a         |      |     |------------------| 
                  |----------------|      |     |    offset of X   | // offset(12) starts from Z
 разделяемый ---> |   X::x         |      |---> |------------------|          
 подобъект        |----------------|            |       .....      |           
 класса X         |                |            |------------------|
```

Представление в памяти производного класса, имеющего один или несколько виртуальных базовых классов, делится на две области:

1. Инвариантную область.
2. Общий регион.

Данные в пределах инвариантной области остаются с фиксированным смещением от начала объекта независимо от последующих производных.  
Однако общая область содержит виртуальный базовый класс, и он меняется в зависимости от последующего вывода и порядка вывода.