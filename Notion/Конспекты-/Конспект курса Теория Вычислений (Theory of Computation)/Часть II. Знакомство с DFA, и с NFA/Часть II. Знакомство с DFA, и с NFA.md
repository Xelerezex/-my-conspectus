---

## 2.1 DFA. Пример первый.

Наша задача будет состоять в следующем: Надо написать свой детерминированный конечный автомат, для данного по условию языка.

Начнем сразу с примера.

Дано: $L_1\ =\ Множество\ всех\ строк,\ начинающихся\ с\ символа\ 0$﻿.

Представим, как бы выглядел такой алфавит: $L_1\ =\ \{0, 00, 01, 010, 011, 0000, ...\}$﻿

![[dfa-example-one.svg]]

Так же в английском варианте тупиковое состояние переводится, как _Dead State_ или _Trap State_. Оно считается таковым, потому что, если мы достигли тупикового состояния, то до конечного состояния, мы никогда не дойдем. А соответственно, если строка попала в тупиковое состояние, договоримся, что такая строка нам не подходит и отбросим её.

Прогоним через наш автомат две разные строки:

1. Первая строка - $001$﻿.
    
    ![[dfa-example-one-one.svg]]
    
    И так как последний символ строки оказался в конечном состоянии автомата - строка считается валидной, и её можно добавить в вышеописанный алфавит $L_1$﻿.
    
2. Вторая строка - $101$﻿.
    
    ![[dfa-example-one-two.svg]]
    
    Мы видим, что после всех преобразований строка осталась в тупиковом состоянии и не дошла до конечного. Значит, что строка не подходит для нашего алфавита, мы не считаем её валидной.
    

## 2.2 DFA. Пример второй.

Нам следует создать _**DFA**_ такой, что бы принималось любое множество строк, состоящие из алфавита $\Sigma\ =\ \{0, 1\}$﻿ и длинны 2.

Запишем, что нам дано: $\Sigma\ =\ \{0, 1\}$﻿, $L\ =\ \{00, 01, 10, 11\}$﻿

Получается, наш конечный автомат должен принять на вход только 4 слова, а остальные отбраковать.

![[dfa-example-two-one.svg]]

Именно так и будет выглядеть решение поставленной выше задачи. Но мы себя проверим, и распишем примеры:

1. Строка на вход $00$﻿:
    
    ![[dfa-example-two-two.svg]]
    
      
    
    После всех разбиений строка достигла конечного состояния, значит, она валидна в рамках определенного выше _**DFA**_.
    
2. Строка на вход $10$﻿:
    
    ![[dfa-example-two-three.svg]]
    
    Строка так же попала в конечное состояние, она тоже валидна.
    
3. Теперь возьмем строку большего размера. Строка на вход $001$﻿:
    
    ![[dfa-example-2-4.svg]]
    
    После всех преобразований строка оказалась в тупиковом состоянии, а это значит, что она не валидна в рамках нашего _**DFA**_.
    
4. Строка на вход $1$﻿:
    
    ![[dfa-example-2-5.svg]]
    
    Строка дошла только до промежуточного состояния. А раз она не в конечном состоянии, то и не считается валидной.
    

## 2.3 DFA. Пример третий.

Задача будет следующая: Создать _**DFA**_, такой, что бы он принимал любую строку состоящую из алфавита $\Sigma\ =\ \{a, b\}$﻿, и при это строка на вход не должна включать в себя подстроку $aabb$﻿.

Данная задача выглядит довольно непростой, поэтому попробуем зайти с другого конца и сделать такой _**DFA**_, что будет принимать любую строку, где будут находиться подстроки $aabb$﻿.

![[dfa-example-3-1.svg]]

Мы создали _**DFA**_, который будет пропускать любую строку, в которой есть подстрока $aabb$﻿, теперь нужно сделать обратный вышеописанному _**DFA**_.

И для создания обратного _**DFA**_, нужно _перевернуть_ состояния автомата. Под словом перевенуть, подразумевалось два действия:

1. Обернуть конечное состояние в не конечное состояние.
2. Обернуть не конечные состояния в конечные состояния.

![[dfa-example-3-2.svg]]

И таким образом у нас будут отбрасываться любые строки, в которых есть подстрока $aabb$﻿.

## 2.4 DFA. Пример четвертый.

Четвертым примером мы ответим на вопрос: Как выяснить, что _**DFA**_ будет распознавать?

Для этого, изначально зададим полностью готовый _**DFA**_:

![[dfa-example-4-1.svg]]

Что бы понять, для чего нужен данный автомат - напишем строки, которые успешно попадают в конечное состояние:

1. $10\ это\ (A\ \rightarrow\ B\ \rightarrow\ D)$﻿ ✅
2. $11110\ это\ (A\ \rightarrow\ B\ \rightarrow\ B\ \rightarrow\ B\ \rightarrow\ B\ \rightarrow\ D)$﻿ ✅
3. $01\ это\ (A\ \rightarrow\ C\ \rightarrow\ E)$﻿ ✅

В каждой успешной строке есть $1$﻿

Можем сказать, что язык для данного DFA, будет:

$L=\{ Принимает\ строку\ 01,\ либо\ строку\ с\ хотя\ бы\ одним\ вхождением\ 1\ \ и\ идущим\ в\ след\ 0\}$﻿

Мы предварительно описали правило, которое должно работать, но что делать со строками $001,\ 010,\ 011,\ 1101,\ 1100$﻿? Данные строки просто не будут работать?

Данные строки, релевантны на вход для вышеописанного _**DFA**_, но нам надо будет описать Тупиковое значение (_Dead State_).

![[dfa-example-4-2.svg]]

Таким образом, дорисовав тупиковое состояние $X$﻿ мы получаем полностью законченный автомат.

_Существует соглашение, что если не описано какое-то перемещение из состояния, в другое состояние, то оно по дефолту идет в тупиковое состояние._

Как было показано выше, из $C$﻿ нет хода в другое состояние, если передать $0$﻿. Это значит, что при $0 $﻿ в $C$﻿ переход осуществляется в _тупиковое состояние_ ($C\ \rightarrow\ X$﻿).

## 2.5 Регулярные Языки.

Что считается регулярным языком?

$Язык,\ считается\ регулярным, тогда\ и\ только\ тогда,\ когда\ какой-то\newline $

Тогда какие же языки считаются не регулярными?

$Язык\ считается\ не\ регулярным\ если\ он\ не\ распознается\ конечным\ автоматом.\newline$

Вспомним, что память _**FSM**_ очень сильно ограничена (единственное, на что есть память, это на _**FSM**_ и на состояние в котором он находится прям сейчас), и она не может хранить или подсчитывать строки.

_Приведем пример:_ у нас есть строка $ababbababb$﻿, мы видим, что первые пять символов повторяются, а значит её язык будет выглядеть так:

$L\ =\ \{Первые\ пять\ символов\ повторяются\ единожды\}$﻿

Будет ли определенный выше язык регулярным?

Нет, потому что для того, что бы знать, какие символы были введены в первый раз, и что бы по их подобию ввести вторые - надо запомнить первую партию символов в памяти, а у нас нет на это памяти. А значит мы не сможем описать то при помощи _**FSM.**_

_Ещё пример:_ Есть язык, описываемый правилом: $L\ =\ \{a^nb^n\}$﻿, другими словами если нам дано 3 $a$﻿, то и $b$﻿ должно быть 3, типа $aaabbb$﻿ - данная строка удовлетворяет описанному выше языку.

Будет ли данный язык регулярным?

Тоже нет, так как нам нужна будет память под счетчик количества чисел.

## 2.6 Операции над регулярными языками.

В данном модуле обсудим следующие три операции, доступные в регулярных языках:

1. _**Объединение**_ - $A\cup B=\{x \,\mid\, x \in A \text{ или } x \in B\}$﻿
2. _**Конкатенация**_ - $A\circ B=\{xy \,\mid\, x \in A \text{ и } y \in B\}$﻿
3. _**Звездочка**_ - $A^*\,=\, \{x_1x_2x_3 \ldots x_k \mid \, k\geqslant 0\,\text{и каждый } x_i \in A\}$﻿

_Пример:_

$A =\{pq, r\}$﻿, $B =\{t, uv\}$﻿

1. $A \cup B = \{pq, r, t, uv\}$﻿
2. $A \circ B = \{pqt, pquv, rt, ruv\}$﻿
3. $A^* = \{\epsilon, pq, r, pqr, rpq, pqpq, rr, pqpqpq, rrr, \ldots\}$﻿

Обозначив операции над регулярными языками, запишем так же 2 важные теоремы:

$I.\text{ Класс регулярных языков ограничен снизу Пересечением}$﻿$II.\text{ Класс регулярных языков ограничен снизу Конкатенацией}$﻿

## 2.7 Недетерминированный конечный автомат (NFA).

![[nfa-basic.svg]]

  

Недетерминированный конечный автомат. Детерминированный идет от слова Детерминизм, это значит, что что-то уже было определено, а недетерминированный говорит о том, что определения ещё нет, другими словами у нас есть следующие гарантии для _**NFA**_:

- В _**NFA**_, находясь в каком-то состоянии может быть сразу несколько переходов в другие уникальные состояния. То есть _**NFA**_ может иметь единовременно несколько нынешних состояний.
- Следующие состояние _**NFA**_ может быть выбрано либо рандомно, либо параллельно. То есть при желании, следующие состояние может быть только одним, или их может быть сразу несколько.
- Только _**NFA**_ может принять на вход $\epsilon$﻿ - пустую строку.

## 2.8 Формальное определение NFA.

Для наглядности начнем с примера:

$L\ =\ \{\text{Множество всех строк, оканчивающихся на нуль}\}$﻿

![[nfa-formal-1.svg]]

- Сноска
    
    Заметим, что в этом _**NFA**_ нет стрелки перехода из $B\rightarrow B$﻿ ни для нуля, ни для единицы. В _**DFA**_ такой дизайн смело считался бы ошибкой. А вот в _**NFA**_ такое позволяется.
    

Так же как и в _**DFA**_, _**NFA**_ формально определяется при помощи пяти коллекций: $Q,\ \Sigma,\ q_0,\ F,\ \delta$﻿

$Q\ =\ \{\text{Множество всех состояний}\}\ =\ \{A, B\}$﻿

$\Sigma\ =\ \{\text{Множество всех входных символов (алфавит)}\}\ =\ \{0, 1\}$﻿

$q_0\ =\ \text{Начальное состояние} =\ A$﻿

$F\ =\ \{\text{Множество всех конечных значений}\}\ =\ \{B\}$﻿

$\delta\ =\ \text{Функция перехода} =\ Q \times \Sigma \rightarrow 2^Q$﻿

$A \times 0 \rightarrow A$﻿

$A \times 0 \rightarrow B$﻿

$A \times 1 \rightarrow A$﻿

$B \times 0 \rightarrow \emptyset$﻿

$B \times 1 \rightarrow \emptyset$﻿

$A \rightarrow A,\ B,\ AB,\ \empty$﻿

  

## 2.9 NFA. Пример первый.

Проанализируем пример:

$L\ =\ \{\text{Множество всех строк, оканчивающихся на нуль}\}$﻿

![[nfa-formal-1.svg]]

1. Строка на вход $100$﻿ (✔️):
    
    ![[nfa-example-1-1.svg]]
    
    Как мы можем наблюдать - мы дошли до конечного состояния B (желтая галочка). Значит, что данная строка удовлетворяет данному _**NFA**_.
    
2. Строка на вход $01$﻿ (❌):
    
    ![[nfa-example-1-2.svg]]
    
    На данном рисунке мы видим, что с такой входной строкой никогда не попасть в конечное положение.
    

Существует такое правило:

$\text{Если существует такой способ прогнать NFA, что бы хотя бы одно из положений}\newline$

Данное правило видно на примерах выше. Строка 001 имеет неудачные (невалидные проходы), но при это есть один маршрут, что бы добраться до конечного состояния. А значит данная строка валидна для вышеописанного языка:

$L\ =\ \{\text{Множество всех строк, оканчивающихся на нуль}\}$﻿

## 2.9 NFA. Пример второй.

$L\ =\ \{\text{Множество всех строк, начинающихся на нуль}\}$﻿

_**NFA**_ для данного языка будет выглядеть так:

![[nfa-example-2-1.svg]]

1. Строка на вход $001$﻿ (✔️):
    
    ![[nfa-example-2-2.svg]]
    
2. Строка на вход $101$﻿ (❌):
    
    ![[nfa-example-2-3.svg]]
    

- Сноска
    
    На похожее правило $L$﻿ мы писали выше ещё и _**DFA**_, ради интереса попробуем привести _**NFA**_ к _**DFA**_.
    
    ![[nfa-to-daf-example-2.svg]]
    
    Разница состоит в том, что мы должны описывать буквально каждый переход из состояния в другое состояние.
    
    Стоит уточнить, что _**DFA**_ не могут в принципе иметь состояния остановки. Но при этом у них есть тупиковые состояния.
    

---

Для дополнительной практики выполним небольшое задание: Спроектируйте NFA, который принимает все строки из 0 и 1, длины 2.

_Дано:_

  

$\Sigma\ =\ \{0,1\}$﻿

$L\ =\ \{00, 01, 10, 11\}$﻿

Выглядеть он будет так:

![[nfa-example-2-4.svg]]

1. Строка на вход $00$﻿ (✔️):
    
    ![[nfa-example-2-5.svg]]
    
2. Строка на вход $001$﻿ (❌):
    
    ![[nfa-example-2-6.svg]]
    

## 2.10 NFA. Пример третий.

_Упражнение 1:_

$L_1\ =\ \{\text{Множество всех строк, кончающихся на 1}\}$﻿

![[nfa-example-3-1.svg]]

_Упражнение 2:_

$L_2\ =\ \{\text{Множество всех строк, включающие в себя 0}\}$﻿

![[nfa-example-3-2.svg]]

_Упражнение 3:_

$L_3\ =\ \{\text{Множество всех строк, начинающихся на 10}\}$﻿

![[nfa-example-3-3.svg]]

  

_Упражнение 4:_

$L_4\ =\ \{\text{Множество всех строк, включающих в себя 01}\}$﻿

![[nfa-example-3-4.svg]]

  

Упражнение 5:

$L_5\ =\ \{\text{Множество всех строк, кончающихся на 11}\}$﻿

![[nfa-example-3-5.svg]]